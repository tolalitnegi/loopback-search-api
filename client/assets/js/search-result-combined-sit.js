/*! 09-02-2016 09-28-11 */

/** vim: et:ts=4:sw=4:sts=4
 * @license RequireJS 2.1.14 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/requirejs for details
 */
//Not using strict: uneven strict support in browsers, #392, and causes
//problems with requirejs.exec()/transpiler plugins that may not be strict.
/*jslint regexp: true, nomen: true, sloppy: true */
/*global window, navigator, document, importScripts, setTimeout, opera */

var requirejs, require, define;
(function(global) {
    var req, s, head, baseElement, dataMain, src,
        interactiveScript, currentlyAddingScript, mainScript, subPath,
        version = '2.1.14',
        commentRegExp = /(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,
        cjsRequireRegExp = /[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,
        jsSuffixRegExp = /\.js$/,
        currDirRegExp = /^\.\//,
        op = Object.prototype,
        ostring = op.toString,
        hasOwn = op.hasOwnProperty,
        ap = Array.prototype,
        apsp = ap.splice,
        isBrowser = !!(typeof window !== 'undefined' && typeof navigator !== 'undefined' && window.document),
        isWebWorker = !isBrowser && typeof importScripts !== 'undefined',
        //PS3 indicates loaded and complete, but need to wait for complete
        //specifically. Sequence is 'loading', 'loaded', execution,
        // then 'complete'. The UA check is unfortunate, but not sure how
        //to feature test w/o causing perf issues.
        readyRegExp = isBrowser && navigator.platform === 'PLAYSTATION 3' ?
        /^complete$/ : /^(complete|loaded)$/,
        defContextName = '_',
        //Oh the tragedy, detecting opera. See the usage of isOpera for reason.
        isOpera = typeof opera !== 'undefined' && opera.toString() === '[object Opera]',
        contexts = {},
        cfg = {},
        globalDefQueue = [],
        useInteractive = false;

    function isFunction(it) {
        return ostring.call(it) === '[object Function]';
    }

    function isArray(it) {
        return ostring.call(it) === '[object Array]';
    }

    /**
     * Helper function for iterating over an array. If the func returns
     * a true value, it will break out of the loop.
     */
    function each(ary, func) {
        if (ary) {
            var i;
            for (i = 0; i < ary.length; i += 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    /**
     * Helper function for iterating over an array backwards. If the func
     * returns a true value, it will break out of the loop.
     */
    function eachReverse(ary, func) {
        if (ary) {
            var i;
            for (i = ary.length - 1; i > -1; i -= 1) {
                if (ary[i] && func(ary[i], i, ary)) {
                    break;
                }
            }
        }
    }

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    function getOwn(obj, prop) {
        return hasProp(obj, prop) && obj[prop];
    }

    /**
     * Cycles over properties in an object and calls a function for each
     * property value. If the function returns a truthy value, then the
     * iteration is stopped.
     */
    function eachProp(obj, func) {
        var prop;
        for (prop in obj) {
            if (hasProp(obj, prop)) {
                if (func(obj[prop], prop)) {
                    break;
                }
            }
        }
    }

    /**
     * Simple function to mix in properties from source into target,
     * but only if target does not already have a property of the same name.
     */
    function mixin(target, source, force, deepStringMixin) {
        if (source) {
            eachProp(source, function(value, prop) {
                if (force || !hasProp(target, prop)) {
                    if (deepStringMixin && typeof value === 'object' && value &&
                        !isArray(value) && !isFunction(value) &&
                        !(value instanceof RegExp)) {

                        if (!target[prop]) {
                            target[prop] = {};
                        }
                        mixin(target[prop], value, force, deepStringMixin);
                    } else {
                        target[prop] = value;
                    }
                }
            });
        }
        return target;
    }

    //Similar to Function.prototype.bind, but the 'this' object is specified
    //first, since it is easier to read/figure out what 'this' will be.
    function bind(obj, fn) {
        return function() {
            return fn.apply(obj, arguments);
        };
    }

    function scripts() {
        return document.getElementsByTagName('script');
    }

    function defaultOnError(err) {
        throw err;
    }

    //Allow getting a global that is expressed in
    //dot notation, like 'a.b.c'.
    function getGlobal(value) {
        if (!value) {
            return value;
        }
        var g = global;
        each(value.split('.'), function(part) {
            g = g[part];
        });
        return g;
    }

    /**
     * Constructs an error with a pointer to an URL with more information.
     * @param {String} id the error ID that maps to an ID on a web page.
     * @param {String} message human readable error.
     * @param {Error} [err] the original error, if there is one.
     *
     * @returns {Error}
     */
    function makeError(id, msg, err, requireModules) {
        var e = new Error(msg + '\nhttp://requirejs.org/docs/errors.html#' + id);
        e.requireType = id;
        e.requireModules = requireModules;
        if (err) {
            e.originalError = err;
        }
        return e;
    }

    if (typeof define !== 'undefined') {
        //If a define is already in play via another AMD loader,
        //do not overwrite.
        return;
    }

    if (typeof requirejs !== 'undefined') {
        if (isFunction(requirejs)) {
            //Do not overwrite an existing requirejs instance.
            return;
        }
        cfg = requirejs;
        requirejs = undefined;
    }

    //Allow for a require config object
    if (typeof require !== 'undefined' && !isFunction(require)) {
        //assume it is a config object.
        cfg = require;
        require = undefined;
    }

    function newContext(contextName) {
        var inCheckLoaded, Module, context, handlers,
            checkLoadedTimeoutId,
            config = {
                //Defaults. Do not set a default for map
                //config to speed up normalize(), which
                //will run faster if there is no default.
                waitSeconds: 7,
                baseUrl: './',
                paths: {},
                bundles: {},
                pkgs: {},
                shim: {},
                config: {}
            },
            registry = {},
            //registry of just enabled modules, to speed
            //cycle breaking code when lots of modules
            //are registered, but not activated.
            enabledRegistry = {},
            undefEvents = {},
            defQueue = [],
            defined = {},
            urlFetched = {},
            bundlesMap = {},
            requireCounter = 1,
            unnormalizedCounter = 1;

        /**
         * Trims the . and .. from an array of path segments.
         * It will keep a leading path segment if a .. will become
         * the first path segment, to help with module name lookups,
         * which act like paths, but can be remapped. But the end result,
         * all paths that use this function should look normalized.
         * NOTE: this method MODIFIES the input array.
         * @param {Array} ary the array of path segments.
         */
        function trimDots(ary) {
            var i, part;
            for (i = 0; i < ary.length; i++) {
                part = ary[i];
                if (part === '.') {
                    ary.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i == 1 && ary[2] === '..') || ary[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        ary.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
        }

        /**
         * Given a relative module name, like ./something, normalize it to
         * a real name that can be mapped to a path.
         * @param {String} name the relative name
         * @param {String} baseName a real name that the name arg is relative
         * to.
         * @param {Boolean} applyMap apply the map config to the value. Should
         * only be done if this normalization is for a dependency ID.
         * @returns {String} normalized name
         */
        function normalize(name, baseName, applyMap) {
            var pkgMain, mapValue, nameParts, i, j, nameSegment, lastIndex,
                foundMap, foundI, foundStarMap, starI, normalizedBaseParts,
                baseParts = (baseName && baseName.split('/')),
                map = config.map,
                starMap = map && map['*'];

            //Adjust any relative paths.
            if (name) {
                name = name.split('/');
                lastIndex = name.length - 1;

                // If wanting node ID compatibility, strip .js from end
                // of IDs. Have to do this here, and not in nameToUrl
                // because node allows either .js or non .js to map
                // to same file.
                if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                    name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
                }

                // Starts with a '.' so need the baseName
                if (name[0].charAt(0) === '.' && baseParts) {
                    //Convert baseName to array, and lop off the last part,
                    //so that . matches that 'directory' and not name of the baseName's
                    //module. For instance, baseName of 'one/two/three', maps to
                    //'one/two/three.js', but we want the directory, 'one/two' for
                    //this normalization.
                    normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                    name = normalizedBaseParts.concat(name);
                }

                trimDots(name);
                name = name.join('/');
            }

            //Apply map config if available.
            if (applyMap && map && (baseParts || starMap)) {
                nameParts = name.split('/');

                outerLoop: for (i = nameParts.length; i > 0; i -= 1) {
                    nameSegment = nameParts.slice(0, i).join('/');

                    if (baseParts) {
                        //Find the longest baseName segment match in the config.
                        //So, do joins on the biggest to smallest lengths of baseParts.
                        for (j = baseParts.length; j > 0; j -= 1) {
                            mapValue = getOwn(map, baseParts.slice(0, j).join('/'));

                            //baseName segment has config, find if it has one for
                            //this name.
                            if (mapValue) {
                                mapValue = getOwn(mapValue, nameSegment);
                                if (mapValue) {
                                    //Match, update name to the new value.
                                    foundMap = mapValue;
                                    foundI = i;
                                    break outerLoop;
                                }
                            }
                        }
                    }

                    //Check for a star map match, but just hold on to it,
                    //if there is a shorter segment match later in a matching
                    //config, then favor over this star map.
                    if (!foundStarMap && starMap && getOwn(starMap, nameSegment)) {
                        foundStarMap = getOwn(starMap, nameSegment);
                        starI = i;
                    }
                }

                if (!foundMap && foundStarMap) {
                    foundMap = foundStarMap;
                    foundI = starI;
                }

                if (foundMap) {
                    nameParts.splice(0, foundI, foundMap);
                    name = nameParts.join('/');
                }
            }

            // If the name points to a package's name, use
            // the package main instead.
            pkgMain = getOwn(config.pkgs, name);

            return pkgMain ? pkgMain : name;
        }

        function removeScript(name) {
            if (isBrowser) {
                each(scripts(), function(scriptNode) {
                    if (scriptNode.getAttribute('data-requiremodule') === name &&
                        scriptNode.getAttribute('data-requirecontext') === context.contextName) {
                        scriptNode.parentNode.removeChild(scriptNode);
                        return true;
                    }
                });
            }
        }

        function hasPathFallback(id) {
            var pathConfig = getOwn(config.paths, id);
            if (pathConfig && isArray(pathConfig) && pathConfig.length > 1) {
                //Pop off the first array value, since it failed, and
                //retry
                pathConfig.shift();
                context.require.undef(id);

                //Custom require that does not do map translation, since
                //ID is "absolute", already mapped/resolved.
                context.makeRequire(null, {
                    skipMap: true
                })([id]);

                return true;
            }
        }

        //Turns a plugin!resource to [plugin, resource]
        //with the plugin being undefined if the name
        //did not have a plugin prefix.
        function splitPrefix(name) {
            var prefix,
                index = name ? name.indexOf('!') : -1;
            if (index > -1) {
                prefix = name.substring(0, index);
                name = name.substring(index + 1, name.length);
            }
            return [prefix, name];
        }

        /**
         * Creates a module mapping that includes plugin prefix, module
         * name, and path. If parentModuleMap is provided it will
         * also normalize the name via require.normalize()
         *
         * @param {String} name the module name
         * @param {String} [parentModuleMap] parent module map
         * for the module name, used to resolve relative names.
         * @param {Boolean} isNormalized: is the ID already normalized.
         * This is true if this call is done for a define() module ID.
         * @param {Boolean} applyMap: apply the map config to the ID.
         * Should only be true if this map is for a dependency.
         *
         * @returns {Object}
         */
        function makeModuleMap(name, parentModuleMap, isNormalized, applyMap) {
            var url, pluginModule, suffix, nameParts,
                prefix = null,
                parentName = parentModuleMap ? parentModuleMap.name : null,
                originalName = name,
                isDefine = true,
                normalizedName = '';

            //If no name, then it means it is a require call, generate an
            //internal name.
            if (!name) {
                isDefine = false;
                name = '_@r' + (requireCounter += 1);
            }

            nameParts = splitPrefix(name);
            prefix = nameParts[0];
            name = nameParts[1];

            if (prefix) {
                prefix = normalize(prefix, parentName, applyMap);
                pluginModule = getOwn(defined, prefix);
            }

            //Account for relative paths if there is a base name.
            if (name) {
                if (prefix) {
                    if (pluginModule && pluginModule.normalize) {
                        //Plugin is loaded, use its normalize method.
                        normalizedName = pluginModule.normalize(name, function(name) {
                            return normalize(name, parentName, applyMap);
                        });
                    } else {
                        // If nested plugin references, then do not try to
                        // normalize, as it will not normalize correctly. This
                        // places a restriction on resourceIds, and the longer
                        // term solution is not to normalize until plugins are
                        // loaded and all normalizations to allow for async
                        // loading of a loader plugin. But for now, fixes the
                        // common uses. Details in #1131
                        normalizedName = name.indexOf('!') === -1 ?
                            normalize(name, parentName, applyMap) :
                            name;
                    }
                } else {
                    //A regular module.
                    normalizedName = normalize(name, parentName, applyMap);

                    //Normalized name may be a plugin ID due to map config
                    //application in normalize. The map config values must
                    //already be normalized, so do not need to redo that part.
                    nameParts = splitPrefix(normalizedName);
                    prefix = nameParts[0];
                    normalizedName = nameParts[1];
                    isNormalized = true;

                    url = context.nameToUrl(normalizedName);
                }
            }

            //If the id is a plugin id that cannot be determined if it needs
            //normalization, stamp it with a unique ID so two matching relative
            //ids that may conflict can be separate.
            suffix = prefix && !pluginModule && !isNormalized ?
                '_unnormalized' + (unnormalizedCounter += 1) :
                '';

            return {
                prefix: prefix,
                name: normalizedName,
                parentMap: parentModuleMap,
                unnormalized: !!suffix,
                url: url,
                originalName: originalName,
                isDefine: isDefine,
                id: (prefix ?
                    prefix + '!' + normalizedName :
                    normalizedName) + suffix
            };
        }

        function getModule(depMap) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (!mod) {
                mod = registry[id] = new context.Module(depMap);
            }

            return mod;
        }

        function on(depMap, name, fn) {
            var id = depMap.id,
                mod = getOwn(registry, id);

            if (hasProp(defined, id) &&
                (!mod || mod.defineEmitComplete)) {
                if (name === 'defined') {
                    fn(defined[id]);
                }
            } else {
                mod = getModule(depMap);
                if (mod.error && name === 'error') {
                    fn(mod.error);
                } else {
                    mod.on(name, fn);
                }
            }
        }

        function onError(err, errback) {
            var ids = err.requireModules,
                notified = false;

            if (errback) {
                errback(err);
            } else {
                each(ids, function(id) {
                    var mod = getOwn(registry, id);
                    if (mod) {
                        //Set error on module, so it skips timeout checks.
                        mod.error = err;
                        if (mod.events.error) {
                            notified = true;
                            mod.emit('error', err);
                        }
                    }
                });

                if (!notified) {
                    req.onError(err);
                }
            }
        }

        /**
         * Internal method to transfer globalQueue items to this context's
         * defQueue.
         */
        function takeGlobalQueue() {
            //Push all the globalDefQueue items into the context's defQueue
            if (globalDefQueue.length) {
                //Array splice in the values since the context code has a
                //local var ref to defQueue, so cannot just reassign the one
                //on context.
                apsp.apply(defQueue, [defQueue.length, 0].concat(globalDefQueue));
                globalDefQueue = [];
            }
        }

        handlers = {
            'require': function(mod) {
                if (mod.require) {
                    return mod.require;
                } else {
                    return (mod.require = context.makeRequire(mod.map));
                }
            },
            'exports': function(mod) {
                mod.usingExports = true;
                if (mod.map.isDefine) {
                    if (mod.exports) {
                        return (defined[mod.map.id] = mod.exports);
                    } else {
                        return (mod.exports = defined[mod.map.id] = {});
                    }
                }
            },
            'module': function(mod) {
                if (mod.module) {
                    return mod.module;
                } else {
                    return (mod.module = {
                        id: mod.map.id,
                        uri: mod.map.url,
                        config: function() {
                            return getOwn(config.config, mod.map.id) || {};
                        },
                        exports: mod.exports || (mod.exports = {})
                    });
                }
            }
        };

        function cleanRegistry(id) {
            //Clean up machinery used for waiting modules.
            delete registry[id];
            delete enabledRegistry[id];
        }

        function breakCycle(mod, traced, processed) {
            var id = mod.map.id;

            if (mod.error) {
                mod.emit('error', mod.error);
            } else {
                traced[id] = true;
                each(mod.depMaps, function(depMap, i) {
                    var depId = depMap.id,
                        dep = getOwn(registry, depId);

                    //Only force things that have not completed
                    //being defined, so still in the registry,
                    //and only if it has not been matched up
                    //in the module already.
                    if (dep && !mod.depMatched[i] && !processed[depId]) {
                        if (getOwn(traced, depId)) {
                            mod.defineDep(i, defined[depId]);
                            mod.check(); //pass false?
                        } else {
                            breakCycle(dep, traced, processed);
                        }
                    }
                });
                processed[id] = true;
            }
        }

        function checkLoaded() {
            var err, usingPathFallback,
                waitInterval = config.waitSeconds * 1000,
                //It is possible to disable the wait interval by using waitSeconds of 0.
                expired = waitInterval && (context.startTime + waitInterval) < new Date().getTime(),
                noLoads = [],
                reqCalls = [],
                stillLoading = false,
                needCycleCheck = true;

            //Do not bother if this call was a result of a cycle break.
            if (inCheckLoaded) {
                return;
            }

            inCheckLoaded = true;

            //Figure out the state of all the modules.
            eachProp(enabledRegistry, function(mod) {
                var map = mod.map,
                    modId = map.id;

                //Skip things that are not enabled or in error state.
                if (!mod.enabled) {
                    return;
                }

                if (!map.isDefine) {
                    reqCalls.push(mod);
                }

                if (!mod.error) {
                    //If the module should be executed, and it has not
                    //been inited and time is up, remember it.
                    if (!mod.inited && expired) {
                        if (hasPathFallback(modId)) {
                            usingPathFallback = true;
                            stillLoading = true;
                        } else {
                            noLoads.push(modId);
                            removeScript(modId);
                        }
                    } else if (!mod.inited && mod.fetched && map.isDefine) {
                        stillLoading = true;
                        if (!map.prefix) {
                            //No reason to keep looking for unfinished
                            //loading. If the only stillLoading is a
                            //plugin resource though, keep going,
                            //because it may be that a plugin resource
                            //is waiting on a non-plugin cycle.
                            return (needCycleCheck = false);
                        }
                    }
                }
            });

            if (expired && noLoads.length) {
                //If wait time expired, throw error of unloaded modules.
                err = makeError('timeout', 'Load timeout for modules: ' + noLoads, null, noLoads);
                err.contextName = context.contextName;
                return onError(err);
            }

            //Not expired, check for a cycle.
            if (needCycleCheck) {
                each(reqCalls, function(mod) {
                    breakCycle(mod, {}, {});
                });
            }

            //If still waiting on loads, and the waiting load is something
            //other than a plugin resource, or there are still outstanding
            //scripts, then just try back later.
            if ((!expired || usingPathFallback) && stillLoading) {
                //Something is still waiting to load. Wait for it, but only
                //if a timeout is not already in effect.
                if ((isBrowser || isWebWorker) && !checkLoadedTimeoutId) {
                    checkLoadedTimeoutId = setTimeout(function() {
                        checkLoadedTimeoutId = 0;
                        checkLoaded();
                    }, 50);
                }
            }

            inCheckLoaded = false;
        }

        Module = function(map) {
            this.events = getOwn(undefEvents, map.id) || {};
            this.map = map;
            this.shim = getOwn(config.shim, map.id);
            this.depExports = [];
            this.depMaps = [];
            this.depMatched = [];
            this.pluginMaps = {};
            this.depCount = 0;

            /* this.exports this.factory
               this.depMaps = [],
               this.enabled, this.fetched
            */
        };

        Module.prototype = {
            init: function(depMaps, factory, errback, options) {
                options = options || {};

                //Do not do more inits if already done. Can happen if there
                //are multiple define calls for the same module. That is not
                //a normal, common case, but it is also not unexpected.
                if (this.inited) {
                    return;
                }

                this.factory = factory;

                if (errback) {
                    //Register for errors on this module.
                    this.on('error', errback);
                } else if (this.events.error) {
                    //If no errback already, but there are error listeners
                    //on this module, set up an errback to pass to the deps.
                    errback = bind(this, function(err) {
                        this.emit('error', err);
                    });
                }

                //Do a copy of the dependency array, so that
                //source inputs are not modified. For example
                //"shim" deps are passed in here directly, and
                //doing a direct modification of the depMaps array
                //would affect that config.
                this.depMaps = depMaps && depMaps.slice(0);

                this.errback = errback;

                //Indicate this module has be initialized
                this.inited = true;

                this.ignore = options.ignore;

                //Could have option to init this module in enabled mode,
                //or could have been previously marked as enabled. However,
                //the dependencies are not known until init is called. So
                //if enabled previously, now trigger dependencies as enabled.
                if (options.enabled || this.enabled) {
                    //Enable this module and dependencies.
                    //Will call this.check()
                    this.enable();
                } else {
                    this.check();
                }
            },

            defineDep: function(i, depExports) {
                //Because of cycles, defined callback for a given
                //export can be called more than once.
                if (!this.depMatched[i]) {
                    this.depMatched[i] = true;
                    this.depCount -= 1;
                    this.depExports[i] = depExports;
                }
            },

            fetch: function() {
                if (this.fetched) {
                    return;
                }
                this.fetched = true;

                context.startTime = (new Date()).getTime();

                var map = this.map;

                //If the manager is for a plugin managed resource,
                //ask the plugin to load it now.
                if (this.shim) {
                    context.makeRequire(this.map, {
                        enableBuildCallback: true
                    })(this.shim.deps || [], bind(this, function() {
                        return map.prefix ? this.callPlugin() : this.load();
                    }));
                } else {
                    //Regular dependency.
                    return map.prefix ? this.callPlugin() : this.load();
                }
            },

            load: function() {
                var url = this.map.url;

                //Regular dependency.
                if (!urlFetched[url]) {
                    urlFetched[url] = true;
                    context.load(this.map.id, url);
                }
            },

            /**
             * Checks if the module is ready to define itself, and if so,
             * define it.
             */
            check: function() {
                if (!this.enabled || this.enabling) {
                    return;
                }

                var err, cjsModule,
                    id = this.map.id,
                    depExports = this.depExports,
                    exports = this.exports,
                    factory = this.factory;

                if (!this.inited) {
                    this.fetch();
                } else if (this.error) {
                    this.emit('error', this.error);
                } else if (!this.defining) {
                    //The factory could trigger another require call
                    //that would result in checking this module to
                    //define itself again. If already in the process
                    //of doing that, skip this work.
                    this.defining = true;

                    if (this.depCount < 1 && !this.defined) {
                        if (isFunction(factory)) {
                            //If there is an error listener, favor passing
                            //to that instead of throwing an error. However,
                            //only do it for define()'d  modules. require
                            //errbacks should not be called for failures in
                            //their callbacks (#699). However if a global
                            //onError is set, use that.
                            if ((this.events.error && this.map.isDefine) ||
                                req.onError !== defaultOnError) {
                                try {
                                    exports = context.execCb(id, factory, depExports, exports);
                                } catch (e) {
                                    err = e;
                                }
                            } else {
                                exports = context.execCb(id, factory, depExports, exports);
                            }

                            // Favor return value over exports. If node/cjs in play,
                            // then will not have a return value anyway. Favor
                            // module.exports assignment over exports object.
                            if (this.map.isDefine && exports === undefined) {
                                cjsModule = this.module;
                                if (cjsModule) {
                                    exports = cjsModule.exports;
                                } else if (this.usingExports) {
                                    //exports already set the defined value.
                                    exports = this.exports;
                                }
                            }

                            if (err) {
                                err.requireMap = this.map;
                                err.requireModules = this.map.isDefine ? [this.map.id] : null;
                                err.requireType = this.map.isDefine ? 'define' : 'require';
                                return onError((this.error = err));
                            }

                        } else {
                            //Just a literal value
                            exports = factory;
                        }

                        this.exports = exports;

                        if (this.map.isDefine && !this.ignore) {
                            defined[id] = exports;

                            if (req.onResourceLoad) {
                                req.onResourceLoad(context, this.map, this.depMaps);
                            }
                        }

                        //Clean up
                        cleanRegistry(id);

                        this.defined = true;
                    }

                    //Finished the define stage. Allow calling check again
                    //to allow define notifications below in the case of a
                    //cycle.
                    this.defining = false;

                    if (this.defined && !this.defineEmitted) {
                        this.defineEmitted = true;
                        this.emit('defined', this.exports);
                        this.defineEmitComplete = true;
                    }

                }
            },

            callPlugin: function() {
                var map = this.map,
                    id = map.id,
                    //Map already normalized the prefix.
                    pluginMap = makeModuleMap(map.prefix);

                //Mark this as a dependency for this plugin, so it
                //can be traced for cycles.
                this.depMaps.push(pluginMap);

                on(pluginMap, 'defined', bind(this, function(plugin) {
                    var load, normalizedMap, normalizedMod,
                        bundleId = getOwn(bundlesMap, this.map.id),
                        name = this.map.name,
                        parentName = this.map.parentMap ? this.map.parentMap.name : null,
                        localRequire = context.makeRequire(map.parentMap, {
                            enableBuildCallback: true
                        });

                    //If current map is not normalized, wait for that
                    //normalized name to load instead of continuing.
                    if (this.map.unnormalized) {
                        //Normalize the ID if the plugin allows it.
                        if (plugin.normalize) {
                            name = plugin.normalize(name, function(name) {
                                return normalize(name, parentName, true);
                            }) || '';
                        }

                        //prefix and name should already be normalized, no need
                        //for applying map config again either.
                        normalizedMap = makeModuleMap(map.prefix + '!' + name,
                            this.map.parentMap);
                        on(normalizedMap,
                            'defined', bind(this, function(value) {
                                this.init([], function() {
                                    return value;
                                }, null, {
                                    enabled: true,
                                    ignore: true
                                });
                            }));

                        normalizedMod = getOwn(registry, normalizedMap.id);
                        if (normalizedMod) {
                            //Mark this as a dependency for this plugin, so it
                            //can be traced for cycles.
                            this.depMaps.push(normalizedMap);

                            if (this.events.error) {
                                normalizedMod.on('error', bind(this, function(err) {
                                    this.emit('error', err);
                                }));
                            }
                            normalizedMod.enable();
                        }

                        return;
                    }

                    //If a paths config, then just load that file instead to
                    //resolve the plugin, as it is built into that paths layer.
                    if (bundleId) {
                        this.map.url = context.nameToUrl(bundleId);
                        this.load();
                        return;
                    }

                    load = bind(this, function(value) {
                        this.init([], function() {
                            return value;
                        }, null, {
                            enabled: true
                        });
                    });

                    load.error = bind(this, function(err) {
                        this.inited = true;
                        this.error = err;
                        err.requireModules = [id];

                        //Remove temp unnormalized modules for this module,
                        //since they will never be resolved otherwise now.
                        eachProp(registry, function(mod) {
                            if (mod.map.id.indexOf(id + '_unnormalized') === 0) {
                                cleanRegistry(mod.map.id);
                            }
                        });

                        onError(err);
                    });

                    //Allow plugins to load other code without having to know the
                    //context or how to 'complete' the load.
                    load.fromText = bind(this, function(text, textAlt) {
                        /*jslint evil: true */
                        var moduleName = map.name,
                            moduleMap = makeModuleMap(moduleName),
                            hasInteractive = useInteractive;

                        //As of 2.1.0, support just passing the text, to reinforce
                        //fromText only being called once per resource. Still
                        //support old style of passing moduleName but discard
                        //that moduleName in favor of the internal ref.
                        if (textAlt) {
                            text = textAlt;
                        }

                        //Turn off interactive script matching for IE for any define
                        //calls in the text, then turn it back on at the end.
                        if (hasInteractive) {
                            useInteractive = false;
                        }

                        //Prime the system by creating a module instance for
                        //it.
                        getModule(moduleMap);

                        //Transfer any config to this other module.
                        if (hasProp(config.config, id)) {
                            config.config[moduleName] = config.config[id];
                        }

                        try {
                            req.exec(text);
                        } catch (e) {
                            return onError(makeError('fromtexteval',
                                'fromText eval for ' + id +
                                ' failed: ' + e,
                                e, [id]));
                        }

                        if (hasInteractive) {
                            useInteractive = true;
                        }

                        //Mark this as a dependency for the plugin
                        //resource
                        this.depMaps.push(moduleMap);

                        //Support anonymous modules.
                        context.completeLoad(moduleName);

                        //Bind the value of that module to the value for this
                        //resource ID.
                        localRequire([moduleName], load);
                    });

                    //Use parentName here since the plugin's name is not reliable,
                    //could be some weird string with no path that actually wants to
                    //reference the parentName's path.
                    plugin.load(map.name, localRequire, load, config);
                }));

                context.enable(pluginMap, this);
                this.pluginMaps[pluginMap.id] = pluginMap;
            },

            enable: function() {
                enabledRegistry[this.map.id] = this;
                this.enabled = true;

                //Set flag mentioning that the module is enabling,
                //so that immediate calls to the defined callbacks
                //for dependencies do not trigger inadvertent load
                //with the depCount still being zero.
                this.enabling = true;

                //Enable each dependency
                each(this.depMaps, bind(this, function(depMap, i) {
                    var id, mod, handler;

                    if (typeof depMap === 'string') {
                        //Dependency needs to be converted to a depMap
                        //and wired up to this module.
                        depMap = makeModuleMap(depMap, (this.map.isDefine ? this.map : this.map.parentMap),
                            false, !this.skipMap);
                        this.depMaps[i] = depMap;

                        handler = getOwn(handlers, depMap.id);

                        if (handler) {
                            this.depExports[i] = handler(this);
                            return;
                        }

                        this.depCount += 1;

                        on(depMap, 'defined', bind(this, function(depExports) {
                            this.defineDep(i, depExports);
                            this.check();
                        }));

                        if (this.errback) {
                            on(depMap, 'error', bind(this, this.errback));
                        }
                    }

                    id = depMap.id;
                    mod = registry[id];

                    //Skip special modules like 'require', 'exports', 'module'
                    //Also, don't call enable if it is already enabled,
                    //important in circular dependency cases.
                    if (!hasProp(handlers, id) && mod && !mod.enabled) {
                        context.enable(depMap, this);
                    }
                }));

                //Enable each plugin that is used in
                //a dependency
                eachProp(this.pluginMaps, bind(this, function(pluginMap) {
                    var mod = getOwn(registry, pluginMap.id);
                    if (mod && !mod.enabled) {
                        context.enable(pluginMap, this);
                    }
                }));

                this.enabling = false;

                this.check();
            },

            on: function(name, cb) {
                var cbs = this.events[name];
                if (!cbs) {
                    cbs = this.events[name] = [];
                }
                cbs.push(cb);
            },

            emit: function(name, evt) {
                each(this.events[name], function(cb) {
                    cb(evt);
                });
                if (name === 'error') {
                    //Now that the error handler was triggered, remove
                    //the listeners, since this broken Module instance
                    //can stay around for a while in the registry.
                    delete this.events[name];
                }
            }
        };

        function callGetModule(args) {
            //Skip modules already defined.
            if (!hasProp(defined, args[0])) {
                getModule(makeModuleMap(args[0], null, true)).init(args[1], args[2]);
            }
        }

        function removeListener(node, func, name, ieName) {
            //Favor detachEvent because of IE9
            //issue, see attachEvent/addEventListener comment elsewhere
            //in this file.
            if (node.detachEvent && !isOpera) {
                //Probably IE. If not it will throw an error, which will be
                //useful to know.
                if (ieName) {
                    node.detachEvent(ieName, func);
                }
            } else {
                node.removeEventListener(name, func, false);
            }
        }

        /**
         * Given an event from a script node, get the requirejs info from it,
         * and then removes the event listeners on the node.
         * @param {Event} evt
         * @returns {Object}
         */
        function getScriptData(evt) {
            //Using currentTarget instead of target for Firefox 2.0's sake. Not
            //all old browsers will be supported, but this one was easy enough
            //to support and still makes sense.
            var node = evt.currentTarget || evt.srcElement;

            //Remove the listeners once here.
            removeListener(node, context.onScriptLoad, 'load', 'onreadystatechange');
            removeListener(node, context.onScriptError, 'error');

            return {
                node: node,
                id: node && node.getAttribute('data-requiremodule')
            };
        }

        function intakeDefines() {
            var args;

            //Any defined modules in the global queue, intake them now.
            takeGlobalQueue();

            //Make sure any remaining defQueue items get properly processed.
            while (defQueue.length) {
                args = defQueue.shift();
                if (args[0] === null) {
                    return onError(makeError('mismatch', 'Mismatched anonymous define() module: ' + args[args.length - 1]));
                } else {
                    //args are id, deps, factory. Should be normalized by the
                    //define() function.
                    callGetModule(args);
                }
            }
        }

        context = {
            config: config,
            contextName: contextName,
            registry: registry,
            defined: defined,
            urlFetched: urlFetched,
            defQueue: defQueue,
            Module: Module,
            makeModuleMap: makeModuleMap,
            nextTick: req.nextTick,
            onError: onError,

            /**
             * Set a configuration for the context.
             * @param {Object} cfg config object to integrate.
             */
            configure: function(cfg) {
                //Make sure the baseUrl ends in a slash.
                if (cfg.baseUrl) {
                    if (cfg.baseUrl.charAt(cfg.baseUrl.length - 1) !== '/') {
                        cfg.baseUrl += '/';
                    }
                }

                //Save off the paths since they require special processing,
                //they are additive.
                var shim = config.shim,
                    objs = {
                        paths: true,
                        bundles: true,
                        config: true,
                        map: true
                    };

                eachProp(cfg, function(value, prop) {
                    if (objs[prop]) {
                        if (!config[prop]) {
                            config[prop] = {};
                        }
                        mixin(config[prop], value, true, true);
                    } else {
                        config[prop] = value;
                    }
                });

                //Reverse map the bundles
                if (cfg.bundles) {
                    eachProp(cfg.bundles, function(value, prop) {
                        each(value, function(v) {
                            if (v !== prop) {
                                bundlesMap[v] = prop;
                            }
                        });
                    });
                }

                //Merge shim
                if (cfg.shim) {
                    eachProp(cfg.shim, function(value, id) {
                        //Normalize the structure
                        if (isArray(value)) {
                            value = {
                                deps: value
                            };
                        }
                        if ((value.exports || value.init) && !value.exportsFn) {
                            value.exportsFn = context.makeShimExports(value);
                        }
                        shim[id] = value;
                    });
                    config.shim = shim;
                }

                //Adjust packages if necessary.
                if (cfg.packages) {
                    each(cfg.packages, function(pkgObj) {
                        var location, name;

                        pkgObj = typeof pkgObj === 'string' ? {
                            name: pkgObj
                        } : pkgObj;

                        name = pkgObj.name;
                        location = pkgObj.location;
                        if (location) {
                            config.paths[name] = pkgObj.location;
                        }

                        //Save pointer to main module ID for pkg name.
                        //Remove leading dot in main, so main paths are normalized,
                        //and remove any trailing .js, since different package
                        //envs have different conventions: some use a module name,
                        //some use a file name.
                        config.pkgs[name] = pkgObj.name + '/' + (pkgObj.main || 'main')
                            .replace(currDirRegExp, '')
                            .replace(jsSuffixRegExp, '');
                    });
                }

                //If there are any "waiting to execute" modules in the registry,
                //update the maps for them, since their info, like URLs to load,
                //may have changed.
                eachProp(registry, function(mod, id) {
                    //If module already has init called, since it is too
                    //late to modify them, and ignore unnormalized ones
                    //since they are transient.
                    if (!mod.inited && !mod.map.unnormalized) {
                        mod.map = makeModuleMap(id);
                    }
                });

                //If a deps array or a config callback is specified, then call
                //require with those args. This is useful when require is defined as a
                //config object before require.js is loaded.
                if (cfg.deps || cfg.callback) {
                    context.require(cfg.deps || [], cfg.callback);
                }
            },

            makeShimExports: function(value) {
                function fn() {
                    var ret;
                    if (value.init) {
                        ret = value.init.apply(global, arguments);
                    }
                    return ret || (value.exports && getGlobal(value.exports));
                }
                return fn;
            },

            makeRequire: function(relMap, options) {
                options = options || {};

                function localRequire(deps, callback, errback) {
                    var id, map, requireMod;

                    if (options.enableBuildCallback && callback && isFunction(callback)) {
                        callback.__requireJsBuild = true;
                    }

                    if (typeof deps === 'string') {
                        if (isFunction(callback)) {
                            //Invalid call
                            return onError(makeError('requireargs', 'Invalid require call'), errback);
                        }

                        //If require|exports|module are requested, get the
                        //value for them from the special handlers. Caveat:
                        //this only works while module is being defined.
                        if (relMap && hasProp(handlers, deps)) {
                            return handlers[deps](registry[relMap.id]);
                        }

                        //Synchronous access to one module. If require.get is
                        //available (as in the Node adapter), prefer that.
                        if (req.get) {
                            return req.get(context, deps, relMap, localRequire);
                        }

                        //Normalize module name, if it contains . or ..
                        map = makeModuleMap(deps, relMap, false, true);
                        id = map.id;

                        if (!hasProp(defined, id)) {
                            return onError(makeError('notloaded', 'Module name "' +
                                id +
                                '" has not been loaded yet for context: ' +
                                contextName +
                                (relMap ? '' : '. Use require([])')));
                        }
                        return defined[id];
                    }

                    //Grab defines waiting in the global queue.
                    intakeDefines();

                    //Mark all the dependencies as needing to be loaded.
                    context.nextTick(function() {
                        //Some defines could have been added since the
                        //require call, collect them.
                        intakeDefines();

                        requireMod = getModule(makeModuleMap(null, relMap));

                        //Store if map config should be applied to this require
                        //call for dependencies.
                        requireMod.skipMap = options.skipMap;

                        requireMod.init(deps, callback, errback, {
                            enabled: true
                        });

                        checkLoaded();
                    });

                    return localRequire;
                }

                mixin(localRequire, {
                    isBrowser: isBrowser,

                    /**
                     * Converts a module name + .extension into an URL path.
                     * *Requires* the use of a module name. It does not support using
                     * plain URLs like nameToUrl.
                     */
                    toUrl: function(moduleNamePlusExt) {
                        var ext,
                            index = moduleNamePlusExt.lastIndexOf('.'),
                            segment = moduleNamePlusExt.split('/')[0],
                            isRelative = segment === '.' || segment === '..';

                        //Have a file extension alias, and it is not the
                        //dots from a relative path.
                        if (index !== -1 && (!isRelative || index > 1)) {
                            ext = moduleNamePlusExt.substring(index, moduleNamePlusExt.length);
                            moduleNamePlusExt = moduleNamePlusExt.substring(0, index);
                        }

                        return context.nameToUrl(normalize(moduleNamePlusExt,
                            relMap && relMap.id, true), ext, true);
                    },

                    defined: function(id) {
                        return hasProp(defined, makeModuleMap(id, relMap, false, true).id);
                    },

                    specified: function(id) {
                        id = makeModuleMap(id, relMap, false, true).id;
                        return hasProp(defined, id) || hasProp(registry, id);
                    }
                });

                //Only allow undef on top level require calls
                if (!relMap) {
                    localRequire.undef = function(id) {
                        //Bind any waiting define() calls to this context,
                        //fix for #408
                        takeGlobalQueue();

                        var map = makeModuleMap(id, relMap, true),
                            mod = getOwn(registry, id);

                        removeScript(id);

                        delete defined[id];
                        delete urlFetched[map.url];
                        delete undefEvents[id];

                        //Clean queued defines too. Go backwards
                        //in array so that the splices do not
                        //mess up the iteration.
                        eachReverse(defQueue, function(args, i) {
                            if (args[0] === id) {
                                defQueue.splice(i, 1);
                            }
                        });

                        if (mod) {
                            //Hold on to listeners in case the
                            //module will be attempted to be reloaded
                            //using a different config.
                            if (mod.events.defined) {
                                undefEvents[id] = mod.events;
                            }

                            cleanRegistry(id);
                        }
                    };
                }

                return localRequire;
            },

            /**
             * Called to enable a module if it is still in the registry
             * awaiting enablement. A second arg, parent, the parent module,
             * is passed in for context, when this method is overridden by
             * the optimizer. Not shown here to keep code compact.
             */
            enable: function(depMap) {
                var mod = getOwn(registry, depMap.id);
                if (mod) {
                    getModule(depMap).enable();
                }
            },

            /**
             * Internal method used by environment adapters to complete a load event.
             * A load event could be a script load or just a load pass from a synchronous
             * load call.
             * @param {String} moduleName the name of the module to potentially complete.
             */
            completeLoad: function(moduleName) {
                var found, args, mod,
                    shim = getOwn(config.shim, moduleName) || {},
                    shExports = shim.exports;

                takeGlobalQueue();

                while (defQueue.length) {
                    args = defQueue.shift();
                    if (args[0] === null) {
                        args[0] = moduleName;
                        //If already found an anonymous module and bound it
                        //to this name, then this is some other anon module
                        //waiting for its completeLoad to fire.
                        if (found) {
                            break;
                        }
                        found = true;
                    } else if (args[0] === moduleName) {
                        //Found matching define call for this script!
                        found = true;
                    }

                    callGetModule(args);
                }

                //Do this after the cycle of callGetModule in case the result
                //of those calls/init calls changes the registry.
                mod = getOwn(registry, moduleName);

                if (!found && !hasProp(defined, moduleName) && mod && !mod.inited) {
                    if (config.enforceDefine && (!shExports || !getGlobal(shExports))) {
                        if (hasPathFallback(moduleName)) {
                            return;
                        } else {
                            return onError(makeError('nodefine',
                                'No define call for ' + moduleName,
                                null, [moduleName]));
                        }
                    } else {
                        //A script that does not call define(), so just simulate
                        //the call for it.
                        callGetModule([moduleName, (shim.deps || []), shim.exportsFn]);
                    }
                }

                checkLoaded();
            },

            /**
             * Converts a module name to a file path. Supports cases where
             * moduleName may actually be just an URL.
             * Note that it **does not** call normalize on the moduleName,
             * it is assumed to have already been normalized. This is an
             * internal API, not a public one. Use toUrl for the public API.
             */
            nameToUrl: function(moduleName, ext, skipExt) {
                var paths, syms, i, parentModule, url,
                    parentPath, bundleId,
                    pkgMain = getOwn(config.pkgs, moduleName);

                if (pkgMain) {
                    moduleName = pkgMain;
                }

                bundleId = getOwn(bundlesMap, moduleName);

                if (bundleId) {
                    return context.nameToUrl(bundleId, ext, skipExt);
                }

                //If a colon is in the URL, it indicates a protocol is used and it is just
                //an URL to a file, or if it starts with a slash, contains a query arg (i.e. ?)
                //or ends with .js, then assume the user meant to use an url and not a module id.
                //The slash is important for protocol-less URLs as well as full paths.
                if (req.jsExtRegExp.test(moduleName)) {
                    //Just a plain path, not module name lookup, so just return it.
                    //Add extension if it is included. This is a bit wonky, only non-.js things pass
                    //an extension, this method probably needs to be reworked.
                    url = moduleName + (ext || '');
                } else {
                    //A module that needs to be converted to a path.
                    paths = config.paths;

                    syms = moduleName.split('/');
                    //For each module name segment, see if there is a path
                    //registered for it. Start with most specific name
                    //and work up from it.
                    for (i = syms.length; i > 0; i -= 1) {
                        parentModule = syms.slice(0, i).join('/');

                        parentPath = getOwn(paths, parentModule);
                        if (parentPath) {
                            //If an array, it means there are a few choices,
                            //Choose the one that is desired
                            if (isArray(parentPath)) {
                                parentPath = parentPath[0];
                            }
                            syms.splice(0, i, parentPath);
                            break;
                        }
                    }

                    //Join the path parts together, then figure out if baseUrl is needed.
                    url = syms.join('/');
                    url += (ext || (/^data\:|\?/.test(url) || skipExt ? '' : '.js'));
                    url = (url.charAt(0) === '/' || url.match(/^[\w\+\.\-]+:/) ? '' : config.baseUrl) + url;
                }

                return config.urlArgs ? url +
                    ((url.indexOf('?') === -1 ? '?' : '&') +
                        config.urlArgs) : url;
            },

            //Delegates to req.load. Broken out as a separate function to
            //allow overriding in the optimizer.
            load: function(id, url) {
                req.load(context, id, url);
            },

            /**
             * Executes a module callback function. Broken out as a separate function
             * solely to allow the build system to sequence the files in the built
             * layer in the right sequence.
             *
             * @private
             */
            execCb: function(name, callback, args, exports) {
                return callback.apply(exports, args);
            },

            /**
             * callback for script loads, used to check status of loading.
             *
             * @param {Event} evt the event from the browser for the script
             * that was loaded.
             */
            onScriptLoad: function(evt) {
                //Using currentTarget instead of target for Firefox 2.0's sake. Not
                //all old browsers will be supported, but this one was easy enough
                //to support and still makes sense.
                if (evt.type === 'load' ||
                    (readyRegExp.test((evt.currentTarget || evt.srcElement).readyState))) {
                    //Reset interactive script so a script node is not held onto for
                    //to long.
                    interactiveScript = null;

                    //Pull out the name of the module and the context.
                    var data = getScriptData(evt);
                    context.completeLoad(data.id);
                }
            },

            /**
             * Callback for script errors.
             */
            onScriptError: function(evt) {
                var data = getScriptData(evt);
                if (!hasPathFallback(data.id)) {
                    return onError(makeError('scripterror', 'Script error for: ' + data.id, evt, [data.id]));
                }
            }
        };

        context.require = context.makeRequire();
        return context;
    }

    /**
     * Main entry point.
     *
     * If the only argument to require is a string, then the module that
     * is represented by that string is fetched for the appropriate context.
     *
     * If the first argument is an array, then it will be treated as an array
     * of dependency string names to fetch. An optional function callback can
     * be specified to execute when all of those dependencies are available.
     *
     * Make a local req variable to help Caja compliance (it assumes things
     * on a require that are not standardized), and to give a short
     * name for minification/local scope use.
     */
    req = requirejs = function(deps, callback, errback, optional) {

        //Find the right context, use default
        var context, config,
            contextName = defContextName;

        // Determine if have config object in the call.
        if (!isArray(deps) && typeof deps !== 'string') {
            // deps is a config object
            config = deps;
            if (isArray(callback)) {
                // Adjust args if there are dependencies
                deps = callback;
                callback = errback;
                errback = optional;
            } else {
                deps = [];
            }
        }

        if (config && config.context) {
            contextName = config.context;
        }

        context = getOwn(contexts, contextName);
        if (!context) {
            context = contexts[contextName] = req.s.newContext(contextName);
        }

        if (config) {
            context.configure(config);
        }

        return context.require(deps, callback, errback);
    };

    /**
     * Support require.config() to make it easier to cooperate with other
     * AMD loaders on globally agreed names.
     */
    req.config = function(config) {
        return req(config);
    };

    /**
     * Execute something after the current tick
     * of the event loop. Override for other envs
     * that have a better solution than setTimeout.
     * @param  {Function} fn function to execute later.
     */
    req.nextTick = typeof setTimeout !== 'undefined' ? function(fn) {
        setTimeout(fn, 4);
    } : function(fn) {
        fn();
    };

    /**
     * Export require as a global, but only if it does not already exist.
     */
    if (!require) {
        require = req;
    }

    req.version = version;

    //Used to filter out dependencies that are already paths.
    req.jsExtRegExp = /^\/|:|\?|\.js$/;
    req.isBrowser = isBrowser;
    s = req.s = {
        contexts: contexts,
        newContext: newContext
    };

    //Create default context.
    req({});

    //Exports some context-sensitive methods on global require.
    each([
        'toUrl',
        'undef',
        'defined',
        'specified'
    ], function(prop) {
        //Reference from contexts instead of early binding to default context,
        //so that during builds, the latest instance of the default context
        //with its config gets used.
        req[prop] = function() {
            var ctx = contexts[defContextName];
            return ctx.require[prop].apply(ctx, arguments);
        };
    });

    if (isBrowser) {
        head = s.head = document.getElementsByTagName('head')[0];
        //If BASE tag is in play, using appendChild is a problem for IE6.
        //When that browser dies, this can be removed. Details in this jQuery bug:
        //http://dev.jquery.com/ticket/2709
        baseElement = document.getElementsByTagName('base')[0];
        if (baseElement) {
            head = s.head = baseElement.parentNode;
        }
    }

    /**
     * Any errors that require explicitly generates will be passed to this
     * function. Intercept/override it if you want custom error handling.
     * @param {Error} err the error object.
     */
    req.onError = defaultOnError;

    /**
     * Creates the node for the load command. Only used in browser envs.
     */
    req.createNode = function(config, moduleName, url) {
        var node = config.xhtml ?
            document.createElementNS('http://www.w3.org/1999/xhtml', 'html:script') :
            document.createElement('script');
        node.type = config.scriptType || 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        return node;
    };

    /**
     * Does the request to load a module for the browser case.
     * Make this a separate function to allow other environments
     * to override it.
     *
     * @param {Object} context the require context to find state.
     * @param {String} moduleName the name of the module.
     * @param {Object} url the URL to the module.
     */
    req.load = function(context, moduleName, url) {
        var config = (context && context.config) || {},
            node;
        if (isBrowser) {
            //In the browser so use a script tag
            node = req.createNode(config, moduleName, url);

            node.setAttribute('data-requirecontext', context.contextName);
            node.setAttribute('data-requiremodule', moduleName);

            //Set up load listener. Test attachEvent first because IE9 has
            //a subtle issue in its addEventListener and script onload firings
            //that do not match the behavior of all other browsers with
            //addEventListener support, which fire the onload event for a
            //script right after the script execution. See:
            //https://connect.microsoft.com/IE/feedback/details/648057/script-onload-event-is-not-fired-immediately-after-script-execution
            //UNFORTUNATELY Opera implements attachEvent but does not follow the script
            //script execution mode.
            if (node.attachEvent &&
                //Check if node.attachEvent is artificially added by custom script or
                //natively supported by browser
                //read https://github.com/jrburke/requirejs/issues/187
                //if we can NOT find [native code] then it must NOT natively supported.
                //in IE8, node.attachEvent does not have toString()
                //Note the test for "[native code" with no closing brace, see:
                //https://github.com/jrburke/requirejs/issues/273
                !(node.attachEvent.toString && node.attachEvent.toString().indexOf('[native code') < 0) &&
                !isOpera) {
                //Probably IE. IE (at least 6-8) do not fire
                //script onload right after executing the script, so
                //we cannot tie the anonymous define call to a name.
                //However, IE reports the script as being in 'interactive'
                //readyState at the time of the define call.
                useInteractive = true;

                node.attachEvent('onreadystatechange', context.onScriptLoad);
                //It would be great to add an error handler here to catch
                //404s in IE9+. However, onreadystatechange will fire before
                //the error handler, so that does not help. If addEventListener
                //is used, then IE will fire error before load, but we cannot
                //use that pathway given the connect.microsoft.com issue
                //mentioned above about not doing the 'script execute,
                //then fire the script load event listener before execute
                //next script' that other browsers do.
                //Best hope: IE10 fixes the issues,
                //and then destroys all installs of IE 6-9.
                //node.attachEvent('onerror', context.onScriptError);
            } else {
                node.addEventListener('load', context.onScriptLoad, false);
                node.addEventListener('error', context.onScriptError, false);
            }
            node.src = url;

            //For some cache cases in IE 6-8, the script executes before the end
            //of the appendChild execution, so to tie an anonymous define
            //call to the module name (which is stored on the node), hold on
            //to a reference to this node, but clear after the DOM insertion.
            currentlyAddingScript = node;
            if (baseElement) {
                head.insertBefore(node, baseElement);
            } else {
                head.appendChild(node);
            }
            currentlyAddingScript = null;

            return node;
        } else if (isWebWorker) {
            try {
                //In a web worker, use importScripts. This is not a very
                //efficient use of importScripts, importScripts will block until
                //its script is downloaded and evaluated. However, if web workers
                //are in play, the expectation that a build has been done so that
                //only one script needs to be loaded anyway. This may need to be
                //reevaluated if other use cases become common.
                importScripts(url);

                //Account for anonymous modules
                context.completeLoad(moduleName);
            } catch (e) {
                context.onError(makeError('importscripts',
                    'importScripts failed for ' +
                    moduleName + ' at ' + url,
                    e, [moduleName]));
            }
        }
    };

    function getInteractiveScript() {
        if (interactiveScript && interactiveScript.readyState === 'interactive') {
            return interactiveScript;
        }

        eachReverse(scripts(), function(script) {
            if (script.readyState === 'interactive') {
                return (interactiveScript = script);
            }
        });
        return interactiveScript;
    }

    //Look for a data-main script attribute, which could also adjust the baseUrl.
    if (isBrowser && !cfg.skipDataMain) {
        //Figure out baseUrl. Get it from the script tag with require.js in it.
        eachReverse(scripts(), function(script) {
            //Set the 'head' where we can append children by
            //using the script's parent.
            if (!head) {
                head = script.parentNode;
            }

            //Look for a data-main attribute to set main script for the page
            //to load. If it is there, the path to data main becomes the
            //baseUrl, if it is not already set.
            dataMain = script.getAttribute('data-main');
            if (dataMain) {
                //Preserve dataMain in case it is a path (i.e. contains '?')
                mainScript = dataMain;

                //Set final baseUrl if there is not already an explicit one.
                if (!cfg.baseUrl) {
                    //Pull off the directory of data-main for use as the
                    //baseUrl.
                    src = mainScript.split('/');
                    mainScript = src.pop();
                    subPath = src.length ? src.join('/') + '/' : './';

                    cfg.baseUrl = subPath;
                }

                //Strip off any trailing .js since mainScript is now
                //like a module name.
                mainScript = mainScript.replace(jsSuffixRegExp, '');

                //If mainScript is still a path, fall back to dataMain
                if (req.jsExtRegExp.test(mainScript)) {
                    mainScript = dataMain;
                }

                //Put the data-main script in the files to load.
                cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript];

                return true;
            }
        });
    }

    /**
     * The function that handles definitions of modules. Differs from
     * require() in that a string for the module should be the first argument,
     * and the function to execute after dependencies are loaded should
     * return a value to define the module corresponding to the first argument's
     * name.
     */
    define = function(name, deps, callback) {
        var node, context;

        //Allow for anonymous modules
        if (typeof name !== 'string') {
            //Adjust args appropriately
            callback = deps;
            deps = name;
            name = null;
        }

        //This module may not have dependencies
        if (!isArray(deps)) {
            callback = deps;
            deps = null;
        }

        //If no name, and callback is a function, then figure out if it a
        //CommonJS thing with dependencies.
        if (!deps && isFunction(callback)) {
            deps = [];
            //Remove comments from the callback string,
            //look for require calls, and pull them into the dependencies,
            //but only if there are function args.
            if (callback.length) {
                callback
                    .toString()
                    .replace(commentRegExp, '')
                    .replace(cjsRequireRegExp, function(match, dep) {
                        deps.push(dep);
                    });

                //May be a CommonJS thing even without require calls, but still
                //could use exports, and module. Avoid doing exports and module
                //work though if it just needs require.
                //REQUIRES the function to expect the CommonJS variables in the
                //order listed below.
                deps = (callback.length === 1 ? ['require'] : ['require', 'exports', 'module']).concat(deps);
            }
        }

        //If in IE 6-8 and hit an anonymous define() call, do the interactive
        //work.
        if (useInteractive) {
            node = currentlyAddingScript || getInteractiveScript();
            if (node) {
                if (!name) {
                    name = node.getAttribute('data-requiremodule');
                }
                context = contexts[node.getAttribute('data-requirecontext')];
            }
        }

        //Always save off evaluating the def call until the script onload handler.
        //This allows multiple modules to be in a file without prematurely
        //tracing dependencies, and allows for anonymous module support,
        //where the module name is not known until the script onload event
        //occurs. If no context, use the global queue, and get it processed
        //in the onscript load callback.
        (context ? context.defQueue : globalDefQueue).push([name, deps, callback]);
    };

    define.amd = {
        jQuery: true
    };


    /**
     * Executes the text. Normally just uses eval, but can be modified
     * to use a better, environment-specific call. Only used for transpiling
     * loader plugins, not for plain JS modules.
     * @param {String} text the text to execute/evaluate.
     */
    req.exec = function(text) {
        /*jslint evil: true */
        return eval(text);
    };

    //Set up with config info.
    req(cfg);
}(this));

define("vendor/require", function() {});

/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define('jqueryCookie', ['jquery'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function(key, value, options) {

        // Write

        if (value !== undefined && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires,
                    t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }

            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path ? '; path=' + options.path : '',
                options.domain ? '; domain=' + options.domain : '',
                options.secure ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function(key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }

        // Must not alter options, thus extending a fresh object...
        $.cookie(key, '', $.extend({}, options, {
            expires: -1
        }));
        return !$.cookie(key);
    };

}));

/* jQuery Tiny Pub/Sub - v0.7 - 10/27/2011
 * http://benalman.com/
 * Copyright (c) 2011 "Cowboy" Ben Alman; Licensed MIT, GPL */
jQuery = jQuery || $;
(function(a) {
    var b = a({});
    a.subscribe = function() {
        b.on.apply(b, arguments)
    }, a.unsubscribe = function() {
        b.off.apply(b, arguments)
    }, a.publish = function() {
        b.trigger.apply(b, arguments)
    }
})(jQuery);
define("pubSub", ["jquery"], (function(global) {
    return function() {
        var ret, fn;
        return ret || global.PubSub;
    };
}(this)));

/*!

 handlebars v1.3.0

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
var Handlebars = function() {
    var a = function() {
            "use strict";

            function a(a) {
                this.string = a
            }
            var b;
            return a.prototype.toString = function() {
                return "" + this.string
            }, b = a
        }(),
        b = function(a) {
            "use strict";

            function b(a) {
                return h[a] || "&amp;"
            }

            function c(a, b) {
                for (var c in b) Object.prototype.hasOwnProperty.call(b, c) && (a[c] = b[c])
            }

            function d(a) {
                return a instanceof g ? a.toString() : a || 0 === a ? (a = "" + a, j.test(a) ? a.replace(i, b) : a) : ""
            }

            function e(a) {
                return a || 0 === a ? m(a) && 0 === a.length ? !0 : !1 : !0
            }
            var f = {},
                g = a,
                h = {
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#x27;",
                    "`": "&#x60;"
                },
                i = /[&<>"'`]/g,
                j = /[&<>"'`]/;
            f.extend = c;
            var k = Object.prototype.toString;
            f.toString = k;
            var l = function(a) {
                return "function" == typeof a
            };
            l(/x/) && (l = function(a) {
                return "function" == typeof a && "[object Function]" === k.call(a)
            });
            var l;
            f.isFunction = l;
            var m = Array.isArray || function(a) {
                return a && "object" == typeof a ? "[object Array]" === k.call(a) : !1
            };
            return f.isArray = m, f.escapeExpression = d, f.isEmpty = e, f
        }(a),
        c = function() {
            "use strict";

            function a(a, b) {
                var d;
                b && b.firstLine && (d = b.firstLine, a += " - " + d + ":" + b.firstColumn);
                for (var e = Error.prototype.constructor.call(this, a), f = 0; f < c.length; f++) this[c[f]] = e[c[f]];
                d && (this.lineNumber = d, this.column = b.firstColumn)
            }
            var b, c = ["description", "fileName", "lineNumber", "message", "name", "number", "stack"];
            return a.prototype = new Error, b = a
        }(),
        d = function(a, b) {
            "use strict";

            function c(a, b) {
                this.helpers = a || {}, this.partials = b || {}, d(this)
            }

            function d(a) {
                a.registerHelper("helperMissing", function(a) {
                    if (2 === arguments.length) return void 0;
                    throw new h("Missing helper: '" + a + "'")
                }), a.registerHelper("blockHelperMissing", function(b, c) {
                    var d = c.inverse || function() {},
                        e = c.fn;
                    return m(b) && (b = b.call(this)), b === !0 ? e(this) : b === !1 || null == b ? d(this) : l(b) ? b.length > 0 ? a.helpers.each(b, c) : d(this) : e(b)
                }), a.registerHelper("each", function(a, b) {
                    var c, d = b.fn,
                        e = b.inverse,
                        f = 0,
                        g = "";
                    if (m(a) && (a = a.call(this)), b.data && (c = q(b.data)), a && "object" == typeof a)
                        if (l(a))
                            for (var h = a.length; h > f; f++) c && (c.index = f, c.first = 0 === f, c.last = f === a.length - 1), g += d(a[f], {
                                data: c
                            });
                        else
                            for (var i in a) a.hasOwnProperty(i) && (c && (c.key = i, c.index = f, c.first = 0 === f), g += d(a[i], {
                                data: c
                            }), f++);
                    return 0 === f && (g = e(this)), g
                }), a.registerHelper("if", function(a, b) {
                    return m(a) && (a = a.call(this)), !b.hash.includeZero && !a || g.isEmpty(a) ? b.inverse(this) : b.fn(this)
                }), a.registerHelper("unless", function(b, c) {
                    return a.helpers["if"].call(this, b, {
                        fn: c.inverse,
                        inverse: c.fn,
                        hash: c.hash
                    })
                }), a.registerHelper("with", function(a, b) {
                    return m(a) && (a = a.call(this)), g.isEmpty(a) ? void 0 : b.fn(a)
                }), a.registerHelper("log", function(b, c) {
                    var d = c.data && null != c.data.level ? parseInt(c.data.level, 10) : 1;
                    a.log(d, b)
                })
            }

            function e(a, b) {
                p.log(a, b)
            }
            var f = {},
                g = a,
                h = b,
                i = "1.3.0";
            f.VERSION = i;
            var j = 4;
            f.COMPILER_REVISION = j;
            var k = {
                1: "<= 1.0.rc.2",
                2: "== 1.0.0-rc.3",
                3: "== 1.0.0-rc.4",
                4: ">= 1.0.0"
            };
            f.REVISION_CHANGES = k;
            var l = g.isArray,
                m = g.isFunction,
                n = g.toString,
                o = "[object Object]";
            f.HandlebarsEnvironment = c, c.prototype = {
                constructor: c,
                logger: p,
                log: e,
                registerHelper: function(a, b, c) {
                    if (n.call(a) === o) {
                        if (c || b) throw new h("Arg not supported with multiple helpers");
                        g.extend(this.helpers, a)
                    } else c && (b.not = c), this.helpers[a] = b
                },
                registerPartial: function(a, b) {
                    n.call(a) === o ? g.extend(this.partials, a) : this.partials[a] = b
                }
            };
            var p = {
                methodMap: {
                    0: "debug",
                    1: "info",
                    2: "warn",
                    3: "error"
                },
                DEBUG: 0,
                INFO: 1,
                WARN: 2,
                ERROR: 3,
                level: 3,
                log: function(a, b) {
                    if (p.level <= a) {
                        var c = p.methodMap[a];
                        "undefined" != typeof console && console[c] && console[c].call(console, b)
                    }
                }
            };
            f.logger = p, f.log = e;
            var q = function(a) {
                var b = {};
                return g.extend(b, a), b
            };
            return f.createFrame = q, f
        }(b, c),
        e = function(a, b, c) {
            "use strict";

            function d(a) {
                var b = a && a[0] || 1,
                    c = m;
                if (b !== c) {
                    if (c > b) {
                        var d = n[c],
                            e = n[b];
                        throw new l("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + d + ") or downgrade your runtime to an older version (" + e + ").")
                    }
                    throw new l("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + a[1] + ").")
                }
            }

            function e(a, b) {
                if (!b) throw new l("No environment passed to template");
                var c = function(a, c, d, e, f, g) {
                        var h = b.VM.invokePartial.apply(this, arguments);
                        if (null != h) return h;
                        if (b.compile) {
                            var i = {
                                helpers: e,
                                partials: f,
                                data: g
                            };
                            return f[c] = b.compile(a, {
                                data: void 0 !== g
                            }, b), f[c](d, i)
                        }
                        throw new l("The partial " + c + " could not be compiled when running in runtime-only mode")
                    },
                    d = {
                        escapeExpression: k.escapeExpression,
                        invokePartial: c,
                        programs: [],
                        program: function(a, b, c) {
                            var d = this.programs[a];
                            return c ? d = g(a, b, c) : d || (d = this.programs[a] = g(a, b)), d
                        },
                        merge: function(a, b) {
                            var c = a || b;
                            return a && b && a !== b && (c = {}, k.extend(c, b), k.extend(c, a)), c
                        },
                        programWithDepth: b.VM.programWithDepth,
                        noop: b.VM.noop,
                        compilerInfo: null
                    };
                return function(c, e) {
                    e = e || {};
                    var f, g, h = e.partial ? e : b;
                    e.partial || (f = e.helpers, g = e.partials);
                    var i = a.call(d, h, c, f, g, e.data);
                    return e.partial || b.VM.checkRevision(d.compilerInfo), i
                }
            }

            function f(a, b, c) {
                var d = Array.prototype.slice.call(arguments, 3),
                    e = function(a, e) {
                        return e = e || {}, b.apply(this, [a, e.data || c].concat(d))
                    };
                return e.program = a, e.depth = d.length, e
            }

            function g(a, b, c) {
                var d = function(a, d) {
                    return d = d || {}, b(a, d.data || c)
                };
                return d.program = a, d.depth = 0, d
            }

            function h(a, b, c, d, e, f) {
                var g = {
                    partial: !0,
                    helpers: d,
                    partials: e,
                    data: f
                };
                if (void 0 === a) throw new l("The partial " + b + " could not be found");
                return a instanceof Function ? a(c, g) : void 0
            }

            function i() {
                return ""
            }
            var j = {},
                k = a,
                l = b,
                m = c.COMPILER_REVISION,
                n = c.REVISION_CHANGES;
            return j.checkRevision = d, j.template = e, j.programWithDepth = f, j.program = g, j.invokePartial = h, j.noop = i, j
        }(b, c, d),
        f = function(a, b, c, d, e) {
            "use strict";
            var f, g = a,
                h = b,
                i = c,
                j = d,
                k = e,
                l = function() {
                    var a = new g.HandlebarsEnvironment;
                    return j.extend(a, g), a.SafeString = h, a.Exception = i, a.Utils = j, a.VM = k, a.template = function(b) {
                        return k.template(b, a)
                    }, a
                },
                m = l();
            return m.create = l, f = m
        }(d, a, c, b, e),
        g = function(a) {
            "use strict";

            function b(a) {
                a = a || {}, this.firstLine = a.first_line, this.firstColumn = a.first_column, this.lastColumn = a.last_column, this.lastLine = a.last_line
            }
            var c, d = a,
                e = {
                    ProgramNode: function(a, c, d, f) {
                        var g, h;
                        3 === arguments.length ? (f = d, d = null) : 2 === arguments.length && (f = c, c = null), b.call(this, f), this.type = "program", this.statements = a, this.strip = {}, d ? (h = d[0], h ? (g = {
                            first_line: h.firstLine,
                            last_line: h.lastLine,
                            last_column: h.lastColumn,
                            first_column: h.firstColumn
                        }, this.inverse = new e.ProgramNode(d, c, g)) : this.inverse = new e.ProgramNode(d, c), this.strip.right = c.left) : c && (this.strip.left = c.right)
                    },
                    MustacheNode: function(a, c, d, f, g) {
                        if (b.call(this, g), this.type = "mustache", this.strip = f, null != d && d.charAt) {
                            var h = d.charAt(3) || d.charAt(2);
                            this.escaped = "{" !== h && "&" !== h
                        } else this.escaped = !!d;
                        this.sexpr = a instanceof e.SexprNode ? a : new e.SexprNode(a, c), this.sexpr.isRoot = !0, this.id = this.sexpr.id, this.params = this.sexpr.params, this.hash = this.sexpr.hash, this.eligibleHelper = this.sexpr.eligibleHelper, this.isHelper = this.sexpr.isHelper
                    },
                    SexprNode: function(a, c, d) {
                        b.call(this, d), this.type = "sexpr", this.hash = c;
                        var e = this.id = a[0],
                            f = this.params = a.slice(1),
                            g = this.eligibleHelper = e.isSimple;
                        this.isHelper = g && (f.length || c)
                    },
                    PartialNode: function(a, c, d, e) {
                        b.call(this, e), this.type = "partial", this.partialName = a, this.context = c, this.strip = d
                    },
                    BlockNode: function(a, c, e, f, g) {
                        if (b.call(this, g), a.sexpr.id.original !== f.path.original) throw new d(a.sexpr.id.original + " doesn't match " + f.path.original, this);
                        this.type = "block", this.mustache = a, this.program = c, this.inverse = e, this.strip = {
                            left: a.strip.left,
                            right: f.strip.right
                        }, (c || e).strip.left = a.strip.right, (e || c).strip.right = f.strip.left, e && !c && (this.isInverse = !0)
                    },
                    ContentNode: function(a, c) {
                        b.call(this, c), this.type = "content", this.string = a
                    },
                    HashNode: function(a, c) {
                        b.call(this, c), this.type = "hash", this.pairs = a
                    },
                    IdNode: function(a, c) {
                        b.call(this, c), this.type = "ID";
                        for (var e = "", f = [], g = 0, h = 0, i = a.length; i > h; h++) {
                            var j = a[h].part;
                            if (e += (a[h].separator || "") + j, ".." === j || "." === j || "this" === j) {
                                if (f.length > 0) throw new d("Invalid path: " + e, this);
                                ".." === j ? g++ : this.isScoped = !0
                            } else f.push(j)
                        }
                        this.original = e, this.parts = f, this.string = f.join("."), this.depth = g, this.isSimple = 1 === a.length && !this.isScoped && 0 === g, this.stringModeValue = this.string
                    },
                    PartialNameNode: function(a, c) {
                        b.call(this, c), this.type = "PARTIAL_NAME", this.name = a.original
                    },
                    DataNode: function(a, c) {
                        b.call(this, c), this.type = "DATA", this.id = a
                    },
                    StringNode: function(a, c) {
                        b.call(this, c), this.type = "STRING", this.original = this.string = this.stringModeValue = a
                    },
                    IntegerNode: function(a, c) {
                        b.call(this, c), this.type = "INTEGER", this.original = this.integer = a, this.stringModeValue = Number(a)
                    },
                    BooleanNode: function(a, c) {
                        b.call(this, c), this.type = "BOOLEAN", this.bool = a, this.stringModeValue = "true" === a
                    },
                    CommentNode: function(a, c) {
                        b.call(this, c), this.type = "comment", this.comment = a
                    }
                };
            return c = e
        }(c),
        h = function() {
            "use strict";
            var a, b = function() {
                function a(a, b) {
                    return {
                        left: "~" === a.charAt(2),
                        right: "~" === b.charAt(0) || "~" === b.charAt(1)
                    }
                }

                function b() {
                    this.yy = {}
                }
                var c = {
                        trace: function() {},
                        yy: {},
                        symbols_: {
                            error: 2,
                            root: 3,
                            statements: 4,
                            EOF: 5,
                            program: 6,
                            simpleInverse: 7,
                            statement: 8,
                            openInverse: 9,
                            closeBlock: 10,
                            openBlock: 11,
                            mustache: 12,
                            partial: 13,
                            CONTENT: 14,
                            COMMENT: 15,
                            OPEN_BLOCK: 16,
                            sexpr: 17,
                            CLOSE: 18,
                            OPEN_INVERSE: 19,
                            OPEN_ENDBLOCK: 20,
                            path: 21,
                            OPEN: 22,
                            OPEN_UNESCAPED: 23,
                            CLOSE_UNESCAPED: 24,
                            OPEN_PARTIAL: 25,
                            partialName: 26,
                            partial_option0: 27,
                            sexpr_repetition0: 28,
                            sexpr_option0: 29,
                            dataName: 30,
                            param: 31,
                            STRING: 32,
                            INTEGER: 33,
                            BOOLEAN: 34,
                            OPEN_SEXPR: 35,
                            CLOSE_SEXPR: 36,
                            hash: 37,
                            hash_repetition_plus0: 38,
                            hashSegment: 39,
                            ID: 40,
                            EQUALS: 41,
                            DATA: 42,
                            pathSegments: 43,
                            SEP: 44,
                            $accept: 0,
                            $end: 1
                        },
                        terminals_: {
                            2: "error",
                            5: "EOF",
                            14: "CONTENT",
                            15: "COMMENT",
                            16: "OPEN_BLOCK",
                            18: "CLOSE",
                            19: "OPEN_INVERSE",
                            20: "OPEN_ENDBLOCK",
                            22: "OPEN",
                            23: "OPEN_UNESCAPED",
                            24: "CLOSE_UNESCAPED",
                            25: "OPEN_PARTIAL",
                            32: "STRING",
                            33: "INTEGER",
                            34: "BOOLEAN",
                            35: "OPEN_SEXPR",
                            36: "CLOSE_SEXPR",
                            40: "ID",
                            41: "EQUALS",
                            42: "DATA",
                            44: "SEP"
                        },
                        productions_: [0, [3, 2],
                            [3, 1],
                            [6, 2],
                            [6, 3],
                            [6, 2],
                            [6, 1],
                            [6, 1],
                            [6, 0],
                            [4, 1],
                            [4, 2],
                            [8, 3],
                            [8, 3],
                            [8, 1],
                            [8, 1],
                            [8, 1],
                            [8, 1],
                            [11, 3],
                            [9, 3],
                            [10, 3],
                            [12, 3],
                            [12, 3],
                            [13, 4],
                            [7, 2],
                            [17, 3],
                            [17, 1],
                            [31, 1],
                            [31, 1],
                            [31, 1],
                            [31, 1],
                            [31, 1],
                            [31, 3],
                            [37, 1],
                            [39, 3],
                            [26, 1],
                            [26, 1],
                            [26, 1],
                            [30, 2],
                            [21, 1],
                            [43, 3],
                            [43, 1],
                            [27, 0],
                            [27, 1],
                            [28, 0],
                            [28, 2],
                            [29, 0],
                            [29, 1],
                            [38, 1],
                            [38, 2]
                        ],
                        performAction: function(b, c, d, e, f, g) {
                            var h = g.length - 1;
                            switch (f) {
                                case 1:
                                    return new e.ProgramNode(g[h - 1], this._$);
                                case 2:
                                    return new e.ProgramNode([], this._$);
                                case 3:
                                    this.$ = new e.ProgramNode([], g[h - 1], g[h], this._$);
                                    break;
                                case 4:
                                    this.$ = new e.ProgramNode(g[h - 2], g[h - 1], g[h], this._$);
                                    break;
                                case 5:
                                    this.$ = new e.ProgramNode(g[h - 1], g[h], [], this._$);
                                    break;
                                case 6:
                                    this.$ = new e.ProgramNode(g[h], this._$);
                                    break;
                                case 7:
                                    this.$ = new e.ProgramNode([], this._$);
                                    break;
                                case 8:
                                    this.$ = new e.ProgramNode([], this._$);
                                    break;
                                case 9:
                                    this.$ = [g[h]];
                                    break;
                                case 10:
                                    g[h - 1].push(g[h]), this.$ = g[h - 1];
                                    break;
                                case 11:
                                    this.$ = new e.BlockNode(g[h - 2], g[h - 1].inverse, g[h - 1], g[h], this._$);
                                    break;
                                case 12:
                                    this.$ = new e.BlockNode(g[h - 2], g[h - 1], g[h - 1].inverse, g[h], this._$);
                                    break;
                                case 13:
                                    this.$ = g[h];
                                    break;
                                case 14:
                                    this.$ = g[h];
                                    break;
                                case 15:
                                    this.$ = new e.ContentNode(g[h], this._$);
                                    break;
                                case 16:
                                    this.$ = new e.CommentNode(g[h], this._$);
                                    break;
                                case 17:
                                    this.$ = new e.MustacheNode(g[h - 1], null, g[h - 2], a(g[h - 2], g[h]), this._$);
                                    break;
                                case 18:
                                    this.$ = new e.MustacheNode(g[h - 1], null, g[h - 2], a(g[h - 2], g[h]), this._$);
                                    break;
                                case 19:
                                    this.$ = {
                                        path: g[h - 1],
                                        strip: a(g[h - 2], g[h])
                                    };
                                    break;
                                case 20:
                                    this.$ = new e.MustacheNode(g[h - 1], null, g[h - 2], a(g[h - 2], g[h]), this._$);
                                    break;
                                case 21:
                                    this.$ = new e.MustacheNode(g[h - 1], null, g[h - 2], a(g[h - 2], g[h]), this._$);
                                    break;
                                case 22:
                                    this.$ = new e.PartialNode(g[h - 2], g[h - 1], a(g[h - 3], g[h]), this._$);
                                    break;
                                case 23:
                                    this.$ = a(g[h - 1], g[h]);
                                    break;
                                case 24:
                                    this.$ = new e.SexprNode([g[h - 2]].concat(g[h - 1]), g[h], this._$);
                                    break;
                                case 25:
                                    this.$ = new e.SexprNode([g[h]], null, this._$);
                                    break;
                                case 26:
                                    this.$ = g[h];
                                    break;
                                case 27:
                                    this.$ = new e.StringNode(g[h], this._$);
                                    break;
                                case 28:
                                    this.$ = new e.IntegerNode(g[h], this._$);
                                    break;
                                case 29:
                                    this.$ = new e.BooleanNode(g[h], this._$);
                                    break;
                                case 30:
                                    this.$ = g[h];
                                    break;
                                case 31:
                                    g[h - 1].isHelper = !0, this.$ = g[h - 1];
                                    break;
                                case 32:
                                    this.$ = new e.HashNode(g[h], this._$);
                                    break;
                                case 33:
                                    this.$ = [g[h - 2], g[h]];
                                    break;
                                case 34:
                                    this.$ = new e.PartialNameNode(g[h], this._$);
                                    break;
                                case 35:
                                    this.$ = new e.PartialNameNode(new e.StringNode(g[h], this._$), this._$);
                                    break;
                                case 36:
                                    this.$ = new e.PartialNameNode(new e.IntegerNode(g[h], this._$));
                                    break;
                                case 37:
                                    this.$ = new e.DataNode(g[h], this._$);
                                    break;
                                case 38:
                                    this.$ = new e.IdNode(g[h], this._$);
                                    break;
                                case 39:
                                    g[h - 2].push({
                                        part: g[h],
                                        separator: g[h - 1]
                                    }), this.$ = g[h - 2];
                                    break;
                                case 40:
                                    this.$ = [{
                                        part: g[h]
                                    }];
                                    break;
                                case 43:
                                    this.$ = [];
                                    break;
                                case 44:
                                    g[h - 1].push(g[h]);
                                    break;
                                case 47:
                                    this.$ = [g[h]];
                                    break;
                                case 48:
                                    g[h - 1].push(g[h])
                            }
                        },
                        table: [{
                            3: 1,
                            4: 2,
                            5: [1, 3],
                            8: 4,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            1: [3]
                        }, {
                            5: [1, 16],
                            8: 17,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            1: [2, 2]
                        }, {
                            5: [2, 9],
                            14: [2, 9],
                            15: [2, 9],
                            16: [2, 9],
                            19: [2, 9],
                            20: [2, 9],
                            22: [2, 9],
                            23: [2, 9],
                            25: [2, 9]
                        }, {
                            4: 20,
                            6: 18,
                            7: 19,
                            8: 4,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 21],
                            20: [2, 8],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            4: 20,
                            6: 22,
                            7: 19,
                            8: 4,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 21],
                            20: [2, 8],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            5: [2, 13],
                            14: [2, 13],
                            15: [2, 13],
                            16: [2, 13],
                            19: [2, 13],
                            20: [2, 13],
                            22: [2, 13],
                            23: [2, 13],
                            25: [2, 13]
                        }, {
                            5: [2, 14],
                            14: [2, 14],
                            15: [2, 14],
                            16: [2, 14],
                            19: [2, 14],
                            20: [2, 14],
                            22: [2, 14],
                            23: [2, 14],
                            25: [2, 14]
                        }, {
                            5: [2, 15],
                            14: [2, 15],
                            15: [2, 15],
                            16: [2, 15],
                            19: [2, 15],
                            20: [2, 15],
                            22: [2, 15],
                            23: [2, 15],
                            25: [2, 15]
                        }, {
                            5: [2, 16],
                            14: [2, 16],
                            15: [2, 16],
                            16: [2, 16],
                            19: [2, 16],
                            20: [2, 16],
                            22: [2, 16],
                            23: [2, 16],
                            25: [2, 16]
                        }, {
                            17: 23,
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            17: 29,
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            17: 30,
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            17: 31,
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            21: 33,
                            26: 32,
                            32: [1, 34],
                            33: [1, 35],
                            40: [1, 28],
                            43: 26
                        }, {
                            1: [2, 1]
                        }, {
                            5: [2, 10],
                            14: [2, 10],
                            15: [2, 10],
                            16: [2, 10],
                            19: [2, 10],
                            20: [2, 10],
                            22: [2, 10],
                            23: [2, 10],
                            25: [2, 10]
                        }, {
                            10: 36,
                            20: [1, 37]
                        }, {
                            4: 38,
                            8: 4,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            20: [2, 7],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            7: 39,
                            8: 17,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 21],
                            20: [2, 6],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            17: 23,
                            18: [1, 40],
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            10: 41,
                            20: [1, 37]
                        }, {
                            18: [1, 42]
                        }, {
                            18: [2, 43],
                            24: [2, 43],
                            28: 43,
                            32: [2, 43],
                            33: [2, 43],
                            34: [2, 43],
                            35: [2, 43],
                            36: [2, 43],
                            40: [2, 43],
                            42: [2, 43]
                        }, {
                            18: [2, 25],
                            24: [2, 25],
                            36: [2, 25]
                        }, {
                            18: [2, 38],
                            24: [2, 38],
                            32: [2, 38],
                            33: [2, 38],
                            34: [2, 38],
                            35: [2, 38],
                            36: [2, 38],
                            40: [2, 38],
                            42: [2, 38],
                            44: [1, 44]
                        }, {
                            21: 45,
                            40: [1, 28],
                            43: 26
                        }, {
                            18: [2, 40],
                            24: [2, 40],
                            32: [2, 40],
                            33: [2, 40],
                            34: [2, 40],
                            35: [2, 40],
                            36: [2, 40],
                            40: [2, 40],
                            42: [2, 40],
                            44: [2, 40]
                        }, {
                            18: [1, 46]
                        }, {
                            18: [1, 47]
                        }, {
                            24: [1, 48]
                        }, {
                            18: [2, 41],
                            21: 50,
                            27: 49,
                            40: [1, 28],
                            43: 26
                        }, {
                            18: [2, 34],
                            40: [2, 34]
                        }, {
                            18: [2, 35],
                            40: [2, 35]
                        }, {
                            18: [2, 36],
                            40: [2, 36]
                        }, {
                            5: [2, 11],
                            14: [2, 11],
                            15: [2, 11],
                            16: [2, 11],
                            19: [2, 11],
                            20: [2, 11],
                            22: [2, 11],
                            23: [2, 11],
                            25: [2, 11]
                        }, {
                            21: 51,
                            40: [1, 28],
                            43: 26
                        }, {
                            8: 17,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            20: [2, 3],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            4: 52,
                            8: 4,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            20: [2, 5],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            14: [2, 23],
                            15: [2, 23],
                            16: [2, 23],
                            19: [2, 23],
                            20: [2, 23],
                            22: [2, 23],
                            23: [2, 23],
                            25: [2, 23]
                        }, {
                            5: [2, 12],
                            14: [2, 12],
                            15: [2, 12],
                            16: [2, 12],
                            19: [2, 12],
                            20: [2, 12],
                            22: [2, 12],
                            23: [2, 12],
                            25: [2, 12]
                        }, {
                            14: [2, 18],
                            15: [2, 18],
                            16: [2, 18],
                            19: [2, 18],
                            20: [2, 18],
                            22: [2, 18],
                            23: [2, 18],
                            25: [2, 18]
                        }, {
                            18: [2, 45],
                            21: 56,
                            24: [2, 45],
                            29: 53,
                            30: 60,
                            31: 54,
                            32: [1, 57],
                            33: [1, 58],
                            34: [1, 59],
                            35: [1, 61],
                            36: [2, 45],
                            37: 55,
                            38: 62,
                            39: 63,
                            40: [1, 64],
                            42: [1, 27],
                            43: 26
                        }, {
                            40: [1, 65]
                        }, {
                            18: [2, 37],
                            24: [2, 37],
                            32: [2, 37],
                            33: [2, 37],
                            34: [2, 37],
                            35: [2, 37],
                            36: [2, 37],
                            40: [2, 37],
                            42: [2, 37]
                        }, {
                            14: [2, 17],
                            15: [2, 17],
                            16: [2, 17],
                            19: [2, 17],
                            20: [2, 17],
                            22: [2, 17],
                            23: [2, 17],
                            25: [2, 17]
                        }, {
                            5: [2, 20],
                            14: [2, 20],
                            15: [2, 20],
                            16: [2, 20],
                            19: [2, 20],
                            20: [2, 20],
                            22: [2, 20],
                            23: [2, 20],
                            25: [2, 20]
                        }, {
                            5: [2, 21],
                            14: [2, 21],
                            15: [2, 21],
                            16: [2, 21],
                            19: [2, 21],
                            20: [2, 21],
                            22: [2, 21],
                            23: [2, 21],
                            25: [2, 21]
                        }, {
                            18: [1, 66]
                        }, {
                            18: [2, 42]
                        }, {
                            18: [1, 67]
                        }, {
                            8: 17,
                            9: 5,
                            11: 6,
                            12: 7,
                            13: 8,
                            14: [1, 9],
                            15: [1, 10],
                            16: [1, 12],
                            19: [1, 11],
                            20: [2, 4],
                            22: [1, 13],
                            23: [1, 14],
                            25: [1, 15]
                        }, {
                            18: [2, 24],
                            24: [2, 24],
                            36: [2, 24]
                        }, {
                            18: [2, 44],
                            24: [2, 44],
                            32: [2, 44],
                            33: [2, 44],
                            34: [2, 44],
                            35: [2, 44],
                            36: [2, 44],
                            40: [2, 44],
                            42: [2, 44]
                        }, {
                            18: [2, 46],
                            24: [2, 46],
                            36: [2, 46]
                        }, {
                            18: [2, 26],
                            24: [2, 26],
                            32: [2, 26],
                            33: [2, 26],
                            34: [2, 26],
                            35: [2, 26],
                            36: [2, 26],
                            40: [2, 26],
                            42: [2, 26]
                        }, {
                            18: [2, 27],
                            24: [2, 27],
                            32: [2, 27],
                            33: [2, 27],
                            34: [2, 27],
                            35: [2, 27],
                            36: [2, 27],
                            40: [2, 27],
                            42: [2, 27]
                        }, {
                            18: [2, 28],
                            24: [2, 28],
                            32: [2, 28],
                            33: [2, 28],
                            34: [2, 28],
                            35: [2, 28],
                            36: [2, 28],
                            40: [2, 28],
                            42: [2, 28]
                        }, {
                            18: [2, 29],
                            24: [2, 29],
                            32: [2, 29],
                            33: [2, 29],
                            34: [2, 29],
                            35: [2, 29],
                            36: [2, 29],
                            40: [2, 29],
                            42: [2, 29]
                        }, {
                            18: [2, 30],
                            24: [2, 30],
                            32: [2, 30],
                            33: [2, 30],
                            34: [2, 30],
                            35: [2, 30],
                            36: [2, 30],
                            40: [2, 30],
                            42: [2, 30]
                        }, {
                            17: 68,
                            21: 24,
                            30: 25,
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            18: [2, 32],
                            24: [2, 32],
                            36: [2, 32],
                            39: 69,
                            40: [1, 70]
                        }, {
                            18: [2, 47],
                            24: [2, 47],
                            36: [2, 47],
                            40: [2, 47]
                        }, {
                            18: [2, 40],
                            24: [2, 40],
                            32: [2, 40],
                            33: [2, 40],
                            34: [2, 40],
                            35: [2, 40],
                            36: [2, 40],
                            40: [2, 40],
                            41: [1, 71],
                            42: [2, 40],
                            44: [2, 40]
                        }, {
                            18: [2, 39],
                            24: [2, 39],
                            32: [2, 39],
                            33: [2, 39],
                            34: [2, 39],
                            35: [2, 39],
                            36: [2, 39],
                            40: [2, 39],
                            42: [2, 39],
                            44: [2, 39]
                        }, {
                            5: [2, 22],
                            14: [2, 22],
                            15: [2, 22],
                            16: [2, 22],
                            19: [2, 22],
                            20: [2, 22],
                            22: [2, 22],
                            23: [2, 22],
                            25: [2, 22]
                        }, {
                            5: [2, 19],
                            14: [2, 19],
                            15: [2, 19],
                            16: [2, 19],
                            19: [2, 19],
                            20: [2, 19],
                            22: [2, 19],
                            23: [2, 19],
                            25: [2, 19]
                        }, {
                            36: [1, 72]
                        }, {
                            18: [2, 48],
                            24: [2, 48],
                            36: [2, 48],
                            40: [2, 48]
                        }, {
                            41: [1, 71]
                        }, {
                            21: 56,
                            30: 60,
                            31: 73,
                            32: [1, 57],
                            33: [1, 58],
                            34: [1, 59],
                            35: [1, 61],
                            40: [1, 28],
                            42: [1, 27],
                            43: 26
                        }, {
                            18: [2, 31],
                            24: [2, 31],
                            32: [2, 31],
                            33: [2, 31],
                            34: [2, 31],
                            35: [2, 31],
                            36: [2, 31],
                            40: [2, 31],
                            42: [2, 31]
                        }, {
                            18: [2, 33],
                            24: [2, 33],
                            36: [2, 33],
                            40: [2, 33]
                        }],
                        defaultActions: {
                            3: [2, 2],
                            16: [2, 1],
                            50: [2, 42]
                        },
                        parseError: function(a) {
                            throw new Error(a)
                        },
                        parse: function(a) {
                            function b() {
                                var a;
                                return a = c.lexer.lex() || 1, "number" != typeof a && (a = c.symbols_[a] || a), a
                            }
                            var c = this,
                                d = [0],
                                e = [null],
                                f = [],
                                g = this.table,
                                h = "",
                                i = 0,
                                j = 0,
                                k = 0;
                            this.lexer.setInput(a), this.lexer.yy = this.yy, this.yy.lexer = this.lexer, this.yy.parser = this, "undefined" == typeof this.lexer.yylloc && (this.lexer.yylloc = {});
                            var l = this.lexer.yylloc;
                            f.push(l);
                            var m = this.lexer.options && this.lexer.options.ranges;
                            "function" == typeof this.yy.parseError && (this.parseError = this.yy.parseError);
                            for (var n, o, p, q, r, s, t, u, v, w = {};;) {
                                if (p = d[d.length - 1], this.defaultActions[p] ? q = this.defaultActions[p] : ((null === n || "undefined" == typeof n) && (n = b()), q = g[p] && g[p][n]), "undefined" == typeof q || !q.length || !q[0]) {
                                    var x = "";
                                    if (!k) {
                                        v = [];
                                        for (s in g[p]) this.terminals_[s] && s > 2 && v.push("'" + this.terminals_[s] + "'");
                                        x = this.lexer.showPosition ? "Parse error on line " + (i + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + v.join(", ") + ", got '" + (this.terminals_[n] || n) + "'" : "Parse error on line " + (i + 1) + ": Unexpected " + (1 == n ? "end of input" : "'" + (this.terminals_[n] || n) + "'"), this.parseError(x, {
                                            text: this.lexer.match,
                                            token: this.terminals_[n] || n,
                                            line: this.lexer.yylineno,
                                            loc: l,
                                            expected: v
                                        })
                                    }
                                }
                                if (q[0] instanceof Array && q.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + p + ", token: " + n);
                                switch (q[0]) {
                                    case 1:
                                        d.push(n), e.push(this.lexer.yytext), f.push(this.lexer.yylloc), d.push(q[1]), n = null, o ? (n = o, o = null) : (j = this.lexer.yyleng, h = this.lexer.yytext, i = this.lexer.yylineno, l = this.lexer.yylloc, k > 0 && k--);
                                        break;
                                    case 2:
                                        if (t = this.productions_[q[1]][1], w.$ = e[e.length - t], w._$ = {
                                                first_line: f[f.length - (t || 1)].first_line,
                                                last_line: f[f.length - 1].last_line,
                                                first_column: f[f.length - (t || 1)].first_column,
                                                last_column: f[f.length - 1].last_column
                                            }, m && (w._$.range = [f[f.length - (t || 1)].range[0], f[f.length - 1].range[1]]), r = this.performAction.call(w, h, j, i, this.yy, q[1], e, f), "undefined" != typeof r) return r;
                                        t && (d = d.slice(0, -1 * t * 2), e = e.slice(0, -1 * t), f = f.slice(0, -1 * t)), d.push(this.productions_[q[1]][0]), e.push(w.$), f.push(w._$), u = g[d[d.length - 2]][d[d.length - 1]], d.push(u);
                                        break;
                                    case 3:
                                        return !0
                                }
                            }
                            return !0
                        }
                    },
                    d = function() {
                        var a = {
                            EOF: 1,
                            parseError: function(a, b) {
                                if (!this.yy.parser) throw new Error(a);
                                this.yy.parser.parseError(a, b)
                            },
                            setInput: function(a) {
                                return this._input = a, this._more = this._less = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
                                    first_line: 1,
                                    first_column: 0,
                                    last_line: 1,
                                    last_column: 0
                                }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this
                            },
                            input: function() {
                                var a = this._input[0];
                                this.yytext += a, this.yyleng++, this.offset++, this.match += a, this.matched += a;
                                var b = a.match(/(?:\r\n?|\n).*/g);
                                return b ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), a
                            },
                            unput: function(a) {
                                var b = a.length,
                                    c = a.split(/(?:\r\n?|\n)/g);
                                this._input = a + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - b - 1), this.offset -= b;
                                var d = this.match.split(/(?:\r\n?|\n)/g);
                                this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), c.length - 1 && (this.yylineno -= c.length - 1);
                                var e = this.yylloc.range;
                                return this.yylloc = {
                                    first_line: this.yylloc.first_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.first_column,
                                    last_column: c ? (c.length === d.length ? this.yylloc.first_column : 0) + d[d.length - c.length].length - c[0].length : this.yylloc.first_column - b
                                }, this.options.ranges && (this.yylloc.range = [e[0], e[0] + this.yyleng - b]), this
                            },
                            more: function() {
                                return this._more = !0, this
                            },
                            less: function(a) {
                                this.unput(this.match.slice(a))
                            },
                            pastInput: function() {
                                var a = this.matched.substr(0, this.matched.length - this.match.length);
                                return (a.length > 20 ? "..." : "") + a.substr(-20).replace(/\n/g, "")
                            },
                            upcomingInput: function() {
                                var a = this.match;
                                return a.length < 20 && (a += this._input.substr(0, 20 - a.length)), (a.substr(0, 20) + (a.length > 20 ? "..." : "")).replace(/\n/g, "")
                            },
                            showPosition: function() {
                                var a = this.pastInput(),
                                    b = new Array(a.length + 1).join("-");
                                return a + this.upcomingInput() + "\n" + b + "^"
                            },
                            next: function() {
                                if (this.done) return this.EOF;
                                this._input || (this.done = !0);
                                var a, b, c, d, e;
                                this._more || (this.yytext = "", this.match = "");
                                for (var f = this._currentRules(), g = 0; g < f.length && (c = this._input.match(this.rules[f[g]]), !c || b && !(c[0].length > b[0].length) || (b = c, d = g, this.options.flex)); g++);
                                return b ? (e = b[0].match(/(?:\r\n?|\n).*/g), e && (this.yylineno += e.length), this.yylloc = {
                                    first_line: this.yylloc.last_line,
                                    last_line: this.yylineno + 1,
                                    first_column: this.yylloc.last_column,
                                    last_column: e ? e[e.length - 1].length - e[e.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + b[0].length
                                }, this.yytext += b[0], this.match += b[0], this.matches = b, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._input = this._input.slice(b[0].length), this.matched += b[0], a = this.performAction.call(this, this.yy, this, f[d], this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), a ? a : void 0) : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                                    text: "",
                                    token: null,
                                    line: this.yylineno
                                })
                            },
                            lex: function() {
                                var a = this.next();
                                return "undefined" != typeof a ? a : this.lex()
                            },
                            begin: function(a) {
                                this.conditionStack.push(a)
                            },
                            popState: function() {
                                return this.conditionStack.pop()
                            },
                            _currentRules: function() {
                                return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                            },
                            topState: function() {
                                return this.conditionStack[this.conditionStack.length - 2]
                            },
                            pushState: function(a) {
                                this.begin(a)
                            }
                        };
                        return a.options = {}, a.performAction = function(a, b, c, d) {
                            function e(a, c) {
                                return b.yytext = b.yytext.substr(a, b.yyleng - c)
                            }
                            switch (c) {
                                case 0:
                                    if ("\\\\" === b.yytext.slice(-2) ? (e(0, 1), this.begin("mu")) : "\\" === b.yytext.slice(-1) ? (e(0, 1), this.begin("emu")) : this.begin("mu"), b.yytext) return 14;
                                    break;
                                case 1:
                                    return 14;
                                case 2:
                                    return this.popState(), 14;
                                case 3:
                                    return e(0, 4), this.popState(), 15;
                                case 4:
                                    return 35;
                                case 5:
                                    return 36;
                                case 6:
                                    return 25;
                                case 7:
                                    return 16;
                                case 8:
                                    return 20;
                                case 9:
                                    return 19;
                                case 10:
                                    return 19;
                                case 11:
                                    return 23;
                                case 12:
                                    return 22;
                                case 13:
                                    this.popState(), this.begin("com");
                                    break;
                                case 14:
                                    return e(3, 5), this.popState(), 15;
                                case 15:
                                    return 22;
                                case 16:
                                    return 41;
                                case 17:
                                    return 40;
                                case 18:
                                    return 40;
                                case 19:
                                    return 44;
                                case 20:
                                    break;
                                case 21:
                                    return this.popState(), 24;
                                case 22:
                                    return this.popState(), 18;
                                case 23:
                                    return b.yytext = e(1, 2).replace(/\\"/g, '"'), 32;
                                case 24:
                                    return b.yytext = e(1, 2).replace(/\\'/g, "'"), 32;
                                case 25:
                                    return 42;
                                case 26:
                                    return 34;
                                case 27:
                                    return 34;
                                case 28:
                                    return 33;
                                case 29:
                                    return 40;
                                case 30:
                                    return b.yytext = e(1, 2), 40;
                                case 31:
                                    return "INVALID";
                                case 32:
                                    return 5
                            }
                        }, a.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:[\s\S]*?--\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{!--)/, /^(?:\{\{![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:-?[0-9]+(?=([~}\s)])))/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/], a.conditions = {
                            mu: {
                                rules: [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32],
                                inclusive: !1
                            },
                            emu: {
                                rules: [2],
                                inclusive: !1
                            },
                            com: {
                                rules: [3],
                                inclusive: !1
                            },
                            INITIAL: {
                                rules: [0, 1, 32],
                                inclusive: !0
                            }
                        }, a
                    }();
                return c.lexer = d, b.prototype = c, c.Parser = b, new b
            }();
            return a = b
        }(),
        i = function(a, b) {
            "use strict";

            function c(a) {
                return a.constructor === f.ProgramNode ? a : (e.yy = f, e.parse(a))
            }
            var d = {},
                e = a,
                f = b;
            return d.parser = e, d.parse = c, d
        }(h, g),
        j = function(a) {
            "use strict";

            function b() {}

            function c(a, b, c) {
                if (null == a || "string" != typeof a && a.constructor !== c.AST.ProgramNode) throw new f("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + a);
                b = b || {}, "data" in b || (b.data = !0);
                var d = c.parse(a),
                    e = (new c.Compiler).compile(d, b);
                return (new c.JavaScriptCompiler).compile(e, b)
            }

            function d(a, b, c) {
                function d() {
                    var d = c.parse(a),
                        e = (new c.Compiler).compile(d, b),
                        f = (new c.JavaScriptCompiler).compile(e, b, void 0, !0);
                    return c.template(f)
                }
                if (null == a || "string" != typeof a && a.constructor !== c.AST.ProgramNode) throw new f("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + a);
                b = b || {}, "data" in b || (b.data = !0);
                var e;
                return function(a, b) {
                    return e || (e = d()), e.call(this, a, b)
                }
            }
            var e = {},
                f = a;
            return e.Compiler = b, b.prototype = {
                compiler: b,
                disassemble: function() {
                    for (var a, b, c, d = this.opcodes, e = [], f = 0, g = d.length; g > f; f++)
                        if (a = d[f], "DECLARE" === a.opcode) e.push("DECLARE " + a.name + "=" + a.value);
                        else {
                            b = [];
                            for (var h = 0; h < a.args.length; h++) c = a.args[h], "string" == typeof c && (c = '"' + c.replace("\n", "\\n") + '"'), b.push(c);
                            e.push(a.opcode + " " + b.join(" "))
                        }
                    return e.join("\n")
                },
                equals: function(a) {
                    var b = this.opcodes.length;
                    if (a.opcodes.length !== b) return !1;
                    for (var c = 0; b > c; c++) {
                        var d = this.opcodes[c],
                            e = a.opcodes[c];
                        if (d.opcode !== e.opcode || d.args.length !== e.args.length) return !1;
                        for (var f = 0; f < d.args.length; f++)
                            if (d.args[f] !== e.args[f]) return !1
                    }
                    if (b = this.children.length, a.children.length !== b) return !1;
                    for (c = 0; b > c; c++)
                        if (!this.children[c].equals(a.children[c])) return !1;
                    return !0
                },
                guid: 0,
                compile: function(a, b) {
                    this.opcodes = [], this.children = [], this.depths = {
                        list: []
                    }, this.options = b;
                    var c = this.options.knownHelpers;
                    if (this.options.knownHelpers = {
                            helperMissing: !0,
                            blockHelperMissing: !0,
                            each: !0,
                            "if": !0,
                            unless: !0,
                            "with": !0,
                            log: !0
                        }, c)
                        for (var d in c) this.options.knownHelpers[d] = c[d];
                    return this.accept(a)
                },
                accept: function(a) {
                    var b, c = a.strip || {};
                    return c.left && this.opcode("strip"), b = this[a.type](a), c.right && this.opcode("strip"), b
                },
                program: function(a) {
                    for (var b = a.statements, c = 0, d = b.length; d > c; c++) this.accept(b[c]);
                    return this.isSimple = 1 === d, this.depths.list = this.depths.list.sort(function(a, b) {
                        return a - b
                    }), this
                },
                compileProgram: function(a) {
                    var b, c = (new this.compiler).compile(a, this.options),
                        d = this.guid++;
                    this.usePartial = this.usePartial || c.usePartial, this.children[d] = c;
                    for (var e = 0, f = c.depths.list.length; f > e; e++) b = c.depths.list[e], 2 > b || this.addDepth(b - 1);
                    return d
                },
                block: function(a) {
                    var b = a.mustache,
                        c = a.program,
                        d = a.inverse;
                    c && (c = this.compileProgram(c)), d && (d = this.compileProgram(d));
                    var e = b.sexpr,
                        f = this.classifySexpr(e);
                    "helper" === f ? this.helperSexpr(e, c, d) : "simple" === f ? (this.simpleSexpr(e), this.opcode("pushProgram", c), this.opcode("pushProgram", d), this.opcode("emptyHash"), this.opcode("blockValue")) : (this.ambiguousSexpr(e, c, d), this.opcode("pushProgram", c), this.opcode("pushProgram", d), this.opcode("emptyHash"), this.opcode("ambiguousBlockValue")), this.opcode("append")
                },
                hash: function(a) {
                    var b, c, d = a.pairs;
                    this.opcode("pushHash");
                    for (var e = 0, f = d.length; f > e; e++) b = d[e], c = b[1], this.options.stringParams ? (c.depth && this.addDepth(c.depth), this.opcode("getContext", c.depth || 0), this.opcode("pushStringParam", c.stringModeValue, c.type), "sexpr" === c.type && this.sexpr(c)) : this.accept(c), this.opcode("assignToHash", b[0]);
                    this.opcode("popHash")
                },
                partial: function(a) {
                    var b = a.partialName;
                    this.usePartial = !0, a.context ? this.ID(a.context) : this.opcode("push", "depth0"), this.opcode("invokePartial", b.name), this.opcode("append")
                },
                content: function(a) {
                    this.opcode("appendContent", a.string)
                },
                mustache: function(a) {
                    this.sexpr(a.sexpr), a.escaped && !this.options.noEscape ? this.opcode("appendEscaped") : this.opcode("append")
                },
                ambiguousSexpr: function(a, b, c) {
                    var d = a.id,
                        e = d.parts[0],
                        f = null != b || null != c;
                    this.opcode("getContext", d.depth), this.opcode("pushProgram", b), this.opcode("pushProgram", c), this.opcode("invokeAmbiguous", e, f)
                },
                simpleSexpr: function(a) {
                    var b = a.id;
                    "DATA" === b.type ? this.DATA(b) : b.parts.length ? this.ID(b) : (this.addDepth(b.depth), this.opcode("getContext", b.depth), this.opcode("pushContext")), this.opcode("resolvePossibleLambda")
                },
                helperSexpr: function(a, b, c) {
                    var d = this.setupFullMustacheParams(a, b, c),
                        e = a.id.parts[0];
                    if (this.options.knownHelpers[e]) this.opcode("invokeKnownHelper", d.length, e);
                    else {
                        if (this.options.knownHelpersOnly) throw new f("You specified knownHelpersOnly, but used the unknown helper " + e, a);
                        this.opcode("invokeHelper", d.length, e, a.isRoot)
                    }
                },
                sexpr: function(a) {
                    var b = this.classifySexpr(a);
                    "simple" === b ? this.simpleSexpr(a) : "helper" === b ? this.helperSexpr(a) : this.ambiguousSexpr(a)
                },
                ID: function(a) {
                    this.addDepth(a.depth), this.opcode("getContext", a.depth);
                    var b = a.parts[0];
                    b ? this.opcode("lookupOnContext", a.parts[0]) : this.opcode("pushContext");
                    for (var c = 1, d = a.parts.length; d > c; c++) this.opcode("lookup", a.parts[c])
                },
                DATA: function(a) {
                    if (this.options.data = !0, a.id.isScoped || a.id.depth) throw new f("Scoped data references are not supported: " + a.original, a);
                    this.opcode("lookupData");
                    for (var b = a.id.parts, c = 0, d = b.length; d > c; c++) this.opcode("lookup", b[c])
                },
                STRING: function(a) {
                    this.opcode("pushString", a.string)
                },
                INTEGER: function(a) {
                    this.opcode("pushLiteral", a.integer)
                },
                BOOLEAN: function(a) {
                    this.opcode("pushLiteral", a.bool)
                },
                comment: function() {},
                opcode: function(a) {
                    this.opcodes.push({
                        opcode: a,
                        args: [].slice.call(arguments, 1)
                    })
                },
                declare: function(a, b) {
                    this.opcodes.push({
                        opcode: "DECLARE",
                        name: a,
                        value: b
                    })
                },
                addDepth: function(a) {
                    0 !== a && (this.depths[a] || (this.depths[a] = !0, this.depths.list.push(a)))
                },
                classifySexpr: function(a) {
                    var b = a.isHelper,
                        c = a.eligibleHelper,
                        d = this.options;
                    if (c && !b) {
                        var e = a.id.parts[0];
                        d.knownHelpers[e] ? b = !0 : d.knownHelpersOnly && (c = !1)
                    }
                    return b ? "helper" : c ? "ambiguous" : "simple"
                },
                pushParams: function(a) {
                    for (var b, c = a.length; c--;) b = a[c], this.options.stringParams ? (b.depth && this.addDepth(b.depth), this.opcode("getContext", b.depth || 0), this.opcode("pushStringParam", b.stringModeValue, b.type), "sexpr" === b.type && this.sexpr(b)) : this[b.type](b)
                },
                setupFullMustacheParams: function(a, b, c) {
                    var d = a.params;
                    return this.pushParams(d), this.opcode("pushProgram", b), this.opcode("pushProgram", c), a.hash ? this.hash(a.hash) : this.opcode("emptyHash"), d
                }
            }, e.precompile = c, e.compile = d, e
        }(c),
        k = function(a, b) {
            "use strict";

            function c(a) {
                this.value = a
            }

            function d() {}
            var e, f = a.COMPILER_REVISION,
                g = a.REVISION_CHANGES,
                h = a.log,
                i = b;
            d.prototype = {
                nameLookup: function(a, b) {
                    var c, e;
                    return 0 === a.indexOf("depth") && (c = !0), e = /^[0-9]+$/.test(b) ? a + "[" + b + "]" : d.isValidJavaScriptVariableName(b) ? a + "." + b : a + "['" + b + "']", c ? "(" + a + " && " + e + ")" : e
                },
                compilerInfo: function() {
                    var a = f,
                        b = g[a];
                    return "this.compilerInfo = [" + a + ",'" + b + "'];\n"
                },
                appendToBuffer: function(a) {
                    return this.environment.isSimple ? "return " + a + ";" : {
                        appendToBuffer: !0,
                        content: a,
                        toString: function() {
                            return "buffer += " + a + ";"
                        }
                    }
                },
                initializeBuffer: function() {
                    return this.quotedString("")
                },
                namespace: "Handlebars",
                compile: function(a, b, c, d) {
                    this.environment = a, this.options = b || {}, h("debug", this.environment.disassemble() + "\n\n"), this.name = this.environment.name, this.isChild = !!c, this.context = c || {
                        programs: [],
                        environments: [],
                        aliases: {}
                    }, this.preamble(), this.stackSlot = 0, this.stackVars = [], this.registers = {
                        list: []
                    }, this.hashes = [], this.compileStack = [], this.inlineStack = [], this.compileChildren(a, b);
                    var e, f = a.opcodes;
                    this.i = 0;
                    for (var g = f.length; this.i < g; this.i++) e = f[this.i], "DECLARE" === e.opcode ? this[e.name] = e.value : this[e.opcode].apply(this, e.args), e.opcode !== this.stripNext && (this.stripNext = !1);
                    if (this.pushSource(""), this.stackSlot || this.inlineStack.length || this.compileStack.length) throw new i("Compile completed with content left on stack");
                    return this.createFunctionContext(d)
                },
                preamble: function() {
                    var a = [];
                    if (this.isChild) a.push("");
                    else {
                        var b = this.namespace,
                            c = "helpers = this.merge(helpers, " + b + ".helpers);";
                        this.environment.usePartial && (c = c + " partials = this.merge(partials, " + b + ".partials);"), this.options.data && (c += " data = data || {};"), a.push(c)
                    }
                    this.environment.isSimple ? a.push("") : a.push(", buffer = " + this.initializeBuffer()), this.lastContext = 0, this.source = a
                },
                createFunctionContext: function(a) {
                    var b = this.stackVars.concat(this.registers.list);
                    if (b.length > 0 && (this.source[1] = this.source[1] + ", " + b.join(", ")), !this.isChild)
                        for (var c in this.context.aliases) this.context.aliases.hasOwnProperty(c) && (this.source[1] = this.source[1] + ", " + c + "=" + this.context.aliases[c]);
                    this.source[1] && (this.source[1] = "var " + this.source[1].substring(2) + ";"), this.isChild || (this.source[1] += "\n" + this.context.programs.join("\n") + "\n"), this.environment.isSimple || this.pushSource("return buffer;");
                    for (var d = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"], e = 0, f = this.environment.depths.list.length; f > e; e++) d.push("depth" + this.environment.depths.list[e]);
                    var g = this.mergeSource();
                    if (this.isChild || (g = this.compilerInfo() + g), a) return d.push(g), Function.apply(this, d);
                    var i = "function " + (this.name || "") + "(" + d.join(",") + ") {\n  " + g + "}";
                    return h("debug", i + "\n\n"), i
                },
                mergeSource: function() {
                    for (var a, b = "", c = 0, d = this.source.length; d > c; c++) {
                        var e = this.source[c];
                        e.appendToBuffer ? a = a ? a + "\n    + " + e.content : e.content : (a && (b += "buffer += " + a + ";\n  ", a = void 0), b += e + "\n  ")
                    }
                    return b
                },
                blockValue: function() {
                    this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                    var a = ["depth0"];
                    this.setupParams(0, a), this.replaceStack(function(b) {
                        return a.splice(1, 0, b), "blockHelperMissing.call(" + a.join(", ") + ")"
                    })
                },
                ambiguousBlockValue: function() {
                    this.context.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                    var a = ["depth0"];
                    this.setupParams(0, a);
                    var b = this.topStack();
                    a.splice(1, 0, b), this.pushSource("if (!" + this.lastHelper + ") { " + b + " = blockHelperMissing.call(" + a.join(", ") + "); }")
                },
                appendContent: function(a) {
                    this.pendingContent && (a = this.pendingContent + a), this.stripNext && (a = a.replace(/^\s+/, "")), this.pendingContent = a
                },
                strip: function() {
                    this.pendingContent && (this.pendingContent = this.pendingContent.replace(/\s+$/, "")), this.stripNext = "strip"
                },
                append: function() {
                    this.flushInline();
                    var a = this.popStack();
                    this.pushSource("if(" + a + " || " + a + " === 0) { " + this.appendToBuffer(a) + " }"), this.environment.isSimple && this.pushSource("else { " + this.appendToBuffer("''") + " }")
                },
                appendEscaped: function() {
                    this.context.aliases.escapeExpression = "this.escapeExpression", this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"))
                },
                getContext: function(a) {
                    this.lastContext !== a && (this.lastContext = a)
                },
                lookupOnContext: function(a) {
                    this.push(this.nameLookup("depth" + this.lastContext, a, "context"))
                },
                pushContext: function() {
                    this.pushStackLiteral("depth" + this.lastContext)
                },
                resolvePossibleLambda: function() {
                    this.context.aliases.functionType = '"function"', this.replaceStack(function(a) {
                        return "typeof " + a + " === functionType ? " + a + ".apply(depth0) : " + a
                    })
                },
                lookup: function(a) {
                    this.replaceStack(function(b) {
                        return b + " == null || " + b + " === false ? " + b + " : " + this.nameLookup(b, a, "context")
                    })
                },
                lookupData: function() {
                    this.pushStackLiteral("data")
                },
                pushStringParam: function(a, b) {
                    this.pushStackLiteral("depth" + this.lastContext), this.pushString(b), "sexpr" !== b && ("string" == typeof a ? this.pushString(a) : this.pushStackLiteral(a))
                },
                emptyHash: function() {
                    this.pushStackLiteral("{}"), this.options.stringParams && (this.push("{}"), this.push("{}"))
                },
                pushHash: function() {
                    this.hash && this.hashes.push(this.hash), this.hash = {
                        values: [],
                        types: [],
                        contexts: []
                    }
                },
                popHash: function() {
                    var a = this.hash;
                    this.hash = this.hashes.pop(), this.options.stringParams && (this.push("{" + a.contexts.join(",") + "}"), this.push("{" + a.types.join(",") + "}")), this.push("{\n    " + a.values.join(",\n    ") + "\n  }")
                },
                pushString: function(a) {
                    this.pushStackLiteral(this.quotedString(a))
                },
                push: function(a) {
                    return this.inlineStack.push(a), a
                },
                pushLiteral: function(a) {
                    this.pushStackLiteral(a)
                },
                pushProgram: function(a) {
                    null != a ? this.pushStackLiteral(this.programExpression(a)) : this.pushStackLiteral(null)
                },
                invokeHelper: function(a, b, c) {
                    this.context.aliases.helperMissing = "helpers.helperMissing", this.useRegister("helper");
                    var d = this.lastHelper = this.setupHelper(a, b, !0),
                        e = this.nameLookup("depth" + this.lastContext, b, "context"),
                        f = "helper = " + d.name + " || " + e;
                    d.paramsInit && (f += "," + d.paramsInit), this.push("(" + f + ",helper ? helper.call(" + d.callParams + ") : helperMissing.call(" + d.helperMissingParams + "))"), c || this.flushInline()
                },
                invokeKnownHelper: function(a, b) {
                    var c = this.setupHelper(a, b);
                    this.push(c.name + ".call(" + c.callParams + ")")
                },
                invokeAmbiguous: function(a, b) {
                    this.context.aliases.functionType = '"function"', this.useRegister("helper"), this.emptyHash();
                    var c = this.setupHelper(0, a, b),
                        d = this.lastHelper = this.nameLookup("helpers", a, "helper"),
                        e = this.nameLookup("depth" + this.lastContext, a, "context"),
                        f = this.nextStack();
                    c.paramsInit && this.pushSource(c.paramsInit), this.pushSource("if (helper = " + d + ") { " + f + " = helper.call(" + c.callParams + "); }"), this.pushSource("else { helper = " + e + "; " + f + " = typeof helper === functionType ? helper.call(" + c.callParams + ") : helper; }")
                },
                invokePartial: function(a) {
                    var b = [this.nameLookup("partials", a, "partial"), "'" + a + "'", this.popStack(), "helpers", "partials"];
                    this.options.data && b.push("data"), this.context.aliases.self = "this", this.push("self.invokePartial(" + b.join(", ") + ")")
                },
                assignToHash: function(a) {
                    var b, c, d = this.popStack();
                    this.options.stringParams && (c = this.popStack(), b = this.popStack());
                    var e = this.hash;
                    b && e.contexts.push("'" + a + "': " + b), c && e.types.push("'" + a + "': " + c), e.values.push("'" + a + "': (" + d + ")")
                },
                compiler: d,
                compileChildren: function(a, b) {
                    for (var c, d, e = a.children, f = 0, g = e.length; g > f; f++) {
                        c = e[f], d = new this.compiler;
                        var h = this.matchExistingProgram(c);
                        null == h ? (this.context.programs.push(""), h = this.context.programs.length, c.index = h, c.name = "program" + h, this.context.programs[h] = d.compile(c, b, this.context), this.context.environments[h] = c) : (c.index = h, c.name = "program" + h)
                    }
                },
                matchExistingProgram: function(a) {
                    for (var b = 0, c = this.context.environments.length; c > b; b++) {
                        var d = this.context.environments[b];
                        if (d && d.equals(a)) return b
                    }
                },
                programExpression: function(a) {
                    if (this.context.aliases.self = "this", null == a) return "self.noop";
                    for (var b, c = this.environment.children[a], d = c.depths.list, e = [c.index, c.name, "data"], f = 0, g = d.length; g > f; f++) b = d[f], 1 === b ? e.push("depth0") : e.push("depth" + (b - 1));
                    return (0 === d.length ? "self.program(" : "self.programWithDepth(") + e.join(", ") + ")"
                },
                register: function(a, b) {
                    this.useRegister(a), this.pushSource(a + " = " + b + ";")
                },
                useRegister: function(a) {
                    this.registers[a] || (this.registers[a] = !0, this.registers.list.push(a))
                },
                pushStackLiteral: function(a) {
                    return this.push(new c(a))
                },
                pushSource: function(a) {
                    this.pendingContent && (this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent))), this.pendingContent = void 0), a && this.source.push(a)
                },
                pushStack: function(a) {
                    this.flushInline();
                    var b = this.incrStack();
                    return a && this.pushSource(b + " = " + a + ";"), this.compileStack.push(b), b
                },
                replaceStack: function(a) {
                    var b, d, e, f = "",
                        g = this.isInline();
                    if (g) {
                        var h = this.popStack(!0);
                        if (h instanceof c) b = h.value, e = !0;
                        else {
                            d = !this.stackSlot;
                            var i = d ? this.incrStack() : this.topStackName();
                            f = "(" + this.push(i) + " = " + h + "),", b = this.topStack()
                        }
                    } else b = this.topStack();
                    var j = a.call(this, b);
                    return g ? (e || this.popStack(), d && this.stackSlot--, this.push("(" + f + j + ")")) : (/^stack/.test(b) || (b = this.nextStack()), this.pushSource(b + " = (" + f + j + ");")), b
                },
                nextStack: function() {
                    return this.pushStack()
                },
                incrStack: function() {
                    return this.stackSlot++, this.stackSlot > this.stackVars.length && this.stackVars.push("stack" + this.stackSlot), this.topStackName()
                },
                topStackName: function() {
                    return "stack" + this.stackSlot
                },
                flushInline: function() {
                    var a = this.inlineStack;
                    if (a.length) {
                        this.inlineStack = [];
                        for (var b = 0, d = a.length; d > b; b++) {
                            var e = a[b];
                            e instanceof c ? this.compileStack.push(e) : this.pushStack(e)
                        }
                    }
                },
                isInline: function() {
                    return this.inlineStack.length
                },
                popStack: function(a) {
                    var b = this.isInline(),
                        d = (b ? this.inlineStack : this.compileStack).pop();
                    if (!a && d instanceof c) return d.value;
                    if (!b) {
                        if (!this.stackSlot) throw new i("Invalid stack pop");
                        this.stackSlot--
                    }
                    return d
                },
                topStack: function(a) {
                    var b = this.isInline() ? this.inlineStack : this.compileStack,
                        d = b[b.length - 1];
                    return !a && d instanceof c ? d.value : d
                },
                quotedString: function(a) {
                    return '"' + a.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"'
                },
                setupHelper: function(a, b, c) {
                    var d = [],
                        e = this.setupParams(a, d, c),
                        f = this.nameLookup("helpers", b, "helper");
                    return {
                        params: d,
                        paramsInit: e,
                        name: f,
                        callParams: ["depth0"].concat(d).join(", "),
                        helperMissingParams: c && ["depth0", this.quotedString(b)].concat(d).join(", ")
                    }
                },
                setupOptions: function(a, b) {
                    var c, d, e, f = [],
                        g = [],
                        h = [];
                    f.push("hash:" + this.popStack()), this.options.stringParams && (f.push("hashTypes:" + this.popStack()), f.push("hashContexts:" + this.popStack())), d = this.popStack(), e = this.popStack(), (e || d) && (e || (this.context.aliases.self = "this", e = "self.noop"), d || (this.context.aliases.self = "this", d = "self.noop"), f.push("inverse:" + d), f.push("fn:" + e));
                    for (var i = 0; a > i; i++) c = this.popStack(), b.push(c), this.options.stringParams && (h.push(this.popStack()), g.push(this.popStack()));
                    return this.options.stringParams && (f.push("contexts:[" + g.join(",") + "]"), f.push("types:[" + h.join(",") + "]")), this.options.data && f.push("data:data"), f
                },
                setupParams: function(a, b, c) {
                    var d = "{" + this.setupOptions(a, b).join(",") + "}";
                    return c ? (this.useRegister("options"), b.push("options"), "options=" + d) : (b.push(d), "")
                }
            };
            for (var j = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "), k = d.RESERVED_WORDS = {}, l = 0, m = j.length; m > l; l++) k[j[l]] = !0;
            return d.isValidJavaScriptVariableName = function(a) {
                return !d.RESERVED_WORDS[a] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(a) ? !0 : !1
            }, e = d
        }(d, c),
        l = function(a, b, c, d, e) {
            "use strict";
            var f, g = a,
                h = b,
                i = c.parser,
                j = c.parse,
                k = d.Compiler,
                l = d.compile,
                m = d.precompile,
                n = e,
                o = g.create,
                p = function() {
                    var a = o();
                    return a.compile = function(b, c) {
                        return l(b, c, a)
                    }, a.precompile = function(b, c) {
                        return m(b, c, a)
                    }, a.AST = h, a.Compiler = k, a.JavaScriptCompiler = n, a.Parser = i, a.parse = j, a
                };
            return g = p(), g.create = p, f = g
        }(f, g, i, j, k);
    return l
}();
define("handlebars", (function(global) {
    return function() {
        var ret, fn;
        return ret || global.Handlebars;
    };
}(this)));

define('handlebarsHelpers', ['handlebars'], function(Handlebars) {
    Handlebars.registerHelper('rating', function(n) {
        var count = Math.floor(n),
            half = n % 1 !== 0,
            html,
            ratingText = $('body').data('rating-text');
        if (ratingText === 'star') {
            html = ['<ul class="star-rating" >'];

            for (var i = 0; i < count; i++) {
                html.push('<li class="icon-star"></li>');
            }

            if (half) {
                html.push('<li class="icon-star-half" />');
            }

            html.push('</ul>');
        } else {
            html = ['<ul class="text-rating" >'];

            for (var j = 0; j < count; j++) {
                html.push('<li>' + ratingText + '</li>');
            }

            if (half) {
                html.push('<li>+</li>');
            }

            html.push('</ul>');

        }

        return new Handlebars.SafeString(html.join(''));
    });

    // Airports list
    Handlebars.registerHelper('airportCols', function(context, options) {
        var total = context.length,
            colCount = 3,
            col = 12 / colCount,
            html = ['<div class="col-md-' + col + '"><ul>'],
            newCol = Math.ceil(total / colCount),
            counter = 0;

        for (var i = 0; i < total; i++) {
            if (counter === newCol) {
                html.push('</ul></div><div class="col-md-' + col + '"><ul>');
                counter = 0;
            }
            counter++;
            html.push('<li>' + options.fn(context[i]) + '</li>');
        }

        html.push('</ul></div>');

        return new Handlebars.SafeString(html.join(''));
    });

    // all destinations convert string into object key safe string
    // not used but kept for posible future use. all destinations now using the param as the key
    Handlebars.registerHelper('key', function(context, options) {
        return new Handlebars.SafeString(context.replace(/\&amp;|\s+/g, '_'));
    });


    // Strip html tags from text
    Handlebars.registerHelper('regionText', function(region) {
        // return region.replace(/<(?:.|\n)*?>/gm, '');
        var regionHtml = $('<div>').html(region);
        return regionHtml.text();
    });

    Handlebars.registerHelper('equal', function(lvalue, rvalue, options) {
        if (arguments.length < 3) {
            throw new Error('Handlebars Helper equal needs 2 parameter');
        }
        if (lvalue !== rvalue) {
            return options.inverse(this);
        } else {
            return options.fn(this);
        }
    });

    // Add data-code to destination tabs
    Handlebars.registerHelper('dataCode', function(dataValue) {
        var dataCodeValueArr = dataValue.split('|');
        return dataCodeValueArr[2];
    });

});
define('helpers/addClasses', ['jquery'], function($) {
    function matchUserAgent(regex, classes) {
        var ua = window.navigator.userAgent,
            passed = ua.match(regex) ? true : false;
        if (passed && classes) {
            $('html').addClass(classes);
        }
        return passed;
    }
    return matchUserAgent;
});
define('helpers/requestAnimationFrameWrapper', [], function() {
    return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(b, a) {
            window.setTimeout(b, 1000 / 60);
        };
});
/* global window, tui */
define('helpers/dockable', ['jquery', 'pubSub', './requestAnimationFrameWrapper'], function($, PubSub, animationFrame) {

    function DockableController() {
        this.items = [];
        this.doc = $(document);
        this.init();
    }
    var DCMethods = {
        init: function() {
            var that = this;
            var item, itemY, dock, undock;

            function _watchScroll() {
                if (that.opts.dontDockCondition && that.opts.dontDockCondition()) {
                    return;
                }

                var totalY = 0;
                var y = window.pageYOffset - totalY,
                    l = that.items.length;

                for (var i = 0; i < l; i++) {
                    item = that.items[i];
                    if (that.heightChanged()) {
                        item.setProps();
                        if (i === l) {
                            that.docHeight = that.doc.outerHeight(true);
                        }
                    }
                    itemY = item.y - totalY,
                        dock = y >= itemY && !that[item.id] && y !== 0 && item.conditionToDock(),
                        undock = y <= itemY && that[item.id];

                    if (dock || undock) {
                        $.publish('dockable/' + item.id, [totalY, y]);
                    }

                    if (item.isDocked) {
                        totalY += item.h;
                    }
                }
            }

            // runs on requestAnimationFrame to sync the event to the screen refresh
            var throttledEvent = function() {
                animationFrame(_watchScroll);
            };

            // bind the scrollevent
            $(window).on('scroll', throttledEvent);

            // store the document height on init [used for comparssion]
            this.docHeight = this.doc.outerHeight(true);
        },
        getDockedHeight: function() {
            var h = 0,
                l = this.items.length;
            for (var i = 0; i < l; i++) {
                h += this.items[i].isDocked ? this.items[i].h : 0;
            }
            return h;
        },
        calcPosititions: function() {
            var l = this.items.length,
                item;
            for (var i = 0; i < l; i++) {
                item = this.items[i];
                if (!item.isDocked) {
                    item.y = item.ele.offset().top + item.vOffset;
                    item.h = item.ele.outerHeight(true);
                }
            }
        },
        heightChanged: function() {
            var currentDocHeight = this.doc.outerHeight(true);
            return currentDocHeight !== this.docHeight;
        }
    };

    DockableController.prototype = $.extend({}, DockableController.prototype, DCMethods);

    // Dockable constructor
    function Dockable(ele, opts) {
        this.ele = ele;
        this.opts = $.extend({}, {
            vOffset: this.ele.data('offset') || 0,
            dockedClass: 'fixed',
            name: this.ele.data('name') || false,
            padBody: true,
            wrapper: $([]),
            breakpoints: ['lg'],
            conditionToDock: function() {
                return true;
            }
        }, opts);
        this.isDocked = false;
        this.id = this.opts.name || 'dockable' + Math.round(Math.random() * 1000000);
        this.namespace = 'dockable/' + this.id;
        this.init();
    }

    var methods = {
        init: function() {
            var that = this;
            if (!this.ele.length) {
                return;
            }
            var nameSpace = 'dockable/' + this.id;

            this.setProps();

            this.vOffset = this.opts.vOffset;

            $.subscribe(nameSpace, $.proxy(that.toggleDocking, that));

            window.tui = window.tui || {};

            tui.DockableController = tui.DockableController || new DockableController();
            tui.DockableController.opts = that.opts;

            this.controller = tui.DockableController;

            this.addToController();

            // tui.DockableController[this.id] = this.isDocked;
        },
        addToController: function() {
            this.controller.items.push(this);
            this.controller[this.id] = this.isDocked;
        },
        conditionToDock: function() {
            // return true;
            if ($.inArray(TUIUtil.getCurrentBreakPoint(), this.opts.breakpoints) < 0) {
                return false;
            }
            return this.opts.conditionToDock();
        },
        toggleDocking: function(event, yOffset, winY) {
            var that = this;

            this.ele[this.isDocked ? 'removeClass' : 'addClass'](this.opts.dockedClass)
                .css('top', !this.isDocked ? yOffset : 0);
            this.isDocked = this.ele.is('.' + this.opts.dockedClass);
            tui.DockableController[this.id] = this.isDocked;

            (function _padWrapper() {
                if (that.opts.wrapper.length && ($.inArray(TUIUtil.getCurrentBreakPoint(), that.opts.breakpoints) > -1)) {
                    var extraPadding = tui.DockableController.getDockedHeight();
                    that.opts.wrapper.css({
                        paddingTop: extraPadding
                    });
                }
            })();

            if (this.opts.onToggleDocking) {
                this.opts.onToggleDocking.call(this);
            }

        },
        setProps: function() {
            this.y = !this.isDocked ? (this.ele.offset().top + this.opts.vOffset) : this.y;
            this.h = this.ele.outerHeight(true);
        }
    };

    for (var key in methods) {
        Dockable.prototype[key] = methods[key];
    }

    $.fn.dockable = function(opts) {
        return this.each(function() {
            var $t = $(this);
            new Dockable($t, opts);
        });
    };

    return Dockable;
});
var Tui = Tui || {};

/*******************************************************************************
 * Tui Carousel Module
 * Depends on:
 * - jQuery
 * - jQuery Mobile (Custom, to get access to the 'vclick' event)
 ******************************************************************************/

Tui.carousel = (function() {
    'use strict';

    /**
     * Definition
     */

    var Carousel = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Carousel.defaults, options);

        this.init();
    };

    Carousel.prototype = {
        _isLocked: false,
        _isInited: false,
        _currentIndex: -1,

        //
        // Set up
        //
        init: function() {
            if (this._isInited) {
                return;
            }

            var o = this.options;
            var $element = this.$element;
            var $items, $container, $clonedItems, $newItems;
            var itemContainer, itemArray, firstItem;

            this._isInited = true;

            // Find item elements
            $items = this.$items = $element.find(o.itemSelector);

            // Bail out if there are no items, or only one
            if ($items.length <= 1) {
                return;
            }

            // Add our specified class to the main element
            if (o.mainClass) {
                $element.addClass(o.mainClass);
            }

            // Wrap items in containers, if specified
            if (o.addItem) {
                $clonedItems = $items.clone();
                itemArray = [];

                $clonedItems.each(function() {
                    itemContainer = document.createElement(o.itemTag);
                    itemContainer.appendChild(this);

                    itemArray.push(itemContainer);
                });

                $newItems = $(itemArray);
                $items.parent().html('').append($newItems);

                $items = this.$items = $newItems;
            }

            // Add our specified class to the items
            if (o.itemClass) {
                $items.addClass(o.itemClass);
            }

            // Wrap the items in a container element, or otherwise find an already
            // existing container element
            if (o.addContainer) {
                $container = this.$container = $(document.createElement(o.containerTag));
                $clonedItems = $items.clone();

                $container.append($clonedItems);

                $items.parent().html('').append($container);
                $items = this.$items = $clonedItems;
            } else {
                $container = this.$container = $element.find(o.containerSelector);
            }

            // Add our specified class to the container element
            if (o.containerClass) {
                $container.addClass(o.containerClass);
            }

            // Generate navigation (unless on mobile)
            if (o.showNavigation && !$.support.touch) {
                var $navigation = this.$navigation = $(o.navigationTemplate);
                $element.append($navigation);

                var $navigationPrevItem = this.$navigationPrevItem = $navigation.find(o.navigationPrevItemSelector);
                var $navigationNextItem = this.$navigationNextItem = $navigation.find(o.navigationNextItemSelector);

                // Bind navigation click events
                $navigation.on('vclick', o.navigationPrevLinkSelector + ',' + o.navigationNextLinkSelector, $.proxy(this.navigationClickHandler, this));
                $navigation.on('click', o.navigationPrevLinkSelector + ',' + o.navigationNextLinkSelector, $.proxy(this.navigationClickHandler, this));

            }

            // Generate indicator container
            if (o.showIndicators) {
                var $indicators = this.$indicators = $([]);
                var $indicatorContainer = this.$indicatorContainer = $(o.indicatorContainerTemplate);
                $element.append($indicatorContainer);

                // Bind indicator click events
                $indicatorContainer.on('vclick', o.indicatorSelector, $.proxy(this.indicatorClickHandler, this));
            }

            // Bind swipe events
            if ($.support.touch) {
                $element.on('swipeleft swiperight', $.proxy(this.swipeHandler, this));
            }

            // Set the width of the container and the items
            this.updateItemCount();

            // Set start position
            this.goTo(o.startAtIndex, true);
        },

        //
        // Return the number of items
        //
        getItemCount: function() {
            return this.$items ? this.$items.length : 0;
        },

        //
        // Call to update for the number of items
        //
        updateItemCount: function() {
            var $element = this.$element;
            var $container = this.$container;
            var $indicatorContainer = this.$indicatorContainer;
            var $items = this.$items;
            var o = this.options;

            var itemCount = this.getItemCount();
            var indicators;
            var i;

            // Set the width of the container and individual items
            $container.css('width', (itemCount * 100) + '%');
            $items.css('width', (100 / itemCount) + '%');

            // Clear the indicator container and add new indicators
            if ($indicatorContainer) {
                $indicatorContainer.empty();
                indicators = [];

                for (i = 0; i < itemCount; i++) {
                    indicators.push($(o.indicatorTemplate).get(0));
                }

                var $indicators = this.$indicators = $(indicators);
                $indicatorContainer.append($indicators);
            }
        },

        //
        // Go to the given index
        // - (Boolean)quick  Disable animations
        //
        goTo: function(index, quick) {
            var o = this.options;
            var itemCount = this.getItemCount();
            var currentIndex = this._currentIndex;

            var easing = o.easing;
            var duration = quick ? 0 : o.duration;

            var $container = this.$container;

            index = index || 0;

            if (this._isLocked || index < 0 || index >= itemCount || index === currentIndex) {
                return;
            }

            // Set the current item
            this._currentIndex = index;

            // Lock it
            this._isLocked = true;

            // Define what should happen after the animation has finished
            var after = $.proxy(function() {
                // Unlock
                this._isLocked = false;
            }, this);

            // Calculate the offset to animate the container by
            var offset = 100 * index;

            // Perform the animation
            $container.animate({
                left: -offset + '%'
            }, {
                duration: duration,
                easing: easing,
                complete: after
            });

            // Re-render elements
            this.renderNavigation();
            this.renderIndicators();
        },

        //
        // Re-render the indicators.
        // Set active class on the 'next' link if on anything but the last item
        // in the carousel; otherwise set inactive class.
        // Set active class on the 'prev' link if on anything but the first item;
        // otherwise set inactive.
        //
        renderNavigation: function() {
            var o = this.options;
            var $navigationPrevItem = this.$navigationPrevItem;
            var $navigationNextItem = this.$navigationNextItem;
            var currentIndex = this._currentIndex;
            var itemCount = this.getItemCount();

            if (!($navigationPrevItem && $navigationNextItem)) {
                return;
            }

            var activeClass = o.activeClass;
            var inactiveClass = o.inactiveClass;

            var isFirst = currentIndex === 0;
            var isLast = currentIndex === itemCount - 1;

            var $both = $navigationPrevItem.add($navigationNextItem);

            $both.removeClass(activeClass, inactiveClass);

            $navigationPrevItem.addClass(isFirst ? inactiveClass : activeClass);
            $navigationNextItem.addClass(isLast ? inactiveClass : activeClass);
        },

        //
        // Re-render the indicators
        // Set active class on the indicator corresponding to the currently active
        // item in the carousel; set inactive class on all other indicators.
        //
        renderIndicators: function() {
            var o = this.options;
            var $indicators = this.$indicators;
            var currentIndex = this._currentIndex;

            if (!$indicators) {
                return;
            }

            var activeClass = o.activeClass;
            var inactiveClass = o.inactiveClass;

            $indicators.removeClass(activeClass).addClass(inactiveClass);

            $indicators.slice(currentIndex, currentIndex + 1).removeClass(inactiveClass).addClass(activeClass);
        },

        //
        // Click handler for navigation links
        // Checks if the clicked link is a next or previous one, and spins
        // the carousel accordingly. If already at the end/beginning,
        // doesn't do anything.
        // - (Event)e
        //
        navigationClickHandler: function(e) {
            e.preventDefault();

            var o = this.options;
            var currentIndex = this._currentIndex;

            var $target = $(e.currentTarget);
            var index;

            if ($target.is(o.navigationPrevLinkSelector)) {
                index = currentIndex - 1;
            } else if ($target.is(o.navigationNextLinkSelector)) {
                index = currentIndex + 1;
            }

            this.goTo(index);
        },

        //
        // Click handler for indicators
        // Spins the carousel to the corresponding index of the clicked indicator.
        // - (Event)e
        //
        indicatorClickHandler: function(e) {
            e.preventDefault();

            var o = this.options;
            var $indicators = this.$indicators;

            var $target = $(e.currentTarget);

            var index = $indicators.index($target);

            this.goTo(index);
        },

        //
        // Handle swipe events on the main element
        // swipeleft spins the carousel to the next item; swiperight spins it to
        // the previous one.
        // - (Event)e
        //
        swipeHandler: function(e) {
            var o = this.options;
            var currentIndex = this._currentIndex;

            var index;

            if (e.type === 'swipeleft') {
                index = currentIndex + 1;
            } else if (e.type === 'swiperight') {
                index = currentIndex - 1;
            }

            this.goTo(index);
        }
    };

    /**
     * Default Options
     */

    Carousel.defaults = {
        showIndicators: true,
        showNavigation: true,
        addContainer: false,
        addItem: false,

        startAtIndex: 0,

        duration: 320,
        easing: 'swing',

        activeClass: 'bs-carousel-active',
        inactiveClass: 'bs-carousel-inactive',

        mainClass: 'bs-carousel',

        containerTag: 'UL',
        containerClass: 'bs-carousel-container',
        containerSelector: null,

        itemTag: 'LI',
        itemClass: 'bs-carousel-item',
        itemSelector: null,

        navigationTemplate: '<ul class="bs-carousel-navigation"><li class="bs-carousel-navigation-prev"><a href="#" class="bs-carousel-navigation-prev-link"></a></li><li class="bs-carousel-navigation-next"><a href="#" class="bs-carousel-navigation-next-link"></a></li></ul>',
        indicatorContainerTemplate: '<ul class="bs-carousel-indicators"></ul>',
        indicatorTemplate: '<li class="bs-carousel-indicator"><span></span></li>',
        navigationPrevItemSelector: 'li.bs-carousel-navigation-prev',
        navigationNextItemSelector: 'li.bs-carousel-navigation-next',
        navigationPrevLinkSelector: 'a.bs-carousel-navigation-prev-link',
        navigationNextLinkSelector: 'a.bs-carousel-navigation-next-link',
        indicatorSelector: 'li.bs-carousel-indicator'
    };


    /**
     * Return
     */

    return Carousel;
}());

define("helpers/tui.carousel", function() {});

define('helpers/resize', [
        'jquery',
        'pubSub'
    ],
    function($) {
        function Resizer(opts) {
            this.opts = $.extend({}, {
                sizes: {
                    xs: 480,
                    sm: 768,
                    md: 992,
                    lg: 1024
                }
            }, opts);
            this.currentSize = this.opts.sizes.xs;
        }

        Resizer.prototype.init = function() {
            var $d = $(document),
                that = this,
                sizes = this.opts.sizes,
                size,
                namedsize = (function(t) {
                    for (var key in t.opts.sizes) {
                        return key;
                    }
                })(this);

            $(window).on('resize', function() {
                size = $d.width();
                for (var key in sizes) {
                    namedsize = size >= sizes[key] ? key : namedsize;
                }
                if (that.currentSize !== namedsize) {
                    that.currentSize = namedsize;
                    $.publish('breakpointchange', namedsize);
                }
            });

            function _getCurrentSize(e, result) {
                that.currentSize = result;
            }

            $.subscribe('breakpointchange', _getCurrentSize);
            $(window).trigger('resize');
            $.unsubscribe('breakpointchange', _getCurrentSize);

            return this;
        };

        return Resizer;
    });
// contains global js, jquery, handlebars etc
/* global tuiConfig */
require([
    'jquery',
    'jqueryCookie',
    'pubSub',
    'handlebars',
    'handlebarsHelpers',
    'helpers/addClasses',
    'helpers/dockable',
    'helpers/tui.carousel',
    'helpers/resize'
], function($, jqueryCookie, pubSub, Handlebars, handlebarsHelpers, addClasses, Dockable, Carousel, Resizer) {
    // set any global events, config inits etc

    // checks for IOS devices and adds 'IOS' class to HTML tag. Used as a css hook
    addClasses(/iPhone|iPad|iPod/i, 'IOS');

    // set global namespaces
    if (typeof(tuiConfig) === 'undefined') {
        window.tuiConfig = {};
    }
    if (typeof(tui) === 'undefined') {
        window.tui = {};
    }
    if (typeof(tui.commonUX) === 'undefined') {
        window.tui.commonUX = {};
    }
    // tuiConfig = typeof(tuiConfig) !== undefined ? tuiConfig : {};
    tuiConfig.resizer = new Resizer({
        sizes: tuiConfig.breakpoints
    }).init();

});

define("base", function() {});

/**
 * @license RequireJS text 2.0.5 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text', ['module'], function(module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.5',

        strip: function(content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function(content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function() {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId]; // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function(name) {
            var modName, ext, temp,
                strip = false,
                index = name.indexOf("."),
                isRelative = name.indexOf('./') === 0 ||
                name.indexOf('../') === 0;

            if (index !== -1 && (!isRelative || index > 1)) {
                modName = name.substring(0, index);
                ext = name.substring(index + 1, name.length);
            } else {
                modName = name;
            }

            temp = ext || modName;
            index = temp.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = temp.substring(index + 1) === "strip";
                temp = temp.substring(0, index);
                if (ext) {
                    ext = temp;
                } else {
                    modName = temp;
                }
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function(url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function(name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function(name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName +
                (parsed.ext ? '.' + parsed.ext : ''),
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function(content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function(err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function(content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                        parsed.strip, content, onLoad);
                });
            }
        },

        write: function(pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                    "define(function () { return '" +
                    content +
                    "';});\n");
            }
        },

        writeFile: function(pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                extPart = parsed.ext ? '.' + parsed.ext : '',
                nonStripName = parsed.moduleName + extPart,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + extPart) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function(value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function(contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function(moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (masterConfig.env === 'node' || (!masterConfig.env &&
            typeof process !== "undefined" &&
            process.versions &&
            !!process.versions.node)) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function(url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
            text.createXhr())) {
        text.get = function(url, callback, errback, headers) {
            var xhr = text.createXhr(),
                header;
            xhr.open('GET', url, true);

            //Allow plugins direct access to xhr headers
            if (headers) {
                for (header in headers) {
                    if (headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);
                    }
                }
            }

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function(evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
            typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
        //Why Java, why is this so awkward?
        text.get = function(url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return text;
});


define('text!search-panel/templates/destination-browse-list-v3.hbs', [], function() {
    return '<div class="seprator"></div>\n<div class="country-flyout-header">\n\t<span class="right">\n\t\t<a class="btn-done" href="#"><i class="icon-x"></i></a>\n\t</span>\n</div>\n<section class="scrollable-container">\n\t{{#each columnList}}\n\t\t<div class="col-{{colName}} col-md-4 col-sm-6 col-xs-12">\n\t\t\t<ul class="col-{{colName}}-list">\n\t\t\t\t{{#each columnItems}}\n\t\t\t\t\t<li class="country">\n\t\t\t\t\t\t<div class="country-name {{#if disabled}}disabled {{/if}} {{#if selected}}selected {{/if}} " tabindex="0">\n\t\t\t\t\t\t\t<span class="country-name-container" data-code="{{destinationCode}}" data-type="{{destinationType}}" data-hierarchy="{{destinationHierarchy}}" >{{destinationName}}</span>\n\t\t\t\t\t\t\t<span class="icon-wrapper show-destination"><i class="icon-way-right"></i></span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<ul class="country-destinations" >\n\t\t\t\t\t\t\t{{#each children}}\n\t\t\t\t\t\t\t\t<li class="child {{destinationType}}" data-code="{{destinationCode}}" data-type="{{destinationType}}" data-hierarchy="{{destinationHierarchy}}" >\n\t\t\t\t\t\t\t\t\t<div class="child-name  {{#if disabled}}disabled {{/if}}  {{#if selected}}selected{{/if}}" >\n\t\t\t\t\t\t\t\t\t\t<span class="name-text">{{destinationName}}</span>\n\t\t\t\t\t\t\t\t\t\t{{#if selected}}\n\t\t\t\t\t\t\t\t\t\t\t<span class="icon-close-circle remove-leaf"></span>\n\t\t\t\t\t\t\t\t\t\t{{/if}}\n\t\t\t\t\t\t\t\t\t\t<span class="show-resorts icon-wrapper hidden"><i class="icon-way-right"></i></span>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</li>\n\t\t\t\t\t\t\t{{/each}}\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</li>\n\t\t\t\t{{/each}}\n\t\t\t</ul>\n\t\t</div>\n\t{{/each}}\n</section>\n';
});


define('text!search-panel/templates/disabledDestinationMessage.hbs', [], function() {
    return '\n{{#if  validationErrorMessage}}\n\t\t<div class="validation-err-msg error-msg" data-targetPanel="{{validationErrorMessage.validationType}}">\n\n\n\t\t\t<p>{{{validationErrorMessage.message}}}</p>\n\n\t\t\t{{#if validationErrorMessage.matchedDestination}}\n\t\t\t\t<p><a id="{{validationErrorMessage.matchedDestination.code}}" data-name="{{validationErrorMessage.matchedDestination.name}}" data-hierarchy="{{validationErrorMessage.matchedDestination.hierarchy}}" data-type="{{validationErrorMessage.matchedDestination.type}}" data-code="{{validationErrorMessage.matchedDestination.code}}" data-countrycode="{{validationErrorMessage.matchedDestination.countryCode}}" class="alternate-link" href="javascript:void(0)"><em>{{{validationErrorMessage.alternateLinkText}}}</em></a> </p>\n\t\t\t{{/if}}\n\t\t</div>\n{{/if}}\n';
});


define('text!search-panel/templates/destination-children-v3.hbs', [], function() {
    return '\n<li class="child select-label" data-code="{{parentCode}}" data-type="{{parentType}}" data-hierarchy="{{parentHierarchy}}" data-name="{{parentName}}" >\n\t\t<div class="child-name  select-all-destinations {{#if parentDisabled}}disabled {{/if}}  {{#if parentSelected}}selected{{/if}}">\n\t\t\t<span class="name-text">{{selectAllLabel}} {{parentName}}</span>\n\t\t\t{{#if parentSelected}}\n\t\t\t\t<span class="icon-close-circle remove-leaf remove-country"></span>\n\t\t\t{{/if}}\n\t\t</div>\n</li>\n\n{{#each results}}\n\t<li class="child {{#equal destinationType \'destination\'}} destination {{/equal}} {{#equal destinationType \'resort\'}} resort orphan {{/equal}} {{#equal destinationType \'region\'}} resort orphan {{/equal}}{{#if disabled}} disabled {{/if}}  {{#if selected}}selected{{/if}}" data-code="{{destinationCode}}" data-type="{{destinationType}}" data-hierarchy="{{destinationHierarchy}}" >\n\t\t<div class="child-name {{#equal destinationType \'destination\'}} destination {{/equal}} {{#equal destinationType \'resort\'}} resort {{/equal}} {{#equal destinationType \'region\'}} resort {{/equal}} {{#if disabled}}disabled {{/if}}  {{#if selected}}selected{{/if}}">\n\t\t\t<span class="name-text">{{destinationName}}</span>\n\t\t\t{{#equal destinationType \'destination\'}}\n\t\t\t\t<span class="show-resorts icon-wrapper"><i class="icon-way-right"></i></span>\n\t\t\t{{/equal}}\n\t\t\t{{#if selected}}\n\t\t\t\t{{#equal destinationType \'resort\'}}\n\t\t\t\t\t<span class="icon-close-circle remove-leaf"></span>\n\t\t\t\t{{/equal}}\n\t\t\t\t{{#equal destinationType \'region\'}}\n\t\t\t\t\t<span class="icon-close-circle remove-leaf"></span>\n\t\t\t\t{{/equal}}\n\t\t\t{{/if}}\n\t\t</div>\n\t\t{{#equal destinationType \'destination\'}}\n\t\t\t<ul class="resorts-container">\n\t\t\t</ul>\n\t\t{{/equal}}\n\t</li>\n{{/each}}\n';
});


define('text!search-panel/templates/resorts-children-v3.hbs', [], function() {
    return '\n<li class="child select-label" data-code="{{parentCode}}" data-type="{{parentType}}" data-hierarchy="{{parentHierarchy}}" data-name="{{parentName}}">\n\t\t<div class="child-name select-all-resorts {{#if parentDisabled}}disabled {{/if}}  {{#if parentSelected}}selected{{/if}}">\n\t\t\t<span class="name-text">{{selectAllLabel}} {{parentName}}</span>\n\t\t\t{{#if parentSelected}}\n\t\t\t\t<span class="icon-close-circle remove-leaf remove-destination"></span>\n\t\t\t{{/if}}\n\t\t</div>\n</li>\n\n{{#each results}}\n\t<li class="child {{destinationType}} {{#if disabled}}disabled {{/if}} {{#if selected}}selected{{/if}}" data-code="{{destinationCode}}" data-type="{{destinationType}}" data-hierarchy="{{destinationHierarchy}}" >\n\t\t<div class="child-name resort-name {{#if disabled}}disabled {{/if}}  {{#if selected}}selected{{/if}}">\n\t\t\t<span class="name-text">{{destinationName}}</span>\n\t\t\t{{#if selected}}\n\t\t\t\t<span class="icon-close-circle remove-leaf"></span>\n\t\t\t{{/if}}\n\t\t</div>\n\t</li>\n{{/each}}\n';
});

define('search-panel/search-destination-v3', [
    'base',
    'jquery',
    'handlebars',
    'text!./templates/destination-browse-list-v3.hbs',
    'text!./templates/disabledDestinationMessage.hbs',
    'text!./templates/destination-children-v3.hbs',
    'text!./templates/resorts-children-v3.hbs'
], function(base, $, Handlebars, countryTemplate, disabledDestTemplate, destinationTemplate, resortsTemplate) {
    function DestinationBrowseList(ele, opts) {
        if (!ele || !ele.length) {
            return false;
        }
        this.ele = ele;
        this.animationSpeed = 400;
        this.template = Handlebars.compile(countryTemplate);
        this.controller = opts.controller;
        this.autosuggest = opts.autosuggest;
        this.disabledDestTemplate = Handlebars.compile(disabledDestTemplate);
        this.destinationTemplate = Handlebars.compile(destinationTemplate);
        this.resortTemplate = Handlebars.compile(resortsTemplate);
        this.init();
        this.labels = this.ele.data('labels');
    }
    var that;
    var methods = {
        init: function() {
            that = this;
            that.setVariables();
            that.selectEvent();
            that.unselectEvent();
            that.ele.on('click', function() {
                // Event to close the tooltip validation if any, this event should not restrict any other event.
                // dont use preventDefault or StopPropagation here
                TUIUtil.closeTooltip(that.ele, that.closeTooltipAction);
            });
        },
        setVariables: function() {
            that.countryContainer = that.ele.find('.country-container');
            that.countryService = that.countryContainer.data('countryservice');
            that.destinationService = that.countryContainer.data('destinationservice');
            that.resortService = that.countryContainer.data('resortservice');

            that.maxItemsInAColumn = 10;
        },
        loadCountries: function() { // ajax call to load the countries
            that.cleanup(that.countryContainer);
            that.countryContainer.removeAttr('style');
            var $dfd = $.Deferred();
            var postData = $.extend({}, that.controller.getFormValues(), {
                destinationTab: 'allDestinations-countries'
            });
            TUIUtil.genericAjaxRequest({
                dontPool: true,
                url: that.countryService,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(json) {
                that.renderCountryDetsinations(json);
                that.ele.find('.panel').removeClass('flyout-loading');
                that.controller.targetedPanel.removeClass('loading');
            });
            return $dfd.promise();
        },
        cleanup: function(elem) { // to clean the container first
            elem.empty();
        },
        loadDestinations: function(container, parentContainer) { // ajax call to load destinations for particular country
            TUIUtil.toggleLoader(container.parents('li.country'), false);
            that.cleanup(container);
            var $dfd = $.Deferred();
            var postData = $.extend({}, that.controller.getFormValues(), {
                destinationTab: 'allDestinations-country',
                destinationKey: parentContainer.data('code'),
                destinationType: parentContainer.data('type')
            });
            TUIUtil.genericAjaxRequest({
                url: that.destinationService,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(json) {
                var updatedJSON = that.updateJSON(json, parentContainer);
                var updateParentSelection = that.checkAllChildStatus(updatedJSON);
                TUIUtil.toggleLoader(container.parents('li.country'), true);
                container.append(that.destinationTemplate(updateParentSelection)); // _slideDown(_t);
            });
            return $dfd.promise();
        },
        loadResorts: function(container, parentContainer) { // ajax call to load resorts for particular destination
            that.cleanup(container);
            TUIUtil.toggleLoader(container.parents('li.child'), false);
            var $dfd = $.Deferred();
            var postData = $.extend({}, that.controller.getFormValues(), {
                destinationTab: 'allDestinations-country',
                destinationKey: parentContainer.data('code'),
                destinationType: parentContainer.data('type'),
                countryKey: parentContainer.parents('.country').find('.country-name-container').data('code')
            });
            TUIUtil.genericAjaxRequest({
                url: that.resortService,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(json) {
                var updatedJSON = that.updateJSON(json, parentContainer);
                var updateParentSelection = that.checkAllChildStatus(updatedJSON);
                TUIUtil.toggleLoader(container.parents('li.child'), true);
                container.append(that.resortTemplate(updateParentSelection)); // _slideDown(_t);
            });
            return $dfd.promise();
        },
        updateJSON: function(json, container) { // method to update response json with parent details
            json.selectAllLabel = that.labels.selectAllLabel;
            json.parentCode = container.data('code');
            json.parentType = container.data('type');
            json.parentHierarchy = container.data('hierarchy');
            json.parentName = container.text();
            return json;
        },
        checkAllChildStatus: function(json) { // method to check if all child resorts are selected then select allDestination label
            var activeResorts = 0,
                selectedResorts = 0;
            $.each(json.results, function(i, resort) {
                if (!resort.disabled) {
                    activeResorts++;
                }
                if (resort.selected) {
                    selectedResorts++;
                }
            });
            if ((activeResorts === selectedResorts) && (selectedResorts !== 0)) {
                json.parentSelected = true;
            }
            if (activeResorts === 0) {
                json.parentDisabled = true;
            }
            return json;
        },
        renderCountryDetsinations: function(json) {
            that.setMaxColumnSize(json);
            json = that.distributeInColumns(json);
            that.countryContainer.append(that.template(json)); // _slideDown(_t);
            // that.addScrollbar();
        },
        setMaxColumnSize: function(json) {
            var counter = json.results.length,
                colSize;
            $.each(json.results, function(i, country) {
                counter += country.children.length;
            });
            if (TUIUtil.getCurrentBreakPoint() === 'sm') {
                colSize = counter / 2 || that.maxItemsInAColumn;
            } else {
                colSize = counter / 3 || that.maxItemsInAColumn;
            }
            colSize = parseInt(colSize, 10) + 1;
            that.maxItemsInAColumn = colSize;
        },
        distributeInColumns: function(json) {


            var col1 = [],
                col2 = [],
                col3 = [],
                col1Full, col2Full;

            $.each(json.results, function(i, item) {

                var col1Availability = that.getColumnAvailability(col1);
                if (col1Availability > 0 && item.children.length <= col1Availability && !col1Full) {
                    col1.push(item);
                    return true;
                }
                col1Full = true;

                var col2Availability = that.getColumnAvailability(col2);
                if (col2Availability > 0 && item.children.length <= col2Availability && !col2Full) {
                    col2.push(item);
                    return true;
                }
                col2Full = true;

                col3.push(item);
            });

            var newJSON = {
                columnList: [{
                    colName: 'one',
                    columnItems: col1
                }, {
                    colName: 'two',
                    columnItems: col2
                }, {
                    colName: 'three',
                    columnItems: col3
                }]
            };

            return newJSON;

        },
        getColumnAvailability: function(col) {
            var counter = 0;
            $.each(col, function(i, item) {
                counter = counter + item.children.length + 1;
            });
            return that.maxItemsInAColumn - counter;
        },
        selectEvent: function() {
            that.countryContainer.on('click', '.resort-name:not(.disabled):not(.selected), .child-name.resort:not(.disabled):not(.selected) ', that.handleChildAddition);
            that.countryContainer.on('click', '.child-name.disabled , .country-name.disabled ', that.addDisabledDestination);
            that.countryContainer.on('click', '.select-all-destinations:not(.disabled):not(.selected), .select-all-resorts:not(.disabled):not(.selected)', that.handleParentAddition);
            that.countryContainer.on('click', '.country-name:not(.disabled)', that.expandCollapseDestination);
            that.countryContainer.on('click', '.child-name.destination:not(.disabled)', that.expandCollapseDestination);
            that.countryContainer.on('keydown', that.handleKeyNavigation);
            that.countryContainer.on('mouseover', '.country-name, .child-name', function(e) {
                var activeListItem = $(e.delegateTarget).find('.active');
                if (activeListItem.length) {
                    activeListItem.removeClass('active');
                }
                $(this).addClass('active').focus();
            });

            that.countryContainer.on('mouseleave', '.country-name, .child-name', function(e) {
                $(this).removeClass('active');
            });


        },
        expandCollapseDestination: function() { // handle accordion of country and destination and make ajax call
            var $this = $(this),
                container, childrenContainer, isCountry = false,
                iconWrapper = $this.find('i');

            if ($this.hasClass('country-name')) {
                isCountry = true;
                container = $this.find('.country-name-container');
                childrenContainer = $this.next('.country-destinations');
            } else {
                container = $this.parents('li.child');
                childrenContainer = $this.next('.resorts-container');
            }

            if ($this.hasClass('open')) {
                $this.removeClass('open');
                iconWrapper.removeClass('icon-way-down').addClass('icon-way-right');
                childrenContainer.empty();
            } else {
                $this.addClass('open');
                iconWrapper.removeClass('icon-way-right').addClass('icon-way-down');
                if (isCountry) {
                    that.loadDestinations(childrenContainer, container);
                } else {
                    that.loadResorts(childrenContainer, container);
                }
            }
        },

        unselectEvent: function() {
            that.countryContainer.on('click', '.icon-close-circle', that.handleSelectionRemoval);
        },
        getScrollableHeight: function() {
            var pHeight = that.countryContainer.closest('.panel').height();
            return pHeight * 0.8 || 400;
        },
        expandDestination: function() {

        },
        createBreadCrumbs: function() {

        },
        breadCrumbEventHandler: function() {

        },
        addDisabledDestination: function() { // validate and show error message for disabled destinations
            var $this = $(this),
                code, name, type, countrycode, hierarchy;

            if ($this.hasClass('country-name')) {
                var span = $this.find('span.country-name-container');
                code = span.data('code');
                countrycode = code;
                type = span.data('type');
                name = span.text();
                hierarchy = span.data('hierarchy');
            } else {
                var elem = $this.parents('.child');
                code = elem.data('code');
                countrycode = elem.parents('.country').find('.country-name-container').data('code');
                type = elem.data('type');
                name = elem.find('.name-text').text();
                hierarchy = elem.data('hierarchy');
            }
            var destinationJson = {
                code: code,
                name: name,
                countrycode: countrycode,
                type: type,
                hierarchy: hierarchy
            };
            that.autosuggest.validateDisabledDestination(destinationJson, that.showDisabledMessage, $this, that.ele);

        },
        showDisabledMessage: function(data, element) {
            that.ele.find('.loader-container').remove();
            that.ele.find('.tui-tooltip-inline').remove();

            if ($.isEmptyObject(data)) {
                return;
            }

            var validationData = data.validationErrorMessage;
            TUIUtil.showInlineMessage(element, {
                message: that.disabledDestTemplate(data),
                cssClass: 'alldestination-tooltip',
                closeIcon: true,
                closeTooltipCallback: that.closeTooltipAction

            });
            that.controller.changeDateAction(validationData);
            $('.alldestination-tooltip').width(that.countryContainer.find('.country-name').first().width());
            setTimeout(function() {
                that.checkIfScrollbar();
            }, 100);
        },
        checkIfScrollbar: function() {
            var sHeight = that.controller.ele[0].scrollHeight;
            var height = that.controller.ele.height();
            TUIUtil.printLog('Search Panel scrollableHeight : ' + sHeight + ' & normal height is: ' + height);
            var delta = sHeight - height;
            if (delta > 0) {
                var cHeight = that.countryContainer.height();
                that.countryContainer.height(cHeight + delta);
            }
        },
        closeTooltipAction: function(e) {
            return true;
        },
        addRemoveTags: function(parentDestination, selectedChild, isAddTag, currentCode) { // remove child tags and add parent tag
            if (isAddTag) { // Adding tags
                $.each(selectedChild, function(i, currentChild) {
                    var code = $(currentChild).parents('.child').data('code');
                    that.autosuggest.removeTag('', '', code);
                });
                if (parentDestination.hasClass('country-name-container')) {
                    parentDestination.parents('.country').find('.select-all-destinations').trigger('click');
                } else {
                    parentDestination.find('.select-all-resorts').trigger('click');
                }
            } else { // Removing tag(s)
                var parentCode, countryCode, keepPanelOpen = true;
                if (parentDestination.hasClass('destination')) {
                    parentCode = parentDestination.data('code');
                    countryCode = parentDestination.parents('.country').find('.country-name-container').data('code');
                    that.autosuggest.removeTag('', '', parentCode);
                } else {
                    countryCode = parentDestination.find('.country-name-container').data('code');
                    that.autosuggest.removeTag('', '', countryCode);
                }
                // country.find('.icon-close-circle').trigger('click');
                $.each(selectedChild, function(i, currentChild) {
                    var $this = $(currentChild),
                        code = $this.data('code'),
                        type = $this.data('type'),
                        hierarchy = $this.data('hierarchy'),
                        name = $.trim($this.find('span:eq(0)').text());
                    if (currentCode !== code) {
                        that.addDirectTag(name, type, code, hierarchy, countryCode, '', keepPanelOpen);
                        $this.find('.child-name').addClass('selected');
                    }

                });

            }
        },
        addDirectTag: function(name, type, code, hierarchy, countryCode, isChild, keepPanelOpen, element) {
            that.autosuggest.addTag(name, type, code, hierarchy, countryCode, isChild);
            if (!keepPanelOpen && TUIUtil.getCurrentBreakPoint() !== 'xs') {
                that.flySpan(element);
            } else {
                that.controller.scrollTillSearchPanel();
            }
        },
        handleChildAddition: function() { // add child resorts
            var $this = $(this),
                $parent = $this.parent(),
                name = $.trim($this.find('span:eq(0)').text()),
                type = $parent.data('type'),
                code = $parent.data('code'),
                hierarchy = $parent.data('hierarchy'),
                siblings,
                disabledSiblings,
                selectedSiblings,
                activeSiblings,
                $parentDestination,
                countryCode = $this.parents('li.country').find('.country-name-container').data('code');
            if ($this.hasClass('resort-name')) {
                $parentDestination = $parent.parents('.destination'),
                    siblings = $parent.siblings('.resort');
            } else {
                $parentDestination = $parent.parents('.country').find('.country-name-container'),
                    siblings = $parent.siblings(':not(.select-label)');
            }

            disabledSiblings = siblings.find('.disabled'),
                selectedSiblings = siblings.find('.selected'),
                activeSiblings = siblings.length - disabledSiblings.length;
            if (activeSiblings === selectedSiblings.length) {
                that.addRemoveTags($parentDestination, selectedSiblings, true);
            } else {
                that.addDirectTag(name, type, code, hierarchy, countryCode, '', false, $this);
            }
        },
        handleParentAddition: function() {
            var $this = $(this),
                destination = $this.parent(),
                code = destination.data('code'),
                type = destination.data('type'),
                hierarchy = destination.data('hierarchy'),
                name;
            if ($this.hasClass('select-all-resorts') || $this.hasClass('select-all-destinations')) {
                name = destination.data('name');
                that.removeChildren($this);
            } else {
                name = $.trim($this.find('span:eq(0)').text());
            }

            if ($this.hasClass('select-all-resorts')) {
                var $parentDestination = $this.parents('.country'),
                    $parentcontainer = $parentDestination.find('.country-name-container'),
                    childDestinations = $parentDestination.find('li.destination'),
                    orphanResorts = $parentDestination.find('.orphan'),
                    disabledChildDestinations = childDestinations.filter('.disabled'),
                    selectedkids = childDestinations.filter('.selected');

                orphanResorts = orphanResorts.not('.disabled').not('.selected');

                var activeChildDestinations = childDestinations.length - disabledChildDestinations.length - selectedkids.length - orphanResorts.length;
                if (activeChildDestinations === 1) {
                    that.addRemoveTags($parentcontainer, selectedkids, true);
                } else {
                    that.addDirectTag(name, type, code, hierarchy, code, '', false, $this);
                }
            } else {
                if ($this.hasClass('select-all-destinations')) {
                    that.checkHiddenGrandChildren(code);
                }
                that.addDirectTag(name, type, code, hierarchy, code, '', false, $this);
            }
        },
        checkHiddenGrandChildren: function(code) {
            var fValues = that.autosuggest.getFormValues();
            var destinations = (fValues && fValues.searchValues) ? fValues.searchValues : [];
            $.each(destinations, function(i, destination) {
                if (destination.countryCode === code) {
                    that.autosuggest.removeTag('', '', destination.code);
                }
            });
        },
        tagRemoved: function(code) {
            var existingHtml = that.countryContainer.find('.country').find('[data-code = ' + code + ']'),
                closeIcon;
            if (existingHtml.hasClass('country-name-container')) {
                var countryLI = existingHtml.parents('.country');
                closeIcon = countryLI.find('.icon-close-circle');
                countryLI.find('.selected').removeClass('selected');
            } else {
                closeIcon = existingHtml.find('.icon-close-circle');
            }
            if (closeIcon.length > 0) {
                closeIcon.trigger('click');
            } else {
                if (existingHtml.hasClass('selected')) {
                    existingHtml.removeClass('selected');
                    existingHtml.find('.child-name').removeClass('selected');
                }
            }

        },
        removeChildren: function(place) {
            var selectedKids;
            if (place.hasClass('select-all-resorts')) {
                selectedKids = place.closest('.destination').find('.resort-name.selected');
            } else {
                selectedKids = place.closest('.country').find('.child-name.selected');
            }
            $.each(selectedKids, function(i, kid) {
                var parent = $(kid).closest('.child');
                that.autosuggest.removeTag('', '', parent.data('code'));
                $(kid).removeClass('selected');
                parent.removeClass('selected');
            });
        },
        flySpan: function(cb) {
            var curHTML = $.trim(cb.text()),
                spanClone = '<span class="flyingspan">' + curHTML + '</span>',
                offsetTopField = $('#field-destination-picker').offset().top,
                offsetLeftField = $('#field-destination-picker').offset().left,
                offsetTopEle = cb.parent().offset().top,
                offsetLeftEle = cb.parent().offset().left,
                reqOffsetTop = offsetTopField - offsetTopEle,
                reqOffsetLeft = offsetLeftField - offsetLeftEle;

            $(spanClone).appendTo($('body')).css({
                top: offsetTopEle,
                left: offsetLeftEle
            }).animate({
                top: offsetTopField + 15 + 'px',
                left: offsetLeftField + 'px'
            }, that.animationSpeed, function() {
                $('.flyingspan').fadeOut(that.animationSpeed, function() {
                    $('.flyingspan').remove();
                    that.controller.scrollTillSearchPanel();
                });
            });
        },
        handleSelectionRemoval: function(event) {
            event.stopPropagation();
            var $this = $(this),
                code = '';
            if ($this.hasClass('remove-country')) {
                var countryContainer = $this.parents('.country'),
                    currentDestinationParent = $this.parents('.select-all-destinations'),
                    destinations = countryContainer.find('.country-destinations'),
                    selectedDestinationChilds = destinations.find('.child-name.selected'),
                    countryNameCont = countryContainer.find('.country-name');

                code = countryContainer.find('.country-name-container').data('code');

                that.autosuggest.removeTag('', '', code);
                currentDestinationParent.removeClass('selected');
                countryNameCont.removeClass('selected');
                $.each(selectedDestinationChilds, function(i, currentChild) {
                    $(currentChild).removeClass('selected');
                    $(currentChild).parent().removeClass('selected');
                });

            } else if ($this.hasClass('remove-destination')) {
                var destinationContainer = $this.parents('.child.destination'),
                    destinationLabel = destinationContainer.find('.child-name.destination'),
                    currentResortParent = $this.parents('.select-all-resorts'),
                    resorts = currentResortParent.parents('.resorts-container'),
                    selectedResortChilds = resorts.find('.resort-name.selected'),
                    parentCountryContainer = destinationContainer.parents('.country'),
                    parentCountry = parentCountryContainer.find('.country-name'),
                    isParentCountrySelected = parentCountry.hasClass('selected'),
                    allDestinationChild = parentCountryContainer.find('.select-all-destinations'),
                    selectedDestinationSiblings = parentCountryContainer.find('.country-destinations').find('> .child.selected');

                code = destinationContainer.data('code');
                if (isParentCountrySelected) {
                    parentCountry.removeClass('selected');
                    allDestinationChild.removeClass('selected');
                    that.addRemoveTags(parentCountry, selectedDestinationSiblings, false, code);
                } else {
                    that.autosuggest.removeTag('', '', code);
                }
                currentResortParent.removeClass('selected');
                destinationContainer.removeClass('selected');
                destinationLabel.removeClass('selected');
                $.each(selectedResortChilds, function(i, currentChild) {
                    $(currentChild).removeClass('selected');
                });

            } else if ($this.hasClass('remove-leaf')) {
                var $parent = $this.parents('.child.resort'),
                    $immediateParent = $this.parents('.child-name'),
                    $parentDestination = $this.parents('.child.destination'),
                    $parentCountry = $parent.parents('.country').find('.country-name'),
                    $parentDestinationLabel = $parentDestination.find('.child-name.destination'),
                    siblings = $parent.siblings(':not(.select-label)'),
                    selectedSiblings = siblings.filter('.selected'),
                    isCountrySelected = $parentCountry.hasClass('selected'),
                    isDestinationSelected = $parentDestination.hasClass('selected'),
                    allCountryChild = $parent.parents('.country').find('.select-all-destinations'),
                    allDestinationChildLabel = $parentDestination.find('.select-all-resorts'),
                    parentDestinationCode = $parentDestination.data('code'),
                    selectedParentCountryDestSiblings;
                code = $parent.data('code');

                $immediateParent.removeClass('selected');
                $immediateParent.closest('.child').removeClass('selected');
                selectedParentCountryDestSiblings = $parent.parents('.country').find('.country-destinations').find('> .child.selected');

                if (isCountrySelected && isDestinationSelected) {
                    $parentCountry.removeClass('selected');
                    allCountryChild.removeClass('selected');
                    $parentDestination.removeClass('selected');
                    allDestinationChildLabel.removeClass('selected');
                    $parentDestinationLabel.removeClass('selected');
                    that.addRemoveTags($parentDestination, selectedSiblings, false);
                    that.addRemoveTags($parentCountry, selectedParentCountryDestSiblings, false, parentDestinationCode);
                } else if (isCountrySelected) {
                    $parentCountry.removeClass('selected');
                    allCountryChild.removeClass('selected');
                    that.addRemoveTags($parentCountry, selectedParentCountryDestSiblings, false, code);
                } else if (isDestinationSelected) {
                    $parentDestination.removeClass('selected');
                    allDestinationChildLabel.removeClass('selected');
                    $parentDestinationLabel.removeClass('selected');
                    that.addRemoveTags($parentDestination, selectedSiblings, false);
                } else {
                    that.autosuggest.removeTag('', '', code);
                }
            }
        },
        handleKeyNavigation: function(event) {
            if (event.keyCode !== 38 && event.keyCode !== 40 && event.keyCode !== 13) {
                return true;
            }
            var $this = $(this),
                activeListItem = $this.find('.active'),
                activeItemParent = activeListItem.parent(),
                activeItemGrandParent = activeItemParent.parent().parent(),
                greatGrandParent = activeItemGrandParent.parent().parent(),
                isCountry = activeItemParent.hasClass('country'),
                isDestination = activeItemParent.hasClass('child');

            if (!TUIUtil.isElementVisibleOnScreen(activeListItem)) {
                return true;
            }
            event.preventDefault();
            if (event.keyCode === 40) {
                that.handleDownKey($this, activeListItem, activeItemParent, activeItemGrandParent, greatGrandParent, isCountry);
            } else if (event.keyCode === 38) {
                that.handleUpKey($this, activeListItem, activeItemParent, activeItemGrandParent, isCountry);
            } else if (event.keyCode === 13) {
                that.handleEnterKey(activeListItem);
            }
        },
        handleDownKey: function($this, activeListItem, activeItemParent, activeItemGrandParent, greatGrandParent, isCountry) {
            if (activeListItem.length) {
                var nextParent, nextActiveItem;
                activeListItem.removeClass('active');
                if (isCountry) {
                    nextParent = activeItemParent.nextAll().find('.country-name').not('.disabled').first();
                    if (!nextParent.length) {
                        nextParent = activeItemGrandParent.nextAll().find('.country-name').not('.disabled').first();
                    }
                    if (activeListItem.hasClass('open')) {
                        nextActiveItem = activeItemParent.find('.child-name').not('.disabled').first();
                        if (!nextActiveItem.length && nextParent.length) {
                            nextActiveItem = nextParent;
                        } else if (!nextActiveItem.length && !nextParent.length) {
                            nextActiveItem = activeListItem;
                        }
                    } else {
                        nextActiveItem = nextParent;
                        if (!nextParent.length) {
                            nextActiveItem = activeListItem;
                        }
                    }
                    nextActiveItem.addClass('active');
                } else {
                    nextActiveItem = activeItemParent.nextAll().find('.child-name').not('.disabled').first();
                    if (activeListItem.hasClass('open')) {
                        var nextChild = activeItemParent.find('.child-name').not('.disabled').not('.destination').first();
                        if (!nextChild.length && nextActiveItem.length) {
                            nextChild = nextActiveItem;
                        } else if (!nextChild.length && !nextActiveItem.length) {
                            nextChild = activeItemGrandParent.nextAll().find('.country-name').not('.disabled').first();
                            if (!nextChild.length) {
                                nextChild = greatGrandParent.nextAll().find('.country-name').not('.disabled').first();
                                if (!nextChild.length) {
                                    nextChild = activeListItem;
                                }
                            }
                            nextActiveItem = nextChild;
                        }
                        nextActiveItem = nextChild;
                    } else if (!nextActiveItem.length && !activeListItem.hasClass('open')) { // last-child
                        if (activeItemGrandParent.hasClass('country')) {
                            nextParent = activeItemGrandParent.nextAll().find('.country-name').not('.disabled');
                            nextActiveItem = nextParent.first();
                            if (!nextParent.length) {
                                nextParent = greatGrandParent.nextAll().find('.country-name').not('.disabled');
                                nextActiveItem = nextParent.first();
                                if (!nextParent.length) {
                                    nextActiveItem = activeListItem;
                                }
                            }
                        } else {
                            if (!activeItemGrandParent.nextAll().not('.disabled').length) {
                                var nextGrandCountry = greatGrandParent.nextAll().find('.country-name').not('.disabled');
                                if (!nextGrandCountry.length) {
                                    nextGrandCountry = greatGrandParent.parent().parent().nextAll().find('.country-name').not('.disabled');
                                    if (!nextGrandCountry.length) {
                                        nextActiveItem = activeListItem;
                                    } else {
                                        nextActiveItem = nextGrandCountry.first();
                                    }
                                } else {
                                    nextActiveItem = nextGrandCountry.first();
                                }
                            } else {
                                nextActiveItem = activeItemGrandParent.nextAll().find('.child-name').not('.disabled').first();
                            }
                        }
                    }
                    nextActiveItem.addClass('active');
                }
                if (!TUIUtil.isElementVisibleOnScreen(nextActiveItem)) {
                    if (nextActiveItem.hasClass('resort-name')) {
                        $(window).scrollTop(nextActiveItem.parents('.destination').offset().top);
                    } else {
                        $(window).scrollTop(nextActiveItem.parents('.country').offset().top);
                    }
                }
            }
        },
        handleUpKey: function($this, activeListItem, activeItemParent, activeItemGrandParent, isCountry) {
            if (activeListItem.length) {
                var prevParent, prevActiveItem, updatedActiveItem;
                activeListItem.removeClass('active');
                if (isCountry) {
                    prevParent = activeItemParent.prevAll().find('.country-name').not('.disabled').last();
                    if (prevParent.hasClass('open')) {
                        prevActiveItem = prevParent.parent().find('.child-name').not('.disabled').last();
                        if (!prevActiveItem.length) {
                            prevActiveItem = prevParent;
                        }
                    } else {
                        prevActiveItem = prevParent;
                        if (!prevParent.length) {
                            prevActiveItem = activeItemGrandParent.prevAll().find('.country-name').not('.disabled').last();
                            if (!prevActiveItem.length) {
                                prevActiveItem = activeListItem;
                            } else if (prevActiveItem.length && prevActiveItem.hasClass('open')) {
                                prevActiveItem = prevActiveItem.siblings().find('.child-name').not('.disabled').last();
                            }
                        }
                    }
                    prevActiveItem.addClass('active');
                    updatedActiveItem = prevActiveItem;
                } else {
                    prevParent = activeItemParent.prevAll().find('.child-name').not('.disabled').last();
                    if (!activeItemParent.prevAll().length) { // first-child
                        if (activeItemGrandParent.hasClass('country')) {
                            prevParent = activeItemGrandParent.find('.country-name');
                        } else {
                            prevParent = activeItemGrandParent.find('.open');
                        }
                    }
                    prevParent.addClass('active');
                    updatedActiveItem = prevParent;
                }
                if (!TUIUtil.isElementVisibleOnScreen(updatedActiveItem)) {
                    if (updatedActiveItem.hasClass('resort-name')) {
                        $(window).scrollTop(updatedActiveItem.parents('.destination').offset().top);
                    } else {
                        $(window).scrollTop(updatedActiveItem.parents('.country').offset().top);
                    }
                }
            }
        },
        handleEnterKey: function(activeListItem) {
            var closeIcon = activeListItem.find('.icon-close-circle');
            if (activeListItem.length) {
                if (activeListItem.hasClass('selected') && closeIcon.length) {
                    activeListItem.find('.icon-close-circle').trigger('click');
                } else {
                    activeListItem.trigger('click');
                }
            }
        }
    };
    $.extend(DestinationBrowseList.prototype, methods);

    return DestinationBrowseList;
});

/*! http://mths.be/placeholder v2.0.8 by @mathias */
;
(function(window, document, $) {

    // Opera Mini v7 doesnt support placeholder although its DOM seems to indicate so
    var isOperaMini = Object.prototype.toString.call(window.operamini) == '[object OperaMini]';
    var isInputSupported = 'placeholder' in document.createElement('input') && !isOperaMini;
    var isTextareaSupported = 'placeholder' in document.createElement('textarea') && !isOperaMini;
    var prototype = $.fn;
    var valHooks = $.valHooks;
    var propHooks = $.propHooks;
    var hooks;
    var placeholder;

    if (isInputSupported && isTextareaSupported) {

        placeholder = prototype.placeholder = function() {
            return this;
        };

        placeholder.input = placeholder.textarea = true;

    } else {

        placeholder = prototype.placeholder = function() {
            var $this = this;
            $this
                .filter((isInputSupported ? 'textarea' : ':input') + '[placeholder]')
                .not('.placeholder')
                .bind({
                    'focus.placeholder': clearPlaceholder,
                    'blur.placeholder': setPlaceholder
                })
                .data('placeholder-enabled', true)
                .trigger('blur.placeholder');
            return $this;
        };

        placeholder.input = isInputSupported;
        placeholder.textarea = isTextareaSupported;

        hooks = {
            'get': function(element) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value;
                }

                return $element.data('placeholder-enabled') && $element.hasClass('placeholder') ? '' : element.value;
            },
            'set': function(element, value) {
                var $element = $(element);

                var $passwordInput = $element.data('placeholder-password');
                if ($passwordInput) {
                    return $passwordInput[0].value = value;
                }

                if (!$element.data('placeholder-enabled')) {
                    return element.value = value;
                }
                if (value == '') {
                    element.value = value;
                    // Issue #56: Setting the placeholder causes problems if the element continues to have focus.
                    if (element != safeActiveElement()) {
                        // We can't use `triggerHandler` here because of dummy text/password inputs :(
                        setPlaceholder.call(element);
                    }
                } else if ($element.hasClass('placeholder')) {
                    clearPlaceholder.call(element, true, value) || (element.value = value);
                } else {
                    element.value = value;
                }
                // `set` can not return `undefined`; see http://jsapi.info/jquery/1.7.1/val#L2363
                return $element;
            }
        };

        if (!isInputSupported) {
            valHooks.input = hooks;
            propHooks.value = hooks;
        }
        if (!isTextareaSupported) {
            valHooks.textarea = hooks;
            propHooks.value = hooks;
        }

        $(function() {
            // Look for forms
            $(document).delegate('form', 'submit.placeholder', function() {
                // Clear the placeholder values so they don't get submitted
                var $inputs = $('.placeholder', this).each(clearPlaceholder);
                setTimeout(function() {
                    $inputs.each(setPlaceholder);
                }, 10);
            });
        });

        // Clear placeholder values upon page reload
        $(window).bind('beforeunload.placeholder', function() {
            $('.placeholder').each(function() {
                this.value = '';
            });
        });

    }

    function args(elem) {
        // Return an object of element attributes
        var newAttrs = {};
        var rinlinejQuery = /^jQuery\d+$/;
        $.each(elem.attributes, function(i, attr) {
            if (attr.specified && !rinlinejQuery.test(attr.name)) {
                newAttrs[attr.name] = attr.value;
            }
        });
        return newAttrs;
    }

    function clearPlaceholder(event, value) {
        var input = this;
        var $input = $(input);
        if (input.value == $input.attr('placeholder') && $input.hasClass('placeholder')) {
            if ($input.data('placeholder-password')) {
                $input = $input.hide().next().show().attr('id', $input.removeAttr('id').data('placeholder-id'));
                // If `clearPlaceholder` was called from `$.valHooks.input.set`
                if (event === true) {
                    return $input[0].value = value;
                }
                $input.focus();
            } else {
                input.value = '';
                $input.removeClass('placeholder');
                input == safeActiveElement() && input.select();
            }
        }
    }

    function setPlaceholder() {
        var $replacement;
        var input = this;
        var $input = $(input);
        var id = this.id;
        if (input.value == '') {
            if (input.type == 'password') {
                if (!$input.data('placeholder-textinput')) {
                    try {
                        $replacement = $input.clone().attr({
                            'type': 'text'
                        });
                    } catch (e) {
                        $replacement = $('<input>').attr($.extend(args(this), {
                            'type': 'text'
                        }));
                    }
                    $replacement
                        .removeAttr('name')
                        .data({
                            'placeholder-password': $input,
                            'placeholder-id': id
                        })
                        .bind('focus.placeholder', clearPlaceholder);
                    $input
                        .data({
                            'placeholder-textinput': $replacement,
                            'placeholder-id': id
                        })
                        .before($replacement);
                }
                $input = $input.removeAttr('id').hide().prev().attr('id', id).show();
                // Note: `$input[0] != input` now!
            }
            $input.addClass('placeholder');
            $input[0].value = $input.attr('placeholder');
        } else {
            $input.removeClass('placeholder');
        }
    }

    function safeActiveElement() {
        // Avoid IE9 `document.activeElement` of death
        // https://github.com/mathiasbynens/jquery-placeholder/pull/99
        try {
            return document.activeElement;
        } catch (exception) {}
    }

}(this, document, jQuery));
define("vendor/placeholder.min", function() {});

/**
 * Utility Class having some utility methods which are independent of any functionality
 * and can be accessed from anywhere .
 * @param  {[type]} $            [description]
 * @return {[type]}              [description]
 */
define('TUIUtil', ['jquery', 'vendor/placeholder.min'], function($) {

    window.TUIUtil = {};
    TUIUtil.init = function() {};
    TUIUtil.isCookieDisabled = false;
    TUIUtil.isWindowmobile = navigator.userAgent.match(/iemobile/i);
    var msie = window.navigator.userAgent.indexOf('MSIE');
    var searchPanel = $('#search-panel');

    var checkCookie = function() {
        var cookieEnabled = (navigator.cookieEnabled) ? true : false;
        if (typeof navigator.cookieEnabled === 'undefined' && !cookieEnabled) {
            document.cookie = 'testcookie';
            cookieEnabled = (document.cookie.indexOf('testcookie') !== -1) ? true : false;
        }
        return (cookieEnabled) ? true : false;
    };

    // within a window load, dom ready or something like that place your:
    if (checkCookie()) {
        TUIUtil.isCookieDisabled = false;
    } else {
        TUIUtil.isCookieDisabled = true;
    }

    function returnTextLength(fieldWidth, reduceBy) {
        if (typeof fieldWidth === 'string' && fieldWidth.indexOf('px')) {
            fieldWidth = fieldWidth.split('px')[0];
        }
        var ratio = 13 / 104;
        var textLength = fieldWidth * ratio;
        textLength = Math.floor(textLength);
        if (reduceBy) {
            textLength -= reduceBy;
        }
        return textLength;
    }

    TUIUtil.trimText = function(text, field, count) {
        var reduceBy;
        var newHtml;
        if (field && text) {
            if (count) {
                newHtml = $('<ul class="tags"><li><span>' + text + '+' + count + '</span><span class="icon-close-circle"></li></ul>')
                    .css({
                        'visibility': 'hidden',
                        'white-space': 'nowrap'
                    })
                    .appendTo(field);
                reduceBy = 8;
            } else {
                newHtml = $('<ul class="tags"><li><span>' + text + '</span><span class="icon-close-circle"></li></ul>')
                    .css({
                        'visibility': 'hidden',
                        'white-space': 'nowrap'
                    })
                    .appendTo(field);
                reduceBy = 6;
            }

            var newHtmlWidth = newHtml.find('li').width(),
                fieldWidth = field.width(),
                iconWidth = field.find('.icon-close-circle').width();

            if (newHtmlWidth > (fieldWidth - iconWidth)) {
                text = text.substring(0, returnTextLength(fieldWidth, reduceBy));
                text = text + '...';
            }
            newHtml.remove();
        }
        return text;
    };

    TUIUtil.placeHolder = function() {
        $('input, textarea').placeholder();
    };
    /**
     * Check if jquery element is visible in viewport
     * @param  {[type]}  elem [description]
     * @return {Boolean}      [description]
     */
    TUIUtil.isElementVisibleOnScreen = function(elem, fromCarousel) {
        var $elem = $(elem);
        var $window = $(window);
        var delta = 10;

        var docViewTop = $window.scrollTop();
        var docViewBottom = docViewTop + $window.height() + delta;

        var elemTop = $elem.offset().top;
        var elemBottom = elemTop + $elem.height();
        if (fromCarousel) {
            return (elemTop <= docViewBottom);
        } else {
            return ((elemBottom <= docViewBottom) && (elemTop >= docViewTop));
        }
    };

    TUIUtil.setPosition = function(ele, value, originalMax) {
        var pos = parseInt(ele.parent().css('left'), 10),
            elemParentWidth = parseInt(ele.parent().parent().width(), 10),
            posPercent = pos * 100 / elemParentWidth,
            elemWidth = ele.width(),
            rmd = (1 - ele.parent().width() / elemWidth);
        if (elemWidth > 0 && elemWidth / ele.parent().width() >= 2) {
            rmd = 1;
        }
        ele.css('left', -posPercent * rmd + '%');

        if (elemWidth === 0) {
            ele.css({
                'right': '0',
                'left': 'auto'
            }); // default 0 from right in case of mobile
        }
        if (value && originalMax && value === originalMax) {
            var handlesParent = ele.closest('.ui-slider-handle').css('left', '100%');
            handlesParent.siblings('.ui-slider-range').width('100%');
        }
    };
    /**
     * Logger Function, can log json objects and arrays as well.
     * @param  {[type]} text [description]
     * @return {[type]}      [description]
     */
    TUIUtil.printLog = function(text) {
        if (window.console && console.log && (tuiConfig.isDevMode || window.location.search.indexOf('jsdebug') !== -1)) {
            var d = new Date(),
                timestring = '';
            timestring = d.getHours() + '-' + d.getMinutes() + '-' + d.getSeconds();
            var finalString = 'Log Time : ' + timestring + ' : ' + text;
            if (typeof text !== 'string') {
                console.log('Log Time for log below:' + timestring);
                finalString = text;
            }
            console.log(finalString);
        }
    };

    /**
     * Ajax request based on the ajax param and not form dependent
     * ajaxOptions can be :
     * 		type : GET or POST
     *  	dataType : application/json or html
     *  	successCallback : success callback
     *  	error : errorCallback
     *  	showLoader : true or false
     *  	showLoaderAt : The html element where to show the lder
     */
    TUIUtil.ajaxPool = [];
    TUIUtil.genericAjaxRequest = function(ajaxOptions) {

        if (TUIUtil.ajaxPool.length) {
            $.each(TUIUtil.ajaxPool, function(i, v) {
                this.abort();
            });
            TUIUtil.ajaxPool.length = 0;
        }
        var defaultOptions = {
            type: 'GET',
            cache: false,
            // dataType:'application/json',
            error: function(XMLHttpRequest, textStatus, errorThrown) {
                if (textStatus !== 'abort') {
                    TUIUtil.printLog('Ajax Call failed :' + textStatus + 'XHR: ' + XMLHttpRequest + ', errorThrown:' + errorThrown);
                }
            }
        };

        if (ajaxOptions.url === undefined || ajaxOptions.url === '') {
            return false;
        }

        // Override beforeSend for handling the loader
        if (ajaxOptions.showLoader) {
            if (!ajaxOptions.beforeSend) {
                ajaxOptions.beforeSend = function() {
                    TUIUtil.showLoader(ajaxOptions.showLoaderAt);
                    if (!ajaxOptions.loaderClass) {
                        ajaxOptions.showLoaderAt.find('.pre-loader.custom-loader').css({
                            width: '100%',
                            height: '100%',
                            position: 'absolute',
                            'z-index': '999'
                        });
                    } else {
                        ajaxOptions.showLoaderAt.find('.pre-loader.custom-loader').addClass(ajaxOptions.loaderClass);
                    }
                };
            }
        }
        // Override Success Callback for handling the loader

        if (ajaxOptions.successCallback) {
            ajaxOptions.success = function(data) {
                if (data && typeof data === 'string') {
                    data = $.trim(data);
                }
                if (ajaxOptions.showLoader === true) {
                    TUIUtil.hideLoader(ajaxOptions.showLoaderAt);
                }
                TUIUtil.requesting = false;
                ajaxOptions.successCallback(data);
            };
        }
        var finalAjaxOptions = {};

        $.extend(finalAjaxOptions, defaultOptions, ajaxOptions);

        TUIUtil.requesting = true;
        var xhrObj = $.ajax(finalAjaxOptions);
        if (!finalAjaxOptions.dontPool) {
            TUIUtil.ajaxPool.push(xhrObj);
        }
        return xhrObj; // newly added returing the ajax object (deferred)
    };

    /**
     * Shows the overlay loader
     * @eLocation {object} optional element that contains loader (default is body)
     */
    TUIUtil.showLoader = function(eLocation) {
        /* create loading element */
        var eLoader = $('<div></div>').addClass('pre-loader');

        /* deterime where to place element */
        if (typeof eLocation !== 'undefined') {
            /* make a custom placement */
            eLoader.addClass('custom-loader');

            var sLocation = $(eLocation).attr('data-loader-location');
            if (sLocation) {
                $('#' + sLocation).prepend(eLoader);
            } else {
                $(eLocation).prepend(eLoader);
            }
        } else {
            /* if no placement specified, default to body*/
            eLoader.appendTo('body');
        }
    };
    TUIUtil.updateCurrencyParams = function() {
        if (typeof hotelData !== 'undefined' && TUIUtil.isSearchResultPage()) {
            if (hotelData.currencySymbol) {
                $('body').data('currency', hotelData.currencySymbol);
            }
            if (hotelData.groupingSeparator) {
                $('body').data('currencyseparator', hotelData.groupingSeparator);
                separator = hotelData.groupingSeparator;
            }
        }
    };

    TUIUtil.isSearchResultPage = function() {
        return $('#result-page-wrapper').length;
    };
    /**
     * Removes the overlay loader
     * @eLocation {object} optional element that contains loader (default is body)
     */
    TUIUtil.hideLoader = function(eLocation) {
        var loader;
        if (typeof eLocation !== 'undefined') {
            var sLocation = $(eLocation).attr('data-loader-location');
            if (sLocation) {
                loader = $('#' + sLocation).find('.pre-loader');
            } else {
                loader = $(eLocation).find('.pre-loader');
            }
        } else {
            loader = $('div.pre-loader');
        }
        if (loader.length > 0) {
            loader.remove();
        }
    };
    /**
     * Returns the  breakpoint name based
     * on current screen width
     * @return {[type]} [description]
     */
    TUIUtil.getCurrentBreakPoint = function() {
        var windowWidth = $(window).width(),
            curBrkPnt = 'lg';
        if (windowWidth >= 1200) {
            curBrkPnt = 'lg';
        } else if (windowWidth >= 992) {
            curBrkPnt = 'md';
        } else if (windowWidth >= 768) {
            curBrkPnt = 'sm';
        } else { // windowWidth ~ 480
            curBrkPnt = 'xs';
        }
        return curBrkPnt;
    };

    TUIUtil.detectDeviceType = function() {
        var type = '';
        if (navigator.userAgent.match(/Android/i)) {
            type = 'Android';
            searchPanel.addClass('android');
        } else if (navigator.userAgent.match(/webOS/i)) {
            type = 'webOS';
            searchPanel.addClass('webOs');
        } else if (navigator.userAgent.match(/iPhone/i)) {
            type = 'iPhone';
            searchPanel.addClass('iPhone');
        } else if (navigator.userAgent.match(/iPad/i)) {
            type = 'iPad';
            searchPanel.addClass('iPad');
        } else if (navigator.userAgent.match(/iPod/i)) {
            type = 'iPod';
            searchPanel.addClass('iPod');
        } else if (navigator.userAgent.match(/BlackBerry/i)) {
            type = 'BlackBerry';
            searchPanel.addClass('blackBerry');
        } else if (navigator.userAgent.match(/Windows Phone/i)) {
            type = 'Windows Phone';
            searchPanel.addClass('windowsPhone');
        }
        return type;
    };

    TUIUtil.detectOrientaion = function() {
        var orientaion = '';
        switch (window.orientation) {
            case -90:
            case 90:
                {
                    orientaion = 'landscape';
                    break;
                }
            default:
                {
                    orientaion = 'portrait';
                    break;
                }
        }
        return orientaion;
    };

    TUIUtil.isTouchDevice = function() {
        return (('ontouchstart' in window) || (navigator.MaxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
    };

    TUIUtil.deviceType = TUIUtil.detectDeviceType();

    /**
     * Detect Mobile
     */
    TUIUtil.detectmob = function() {
        var windowWidth = $(window).width();
        // windowHeight = $(window).height();
        if (windowWidth < 768) {
            return true;
        } else {
            return false;
        }
    };

    /**
     * Utility Method to convert a string  to Date
     * two string formats supported :
     *                       DD/MM/YYYY
     *                       DD/MM/YY
     * @param  {[type]} ddmmyyyString [description]
     * @return {[type]}               [description]
     */
    TUIUtil.dateConverter = function(ddmmyyyString) {
        if (!ddmmyyyString || ddmmyyyString.split('/').length !== 3) {
            return;
        }
        var parts = ddmmyyyString.split('/'),
            date = new Date();

        parts[2] = (parts[2].indexOf('20')) === 0 ? parts[2] : '20' + parts[2];
        date = new Date(parts[2], parts[1] - 1, parts[0]);

        return date;
    };
    /**
     * Date string in dd/mm/yyyy format
     * @param  {[type]} dateString [description]
     * @return {[type]}            [description]
     */
    TUIUtil.dateDayConverter = function(dateString) {
        var calendarLabel = ($('#searchWhen').length) ? $('#searchWhen').data('labels') : null,
            tokens,
            dateStr,
            date,
            month,
            dayName,
            formatted = dateString; // fallback

        if (dateString) {
            tokens = dateString.split('/');
            dateStr = tokens.reverse().join('/');
            date = new Date(dateStr);

            if (date && calendarLabel) {
                var dayNumber = date.getDay();
                if (dayNumber === 7) {
                    dayNumber = 0;
                }
                dayName = calendarLabel.dayNamesShort[dayNumber];
            }
            if (tokens.length === 3) {
                month = tokens[1] * 1;
                formatted = dateStr;
            }
            if (dayName) {
                formatted = dayName + ' ' + formatted;
            }
        }
        return formatted;
    };
    /**
     * Currently support just adding a spinner to an element.
     * Can be extended to show modal overlay
     * @param  {[type]} element        [description]
     * @param  {[type]} remove         [description]
     * @param  {[type]} loaderSelector [description]
     * @return {[type]}                [description]
     */
    TUIUtil.toggleLoader = function(element, remove, loaderSelector) {
        if (remove) {
            if (!loaderSelector) {
                loaderSelector = '.loader-container';
            }
            element.find(loaderSelector).remove();
        } else {
            var additionalClass = '';

            if (element.prop('tagName') === 'BODY') {
                additionalClass = 'page';
            }
            element.append('<div class="loader-container ' + additionalClass + '"><div class="loader"></div></div>');
        }

    };

    TUIUtil.showInlineMessage = function(element, opts, append) {
        var finalOpts = $.extend({}, {
            message: '',
            type: 'error',
            removeOthers: true,
            cssClass: '',
            highlightElement: [],
            arrow: true,
            closeIcon: false,
            container: $(body),
            top: null,
            left: null
        }, opts);

        var tooltip = $(getTooltipTemplate(finalOpts.message, true, finalOpts.arrow, finalOpts.closeIcon));

        tooltip.addClass(finalOpts.cssClass);
        if (finalOpts.removeOthers) {
            finalOpts.container.find('.tui-tooltip-inline').remove();
            finalOpts.container.find('.tui-tooltip-error').removeClass('tui-tooltip-error');
        }
        if (finalOpts.type === 'error' && finalOpts.highlightElement.length) {
            finalOpts.highlightElement.addClass('tui-tooltip-error');
        }
        if (append) {
            element.append(tooltip);
        } else {
            if (element.parents('article').hasClass('all-destinations')) {
                element.next('label').after(tooltip);
            } else {
                element.after(tooltip);
            }
        }

        if (finalOpts.closeTooltipCallback) {
            tooltip.on('click', '.icon-close-circle', function(e) {
                e.preventDefault();
                e.stopPropagation();
                TUIUtil.closeTooltip(finalOpts.container, finalOpts.closeTooltipCallback);
            });
        }
    };

    var body = $('body');
    /**
     * Tooltip widget
     * @param  {[type]} element [description]
     * @param  {[type]} opts    [description]
     * @return {[type]}         [description]
     */
    TUIUtil.tooltip = function(element, opts) {
        var finalOpts = $.extend({}, {
            message: '',
            type: 'error',
            removeOthers: true,
            cssClass: '',
            highlightElement: [],
            container: $(body),
            arrow: true,
            closeIcon: false,
            top: null,
            left: null
        }, opts);

        var tooltip = $(getTooltipTemplate(finalOpts.message, false, finalOpts.arrow, finalOpts.closeIcon));

        tooltip.addClass(finalOpts.cssClass);
        if (finalOpts.removeOthers) {
            finalOpts.container.find('.tui-tooltip').remove();
            finalOpts.container.find('.tui-tooltip-error').removeClass('tui-tooltip-error');
        }
        if (finalOpts.type === 'error' && finalOpts.highlightElement.length) {
            finalOpts.highlightElement.addClass('tui-tooltip-error');
        }

        tooltip.appendTo(finalOpts.container).hide();
        if (finalOpts.closeTooltipCallback) {
            finalOpts.container.on('click', '.icon-close-circle', function() {
                TUIUtil.closeTooltip(finalOpts.container, finalOpts.closeTooltipCallback);
            });
        }
        setTimeout(function() {
            var offset = element.offset();
            if (!finalOpts.top) {
                finalOpts.top = offset.top + element.height() + 15;

            }
            if (!finalOpts.left) {
                finalOpts.left = offset.left;
            }
            tooltip.css({
                left: finalOpts.left,
                top: finalOpts.top
            }).show();
        }, 100);
    };

    /**
     * close Tooltip widget
     * @param {[type]} element
     * @param {[type]} callback
     */
    TUIUtil.closeTooltip = function(element, callback) {
        element.find('.tui-tooltip-inline,.tui-tooltip').remove();
        element.find('.tui-tooltip-error').removeClass('tui-tooltip-error');
        callback();
    };

    TUIUtil.conceptClasses = ['bluecouples', 'bluestar', 'bluevillage', 'bluevillagefamilylife', 'holidayvillages', 'sensimar', 'magiclife', 'scene', 'sensatori', 'splashworld', 'suneoclub', 'riu'];

    var getTooltipTemplate = function(message, inline, arrow, closeIcon) {
        var mainClass = 'tui-tooltip';
        if (inline) {
            mainClass = 'tui-tooltip-inline';
        }
        var markup = '<div class="' + mainClass + '">';
        if (closeIcon) {
            markup += '<i class="icon-close-circle"></i>';
        }
        markup += '<div class="tooltip-content">' +
            message +
            '</div>' +
            '</div>';

        return markup;
    };
    /**
     * Detect ie 8 or lower browser
     */
    TUIUtil.ie8OrLower = function() {
        var ie8 = $('html').hasClass('lt-ie9');
        if (ie8) {
            return true;
        } else {
            return false;
        }
    };

    TUIUtil.currency = '';
    TUIUtil.getCurrency = function() {
        if (TUIUtil.currency) {
            return TUIUtil.currency;
        } else {
            TUIUtil.currency = $('body').data('currency');
        }
        // Still no currency;
        if (!TUIUtil.currency) {
            TUIUtil.currency = '&euro;';
        }
        return TUIUtil.currency;
    };

    /**
     * Detect modern IE or lower
     */
    TUIUtil.isMordernIE = true;

    (function() {
        TUIUtil.isMordernIE = ($('html').hasClass('lt-ie9') || $('html').hasClass('ie9')) ? false : true;
    })();

    var separator = body.data('currencyseparator') || null;
    /**
     * Currency Formatter
     * @param  {[type]} amount [description]
     * @return {[type]}        [description]
     */
    TUIUtil.formatPrice = function(amount, withCurrency) {

        if (!amount || !separator) {
            return amount;
        }
        amount += '';
        var x = amount.split('.');
        var x1 = x[0];
        var x2 = x.length > 1 ? '.' + x[1] : '';
        var rgx = /(\d+)(\d{3})/;
        while (rgx.test(x1)) {
            x1 = x1.replace(rgx, '$1' + separator + '$2');
        }
        var finalPrice = x1 + x2;
        if (withCurrency) {
            return finalPrice + '' + TUIUtil.getCurrency();
        } else {
            return finalPrice;
        }
    };

    /**
     * Date Formater as DD, MM, YYYY and returned as part of array
     * @startDate  {[date string]}
     * @duration {[number]}
     */
    TUIUtil.getDateChunksArray = function(startDateString, duration) {

        var startDate = TUIUtil.dateConverter(startDateString),
            startDateInMS = Date.parse(startDate),
            oneDayInMS = 24 * 60 * 60 * 1000, // 24 hours in milliseconds
            dateObjArr = [];
        if (startDate) {
            for (var i = 0, sims = startDateInMS; i < duration; i++, sims = sims + oneDayInMS) {
                var dateObj = {};
                startDate = new Date(sims);
                dateObj.date = startDate.getDate();
                dateObj.month = startDate.getMonth();
                dateObj.year = startDate.getYear() + 1900;
                dateObj.day = startDate.getDay();
                dateObj.time = startDate.getTime();
                dateObjArr.push(dateObj);
            }
        }
        return dateObjArr;
    };

    /**
     * return min n max slider value for date range slider
     * @dateObj  {[date obj with day , date, month time in separate attributes]}
     * @monthNamesArr {[localised month name strings array]}
     * @dayNamesArr {[localised day name strings array]}
     * @showDayLabel {[boolean]}whether to show day label in string or not
     */
    TUIUtil.getDateSliderLabels = function(dateObj, monthNamesArr, dayNamesArr, showDayLabel) {
        if (!dateObj) {
            return;
        }
        var dayName = dayNamesArr[dateObj.day],
            monthName = monthNamesArr[dateObj.month],
            date = dateObj.date,
            sliderLabelStr = '';
        if (showDayLabel) {
            sliderLabelStr = dayName + ' ' + date + ' ' + monthName;
        } else {
            sliderLabelStr = date + ' ' + monthName;
        }

        return sliderLabelStr;
    };

    /**
     * Setting background image on desktop/tablet devices & not on mobile/tablet
     */
    TUIUtil.setBackgroundImage = function() {
        var currentSize = TUIUtil.getCurrentBreakPoint(),

            imgURL = $('body').data('bgimageurl');
        if (!imgURL) {
            return;
        }
        if (currentSize === 'lg' || currentSize === 'md' || currentSize === 'sm') {
            $('body').css('background-image', 'url(' + imgURL + ')');
        }
    };

    /**
     * Checking if pure safari (no chrome )
     * @return {Boolean} [description]
     */
    TUIUtil.isSafariBrowser = function() {
        var isSafari = false;
        var ua = navigator.userAgent.toLowerCase();
        if (ua.indexOf('safari') !== -1) {
            if (ua.indexOf('chrome') > -1) {
                isSafari = false;
            } else {
                isSafari = true;
            }
        }
        return isSafari;
    };

    /**
     * Checking device Type
     * @return {Boolean}
     */
    TUIUtil.istabletOrDesktop = function() {
        if (TUIUtil.getCurrentBreakPoint() === 'lg' || TUIUtil.getCurrentBreakPoint() === 'md' || TUIUtil.getCurrentBreakPoint() === 'sm') {
            return true;
        } else {
            return false;
        }
    };

    /**
     * Check if start page contains search panel
     */
    TUIUtil.isStartPageSearchPanel = function() {
        return $('.start-page #search-panel').length ? true : false;

    };

    TUIUtil.isMSIE = function() {

        return msie > 0 ? true : false;
    };
    /**
     * Detect Safari and add class safari-v6 to html tag
     */
    TUIUtil.checkOldSafari = (function() {
        if (navigator.userAgent.indexOf('Safari') > -1) {
            var browserObj = navigator.userAgent,
                windowWidth = $(window).width(),
                browserVersion = browserObj.substring(browserObj.indexOf('Version/') + 8, browserObj.indexOf(' Safari/'));
            browserVersion = parseInt(browserVersion.substring(0, browserVersion.indexOf('.')), 10);
            if (browserVersion <= 6 && windowWidth > 1024) {
                $('html').addClass('safari-v6');
            }
        }
    }());
    /**
     * Adding contains and unique methods to array
     * @param  {[type]} v [description]
     * @return {[type]}   [description]
     */
    Array.prototype.contains = function(v) {
        for (var i = 0; i < this.length; i++) {
            if (this[i] === v) {
                return true;
            }
        }
        return false;
    };

    Array.prototype.unique = function() {
        var arr = [];
        for (var i = 0; i < this.length; i++) {
            if (!arr.contains(this[i])) {
                arr.push(this[i]);
            }
        }
        return arr;
    };

    return TUIUtil;
});


define('text!search-panel/templates/autosuggestion-template-v3.hbs', [], function() {
    return '<div class="txt-right sm-button-done xs-button-done">\n\t<a class="btn-done" href="#"><i class="icon-x"></i></a>\n</div>\n<div class="scroll-panel">\n{{#if  noResultsMessage}}\n\t\t<div id="noResultsFound" class="error-msg">\n\t\t<i class="icon-warning"></i>\n\t\t{{noResultsMessage}}</div>\n{{/if}}\n\n{{#if  validationErrorMessage}}\n\t\t<div class="validation-err-msg error-msg" data-targetPanel="{{validationErrorMessage.validationType}}">\n\n\n\t\t\t<p><i class="icon-info"></i>{{{validationErrorMessage.message}}}</p>\n\n\t\t\t{{#if validationErrorMessage.matchedDestination}}\n\t\t\t\t<p><a id="{{validationErrorMessage.matchedDestination.code}}" data-name="{{validationErrorMessage.matchedDestination.name}}" data-hierarchy="{{validationErrorMessage.matchedDestination.hierarchy}}" data-type="{{validationErrorMessage.matchedDestination.type}}" data-code="{{validationErrorMessage.matchedDestination.code}}" data-countrycode="{{validationErrorMessage.matchedDestination.countryCode}}" class="alternate-link" href="javascript:void(0)"><em>{{validationErrorMessage.alternateLinkText}}</em></a> </p>\n\t\t\t{{/if}}\n\t\t</div>\n{{/if}}\n{{#if autoSuggestResponse}}\n\t\t\t \t{{#each autoSuggestResponse}}\n\t\t\t \t\t\t{{# if this.options}}\n\t\t\t \t\t\t{{# if groupLabel}}\n\t\t\t \t\t\t\t<div class="{{type}}-group search-res-grp-heading">{{groupLabel}}</div>\n\t\t\t \t\t\t{{/if}}\n\t\t\t \t\t\t<ul id="{{type}}_results" class="{{type}}-list search-result-grp {{# unless groupLabel}}add-top-border {{/unless}}">\n\t\t\t \t\t\t\t{{#each options}}\n\t\t\t \t\t\t\t\t<li class="{{type}} {{#if disabled}}disabled{{/if}} {{iconClass}}" data-hierarchy="{{hierarchy}}" data-type="{{type}}" data-code="{{code}}" data-countrycode="{{countryCode}}" id="{{code}}" data-name="{{name}}">\n\t\t\t \t\t\t\t\t\t<em >{{name}}{{#if hierarchy}}, {{hierarchy}}{{/if}}</em>\n\t\t\t \t\t\t\t\t</li>\n\t\t\t \t\t\t\t{{/each}}\n\t\t\t \t\t\t</ul>\n\t\t\t \t\t\t{{/if}}\n\t\t\t \t{{/each}}\n\n{{/if}}\n</div>\n\n\n';
});

/* global window, document, define */
/**
 * SEARCH AUTOSUGGEST
 * @param  {[type]} $                     [description]
 * @param  {[type]} jquerycookie          [description]
 * @param  {[type]} SearchDestination     [description]
 * @param  {[type]} TUIUtil               [description]
 * @param  {[type]} Handlebars            [description]
 * @param  {[type]} template)
 * @param  {[type]} searchPlaceHolderText
 * @param  {[type]} searchResultFlyout
 * @param  {[type]} searchPanelContainer
 * @return {[type]}                       [description]
 */
define('search-panel/search-autosuggest-v3', ['jquery',
        './search-destination-v3',
        'TUIUtil',
        'handlebars',
        'text!./templates/autosuggestion-template-v3.hbs',
        'text!./templates/disabledDestinationMessage.hbs',
        'jqueryCookie'
    ],
    function(jquery, DestinationBrowseList, TUIUtil, Handlebars, template, disabledDestTemplate) {

        function SearchAutoSuggest(ele, opts) {
            this.ele = $('#searchPanel-field-search-redesign'),
                this.opts = $.extend({}, {
                    dataURL: this.ele.data('service')
                }, opts);
            this.data = {};
            this.controller = opts.controller || false;
            this.template = Handlebars.compile(template);
            this.disabledDestTemplate = Handlebars.compile(disabledDestTemplate);
            this.formData = {};
            this.currentAutoSuggestCall = null;
            this.wrapper = $('#searchDestinationsRedesign');
            this.tags = this.wrapper.find('.tagHolder').find('ul.tags');
            this.placeholder = this.wrapper.find('.placeholder-text');
            this.tagCounts = $('.tag-count');
            this.tagScroll = $('.tag-scroll');
            this.searchResults = $('#recentSearchResults');
            this.exampleResults = $('#forExampleResults');
            TUIUtil.placeHolder();
            this.searchInput = searchInput;
            this.isFlyoutOpen = false;
            this.disableDestService = this.wrapper.data('disabledestservice');
            this.labels = searchResultFlyout.data('labels');
            this.destinationWrapper = $('#field-destination-picker');
            this.init();
        }

        // Private Variables
        var searchInput = $('#searchPanel-field-search-redesign'),
            defaultPlaceholderTxt = searchInput.attr('placeholder'),
            searchResultFlyout = $('#searchResultFlyoutRedesign'),
            searchPanelContainer = $('#searchDestinationRedesign').length ? $('#searchDestinationRedesign') : $('body'),
            MORE_TEXT = searchInput.data('morelabel') || '',
            that = [],
            downKeyPressedTimes = 0,
            upKeyPressedTimes = 0,
            noResults = $('#noResultsFound'),
            spinner = $('.autosuggest-spinner'),
            searchIntakeValues = [],
            SEARCH_DELAY = 500, // ms
            MIN_SEARCH_CHARS = searchInput.data('threshold') || 3, // min chars in search input
            MAX_AUTOSUGGESTION = searchInput.data('maxsuggestion') || 5,
            RECENT_SEARCH_COOKIE = 'RecentSearches',
            FOR_EXAMPLE_COOKIE = 'forExampleJSON',
            recentSearchesLabel = searchPanelContainer.find('.field-search').data('recentsearch') || 'Recent Searches',
            forExampleLabel = searchPanelContainer.find('.field-search').data('forexample') || 'For Examples',
            lastAutoSuggestResponse = {},
            methods,
            maxSlots = $('#searchResultFlyoutRedesign').data('totalrecentsandforexamples'),
            typesArr = [],
            isSafari = TUIUtil.isSafariBrowser(),
            typesTempArr = [],
            remainingSlots = 0,
            filteredRS = [],
            filteredFE = [],
            // Private Methods
            _autosuggest,
            _openPanel,
            _showHideSearchInputBox,
            _highlight,
            _typeahead,
            _selectValueOnEnterAndTab,
            _selectMatchedValue,
            _bindEvents,
            _selectValue,
            _showHideFlyout,
            _appendAutoSuggest,
            _tagScroll,
            _addScroll;

        methods = {
            init: function() {
                that = this;
                that.reinitVars();
                that.searchResultFlyout = searchResultFlyout;
                downKeyPressedTimes = 0;
                upKeyPressedTimes = 0;
                this.destinationBrowseList = new DestinationBrowseList($('#searchDestinationRedesign'), {
                    dataURL: that.opts.dataURL,
                    controller: that.controller,
                    autosuggest: that
                });
                // Store selected values in an object starts
                searchIntakeValues = [];
                _bindEvents();
                this.wrapperHeight = this.wrapper.height();

                this.wrapper.on('click', function(e) {
                    var $t = $(this),
                        closeBtns,
                        $target = $(e.target);
                    that.updateDisplay();
                    closeBtns = $t.find('a.icon-close');
                    if (!($('body').hasClass('readonly-search'))) {
                        if (!TUIUtil.isTouchDevice()) {
                            $t.find('.tag-scroll').css({
                                'width': ($t.outerWidth() - 20),
                                'padding-right': '8px'
                            });
                        }
                        $t.addClass('focus');
                    }

                    $(document).on('click.searchDestinationFocus', function(e) {
                        if (!$.contains($t[0], e.target) && !$.contains(searchResultFlyout[0], e.target) && !$t.is(e.target) && !$(e.target).is('.icon-search') && !$(e.target).is('a.icon-close')) {
                            $(document).off('click.searchDestinationFocus');
                            $t.removeClass('tag-scroll-true');
                        }
                    });
                });

                this.controller.ele.on('click', '.destination-flyout a.btn-done', function(e) {
                    e.preventDefault();
                    $(this).parents('.destination-flyout').hide();
                });

                $('.search-inner-wrapper').on('click', '.field-label-container', function(e) {
                    that.destinationWrapper.trigger('click').focus();
                });

                this.controller.ele.on('click', '.destinations-activities', function(e) {
                    var searchHeight = $('#search-panel').height(),
                        panelHeight = searchPanelContainer.height(),
                        searchTop = $('#search-panel').offset().top - $(window).scrollTop(),
                        cssTop = '';
                    if ($('#search-panel').hasClass('fixed') || (searchTop < (parseInt($(window).height() / 2, 10)))) {
                        cssTop = searchHeight + 3;
                    } else {
                        cssTop = -panelHeight - 3;
                    }
                    that.wrapper.parents('.field-search:first').closest('.searchWrapper').find('.destination-flyout').show();
                    searchPanelContainer.css({
                        'top': cssTop
                    });
                    that.isFlyoutOpen = true;
                    e.stopPropagation();
                });

                openAllDestinationFromFlyout();

                $.subscribe('search/destinations/change', $.proxy(that.updateDisplay, that));
                that.destinationWrapper.on('click', '.icon-close-circle', that.removeDestinationTag);
                $.subscribe('breakpointchange', function() {
                    that.wrapperHeight = that.wrapper.height();
                    that.updateDisplay();
                });
            },
            reinitVars: function() {
                searchInput = $('#searchPanel-field-search-redesign');
                that.searchInput = searchInput;
                defaultPlaceholderTxt = searchInput.attr('placeholder');
                searchResultFlyout = $('#searchResultFlyoutRedesign');
                searchPanelContainer = $('#searchDestinationRedesign').length ? $('#searchDestinationRedesign') : $('body'),
                    MORE_TEXT = searchInput.data('morelabel') || '';
                noResults = $('#noResultsFound');
                spinner = $('.autosuggest-spinner');
                MIN_SEARCH_CHARS = searchInput.data('threshold') || 3; // min chars in search input
                MAX_AUTOSUGGESTION = searchInput.data('maxsuggestion') || 5;
                recentSearchesLabel = searchPanelContainer.find('.field-search').data('recentsearch') || 'Recent Searches';
                forExampleLabel = searchPanelContainer.find('.field-search').data('forexample') || 'For Examples';
                maxSlots = $('#searchResultFlyoutRedesign').data('totalrecentsandforexamples');
            },
            get: function() {
                var postJSON = that.controller.getFormValues();
                postJSON.searchQuery = searchInput.val();
                return TUIUtil.genericAjaxRequest({
                    url: that.opts.dataURL,
                    cache: false,
                    type: 'post',
                    dataType: 'json',
                    contentType: 'application/json',
                    data: JSON.stringify(postJSON)
                });
            },
            showHideMobilePickerField: function(show) {
                if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                    return;
                }
                if (show) {
                    that.destinationWrapper.show();
                } else {
                    that.destinationWrapper.hide();
                }
            },
            getFormValues: function(specialType) {
                // method is to be called via a controller and doesn't accept any arguments
                // the searchIntakeValues sould be stored on the instance of this Class (this / t depending on scope).searchIntakeValues =

                searchIntakeValues = this.trimSearchValues(searchIntakeValues);
                this.formData = {
                    'searchValues': (specialType && specialType === 'SEARCH_PIPE') ? searchIntakeValues : _convertArrayToJSON(searchIntakeValues)
                };
                return this.formData;
            },
            showSpinner: function(show) {
                if (show) {
                    searchResultFlyout.find('.search-result-panel').addClass('hidden');
                    spinner.removeClass('hidden');
                } else {
                    spinner.addClass('hidden');
                    searchResultFlyout.find('.search-result-panel').removeClass('hidden');
                }
            },
            trimSearchValues: function(searchIntakeValues) {
                var trimmedArr = [];
                $.each(searchIntakeValues, function(i, item) {
                    var tokens = item.split('|');
                    var tempArr = [tokens[0], tokens[1], tokens[2], '', tokens[4]];
                    trimmedArr.push(tempArr.join('|'));
                });
                return trimmedArr;
            },
            getSelectedInputs: function() {
                return searchIntakeValues;
            },
            checkTagExists: function(code) {
                var tagExists = false,
                    tagCount = searchIntakeValues.length,
                    i;
                // check if the new tags code has allready been added
                for (i = 0; i < tagCount; i++) {
                    var tokens = searchIntakeValues[i].split('|'),
                        token = tokens[2];
                    if (token === code) {
                        tagExists = true;
                    }
                }
                return tagExists;
            },

            addTag: function(title, category, code, hierarchy, countryCode, isChild) {
                if (!title || !title.length) {
                    return;
                }
                title = title.trim();

                // bail out if tag has allready been added
                if (that.checkTagExists(code)) {
                    return;
                }

                // add item to stored values
                searchIntakeValues.push(title + '|' + category + '|' + code + '|' + hierarchy + '|' + countryCode);

                this.tags.append('<li data-code="' + code + '"><span>' + title + '</span><a class="icon-close-circle" href="#" /></li>');
                that.updateDisplay();
                that.checkAndUpdateDates(title, category, code, hierarchy); // auto-suggest date call
                that.hideAutosuggestion();
            },
            hideAutosuggestion: function() {
                searchResultFlyout.removeClass('open').hide();
            },
            removeTag: function(title, category, code, hierarchy, isChild, fromTagClose) {

                var tag = this.tags.find('li').filter('[data-code="' + code + '"]'),
                    l = searchIntakeValues.length,
                    i;

                if (tag.length) {
                    tag.remove();
                }

                for (i = 0; i < l; i++) {
                    if (tag.length === 0) {
                        return;
                    }
                    if (searchIntakeValues[i].split('|')[2].indexOf(code) >= 0) {
                        searchIntakeValues.splice(i, 1);
                        i = l;
                    }
                }
                /*
                				if (!isChild) {
                					$('#search-all-destinations input[data-code="' + code + '"]').prop('checked', false);
                				}

                				var selectedDestination = $('.dest-content li[data-code="' + code + '"]');
                				selectedDestination.removeClass('selected');
                				selectedDestination.find('input').prop('checked', false);
                				if (fromTagClose) {
                					this.setFocusOnInputField();
                				}
                				*/
                that.updateDisplay();
                that.identifyRemainingTag(searchIntakeValues); // check if there is only 1 item in search destination and make auto-suggest date call
            },
            openPanel: function() {
                _openPanel();
            },
            setFocusOnInputField: function() {
                searchInput.val('').focus();
                if (isSafari) {
                    searchInput.trigger('click');
                }
                if (TUIUtil.isMSIE()) {
                    searchInput.trigger('focusin').focus();
                }
                if (searchResultFlyout.is(':visible')) {
                    _showRecentSearch();
                }
            },
            removeDestinationTag: function() {
                that.setSearchIntakeValues();
                $(this).parents('ul').empty();
                that.tags.empty();
                that.updateDisplay();
                that.identifyRemainingTag(searchIntakeValues);
                setTimeout(function() {
                    that.destinationWrapper.trigger('click');
                }, 100);
            },
            identifyRemainingTag: function(searchIntakeValues) {
                var searchStr, usrSelectedTitle, usrSelectedCategory, usrSelectedCode, usrSelectedHierarchy;
                if (searchIntakeValues.length === 1) {
                    searchStr = searchIntakeValues[0].split('|');
                    usrSelectedTitle = searchStr[0];
                    usrSelectedCategory = searchStr[1];
                    usrSelectedCode = searchStr[2];
                    usrSelectedHierarchy = searchStr[3];
                }
                that.checkAndUpdateDates(usrSelectedTitle, usrSelectedCategory, usrSelectedCode, usrSelectedHierarchy);
            },
            clearAllTags: function() {
                searchIntakeValues = [];
                this.tags.html('');
                this.tagCounts.html('');
                this.searchInput.val('');
                $.publish('search/destinations/change');
            },

            setSearchIntakeValues: function(array) {
                if (array && array.length) {
                    searchIntakeValues = array;
                } else {
                    searchIntakeValues = [];
                }
            },
            trimExtraResults: function(data) {
                var currentOptions = (data && data.autoSuggestResponse) ? data.autoSuggestResponse[0].options : [];
                if (currentOptions.length > MAX_AUTOSUGGESTION) {
                    var newArr = currentOptions.splice(0, MAX_AUTOSUGGESTION);
                    data.autoSuggestResponse[0].options = newArr;
                }
            },
            /**
             * Set first element selected on autosuggest
             */
            setFirstSelected: function(resultContainer) {
                resultContainer.find('#_results').find('li:first-child').addClass(' selected');
            },
            getAddedTags: function() {
                return searchIntakeValues;
            },
            highlightResult: function() {
                noResults.hide();

                if (searchInput.val().length >= 0) {
                    searchResultFlyout.find('li').removeClass('match').hide()
                        .filter(function() {
                            return searchInput.val().toLowerCase().indexOf(searchInput.val().toLowerCase()) !== -1;
                        })
                        .addClass('match').show();
                    _highlight(searchInput.val());

                    if ($('#recentSearchResults li.match').length === 0) {
                        noResults.show();
                    } else if ($('#recentSearchResults li.match').length > 0) {
                        noResults.hide();
                    }
                } else {
                    $('#searchResultFlyoutRedesign li')
                        .show()
                        .add('#searchResultFlyoutRedesign')
                        .removeClass('match');
                }
            },
            emptyCheck: function() {
                var flyout = $('#searchResultFlyoutRedesign');
                if (flyout.length && flyout.is(':visible')) {
                    var innerPanel = flyout.find('.panel');

                    if (innerPanel.length) {
                        var html = innerPanel.html().trim();
                        if (innerPanel.is(':empty')) {
                            flyout.find('.enscroll-track').hide();
                            innerPanel.removeAttr('style');
                        }
                        if (!html) {
                            _showHideFlyout(flyout, false);
                        } else {
                            _showHideFlyout(flyout, true);
                        }
                    }
                }
            },
            /* used to check if user has selected date and
				if there is only 1 tag remaining in search destination field
				then auto suggest date for the user */
            checkAndUpdateDates: function(title, category, code, hierarchy) {

                // DEV-17855 suppressing this call.
            },
            handleNoValidation: function(data) {
                if (!data || !data.validationErrorMessage) {
                    data = {
                        validationErrorMessage: {
                            message: (data && data.noResultsMessage) ? data.noResultsMessage : 'Sorry not available',
                            alternateLinkText: null,
                            validationType: null,
                            matchedDestination: null
                        }
                    };
                }
                return data;
            },

            validateDisabledDestination: function(destination, callback, element, showLoaderAt) {
                if (showLoaderAt) {
                    TUIUtil.toggleLoader(showLoaderAt);
                }
                var postJSON = that.controller.getFormValues();
                postJSON.disabledDestination = destination;
                TUIUtil.genericAjaxRequest({
                    url: that.disableDestService,
                    cache: false,
                    type: 'post',
                    dataType: 'json',
                    contentType: 'application/json',
                    data: JSON.stringify(postJSON),
                    success: function(data) {
                        data = that.handleNoValidation(data);
                        if (callback) {
                            callback(data, element);
                        }
                    },
                    error: cleanupValidationToolTip
                });
            },
            updateDisplay: function() {
                var tags = searchIntakeValues,
                    tagCount = tags.length,
                    placeholderTxt = tagCount ? tags[0].split('|')[0] : defaultPlaceholderTxt,
                    currentWrapperHeight,
                    iconGlobeWidth = $('.icon-globe').outerWidth() + 10,
                    inputLi = that.wrapper.find('#searchPanel-field-search'),
                    count = '';
                that.placeholder.css('maxWidth', that.wrapper.width() - (iconGlobeWidth + that.tagCounts.width()));
                that.tagCounts.text('');
                if (tagCount > 1) {
                    count = '+' + parseInt(tagCount - 1, 10);
                }
                if (tagCount > 0) {
                    searchInput.attr('placeholder', '');
                } else {
                    searchInput.attr('placeholder', defaultPlaceholderTxt);
                }

                that.placeholder.text(placeholderTxt);
                this.destinationWrapper.attr('title', placeholderTxt);
                placeholderTxt = TUIUtil.trimText(placeholderTxt, this.destinationWrapper, count);
                this.destinationWrapper.html(updateInputText(placeholderTxt, count, tagCount));

                // multiLine for clear all positioning
                currentWrapperHeight = that.wrapper.height();
                var multiLine = true;
                that.wrapper[multiLine ? 'addClass' : 'removeClass']('multiLine');
                _tagScroll();
            }
        };

        updateInputText = function(destination, count, tagCount) {
            var tagHtml;
            if (tagCount > 0) {
                tagHtml = '<ul class="tags">';
                tagHtml += '<li>';
                tagHtml += '<span>';
                tagHtml += destination + count;
                tagHtml += '</span>';
                tagHtml += '<span class="icon-close-circle">';
                tagHtml += '</li>';
                tagHtml += '</ul>';
            } else {
                tagHtml = '<span class="placeholder-text">';
                tagHtml += destination;
                tagHtml += '</span>';
            }
            return tagHtml;
        };

        /**
         * Toggle flyout based on provided options
         * @param  {[type]} flyout [description]
         * @param  {[type]} show   boolean
         * @return {[type]}        [description]
         */
        _showHideFlyout = function(flyout, show) {
            var resultContainer = flyout.find('.search-result-panel');
            if (resultContainer.hasClass('error-msg-visible') && flyout.find('.error-msg').length === 0) {
                resultContainer.removeClass('error-msg-visible');
            }
            if (!show) {
                flyout.removeClass('open');
                $(document).off('click.closePanel');
            } else {
                $('.destination-flyout').hide();
                var wrapperPos = that.wrapper.position(),
                    top = wrapperPos.top + that.wrapper.outerHeight() + 8,
                    inputOffset = searchInput.offset().left,
                    arrowParentOffset = that.controller.panelArrow.parent().offset() ? that.controller.panelArrow.parent().offset().left : 40,
                    arrowLeft = inputOffset - arrowParentOffset;
                // Add Display hidden initially

                flyout.addClass('open').css({
                    top: 0
                });

                that.controller.panelArrow.css({
                    left: arrowLeft < 35 ? 35 : arrowLeft,
                    top: top - 10
                }).show();
                // _addScroll(); commented so that wrapper height is updated on show
                that.controller.panels.not(flyout).removeClass('open');
                that.controller.$openPanel = flyout;
                that.controller.bindGlobalClosePanel();
                if (!searchPanelContainer.is(':visible')) {
                    searchPanelContainer.addClass('open').show();
                }
                if (searchPanelContainer.is(':visible') && !searchPanelContainer.hasClass('open')) {
                    searchPanelContainer.addClass('open');
                }
                // _addScroll();
            }
            that.controller.panelOpen = show;
            that.controller.scrollWindowTillHeader(that.wrapper, true);
        };

        // Add scroll bar to auto suggest result flyout
        _addScroll = function() {
            var autosuggestWrapper = searchPanelContainer,
                autosuggestList = $('#searchResultFlyoutRedesign'),
                autosuggestListPanel = autosuggestList.find('.panel'),
                searchPanelHeight = $('#search-panel').height(),
                btnViewAllHeight = that.viewAllBtn.height();
            autosuggestListPanel.removeAttr('style');

            var winHeight = (window.innerHeight - searchPanelHeight - that.wrapper.height() - 60) * 0.75,
                winWidth = autosuggestWrapper.find('> .panel').width() + 10,
                contentHeight = autosuggestListPanel.height(),
                scroll = autosuggestListPanel.parent().find('.enscroll-track').parent();
            autosuggestListPanel.parent().find('.enscroll-track').parent().remove();
            if (TUIUtil.getCurrentBreakPoint() === 'xs') {
                return;
            }

            autosuggestListPanel.css({
                'height': winHeight - btnViewAllHeight,
                'overflow': 'auto',
                'padding-right': 5,
                'width': winWidth
            });
            $(scroll).remove();

            autosuggestListPanel.enscroll({
                verticalTrackClass: 'track4',
                verticalHandleClass: 'handle4',
                minScrollbarLength: 28,
                easingDuration: 100
            });

        };
        _tagScroll = function() {

            var autosuggestListPanel = that.wrapper.find('.tag-scroll');

            setInputWidth();

            if (!autosuggestListPanel.length) {
                return;
            }
            var winHeight = 150,
                tagCount = searchIntakeValues.length,
                winWidth = that.wrapper.outerWidth(),
                contentHeight = autosuggestListPanel.height(),
                scrollbar = autosuggestListPanel.parent().find('.enscroll-track').parent();
            autosuggestListPanel.parent().find('.enscroll-track').parent().remove();
            autosuggestListPanel.css({
                'max-height': winHeight,
                'overflow': 'auto',
                'padding-right': '0px',
                'width': winWidth
            });

            $(scrollbar).remove();
            if (tagCount > 1) {

                setTimeout(function() {
                    autosuggestListPanel.siblings().remove();
                    autosuggestListPanel.enscroll({
                        verticalTrackClass: 'track4',
                        verticalHandleClass: 'handle4',
                        minScrollbarLength: 28,
                        easingDuration: 100
                    });
                    autosuggestListPanel.scrollTop(autosuggestListPanel[0].scrollHeight);
                    var isTagScroll = $('.tag-scroll').next().css('display');
                    if (isTagScroll === 'block') {
                        that.wrapper.addClass('tag-scroll-true');
                        $('.tag-scroll').next().addClass('tag-scroll-bar');
                    } else {
                        that.wrapper.removeClass('tag-scroll-true');
                    }
                }, 0);

            } else {
                that.wrapper.removeClass('tag-scroll-true');
                setInputWidth();
            }
        };

        var setInputWidth = function() {
            var tagHolder = $('.dropdown-panel.search-destination .tagHolder'),
                tagWrapper = tagHolder.find('.tag-wrapper'),
                fieldWrapper = tagHolder.find('.field-wrapper'),
                searhField = tagHolder.find('.search-destination-field');

            var widthTagHolder = tagHolder.width(),
                widthTagWrapper = tagWrapper.width(),
                actualWidth = widthTagHolder - widthTagWrapper;

            if (actualWidth < 50) {
                fieldWrapper.width(widthTagHolder - 20);
                searhField.width(widthTagHolder - 30);
                searhField.css('maxWidth', widthTagHolder - 30);
            } else {
                fieldWrapper.width(actualWidth - 10);
                searhField.width(fieldWrapper.width() - 20);
                searhField.css('maxWidth', fieldWrapper.width());
            }

        };

        // It will be called on keypress with a delay if the search chars are greater than 2

        _typeahead = function() {
            if (that.ele.val().length > 0) {
                window.setTimeout(function() {
                    _autosuggest();
                }, 2000);
            }
        };

        /**
         * Highlight the matched string only
         * @param  {[typed]} string [description]
         * @return {[type]}        [description]
         */
        _highlight = function(typed) {
            if (!typed || !typed.length) {
                return;
            }

            function matchLoop() {
                var $t = $(this),
                    subTxt = $t.find('i').text(),
                    rawTxt = $.trim($t.text()),
                    txt = $.trim(rawTxt.replace(subTxt, '')),
                    toMatch = typed.toLowerCase(),
                    start = txt.toLowerCase().indexOf(toMatch),
                    end = (start + typed.length - 1),
                    beforeMatch = txt.slice(0, start),
                    matched = rawTxt.slice(start, end + 1),
                    afterMatch = txt.slice(end + 1),
                    html;

                if (start > -1) {
                    html = '<span data-icon=""></span><em>' + beforeMatch + '<strong>' + matched + '</strong>' + afterMatch + ' <i>' + subTxt + '</i></em>';
                    $t.html(html);
                }
            }
            searchResultFlyout.find('li.match').each(matchLoop);
        };
        var handleDisabledDestination = function(data, element) {
            cleanupValidationToolTip();
            var validationData = data.validationErrorMessage;
            if (validationData && validationData.validationType) {
                var messageString = that.disabledDestTemplate(data);
                TUIUtil.showInlineMessage(element, {
                    message: messageString,
                    cssClass: 'code-' + validationData.matchedDestination.code,
                    highlightElement: [],
                    arrow: true,
                    container: element,
                    left: 0
                });
            } else if (validationData && validationData.matchedDestination) {
                that.addTag(validationData.matchedDestination.name, validationData.matchedDestination.type, validationData.matchedDestination.code, validationData.matchedDestination.hierarchy, validationData.matchedDestination.countryCode);
                that.controller.closePanel();
            } else {
                if (validationData && validationData.message) {
                    var msg = that.disabledDestTemplate(data);
                    TUIUtil.showInlineMessage(element, {
                        message: msg,
                        cssClass: 'not-available',
                        highlightElement: [],
                        arrow: true,
                        container: element,
                        left: 0
                    });
                }
                TUIUtil.printLog('No validation json recieved');
            }
        };
        var cleanupValidationToolTip = function() {
            searchResultFlyout.find('.loader-container').remove();
            searchResultFlyout.find('.tui-tooltip-inline').remove();
        };

        /**
         * Choose from the autosuggest list starts here
         * @return {[type]} [description]
         */
        _selectValue = function(e) {
            var $t = $(this);
            if ($t.hasClass('error-msg')) {
                return false;
            }
            // bail out if the item is .none
            if ($t.hasClass('none')) {
                return false;
            }

            if (isForExampleOrRecentSearch($t) && $t.is('li')) {
                if (that.checkTagExists($t.data('code')) || $t.siblings('.code-' + $t.data('code')).length) {
                    return false;
                }
                var destination = {
                    code: $t.data('code'),
                    name: $.trim($t.find('em').text().replace($t.find('i').text(), '')),
                    type: $t.data('type'),
                    countryCode: $t.data('countrycode'),
                    hierarchy: $t.data('hierarchy')
                };
                cleanupValidationToolTip();
                that.validateDisabledDestination(destination, handleDisabledDestination, $t, searchResultFlyout.find('div.panel'));
            } else {

                // set / declare vars
                var currentItem = $t.data('name'),
                    currentCategory = $t.data('type'),
                    currentItemHierarchy = $t.data('hierarchy'),
                    currentItemCountryCode = $t.data('countrycode'), // Only here the titlecase is not used as hbs recommendation
                    currentItemCode = $t.data('code');

                if ($t.hasClass('alternate-link')) {
                    var alternatePanelName = $t.parents('.validation-err-msg').data('targetpanel');
                    if (alternatePanelName === 'both') {
                        alternatePanelName = 'where';
                        resetDates();
                    }
                    if (alternatePanelName === 'when') {
                        resetDates();
                    }
                    that.addTag(currentItem, currentCategory, currentItemCode, currentItemHierarchy, currentItemCountryCode);

                    searchInput.val('').blur();

                    $('[data-panel="' + alternatePanelName + '"]').trigger('click');
                } else {
                    that.addTag(currentItem, currentCategory, currentItemCode, currentItemHierarchy, currentItemCountryCode);
                    if (e !== 'auto') {
                        searchInput.val('').keyup();
                        if (TUIUtil.isMSIE()) {
                            searchInput.focus();
                        }
                    } else {
                        searchInput.val('');
                    }
                }
                that.controller.closePanel();
                if (TUIUtil.getCurrentBreakPoint() === 'xs' && !$('#searchDestinationRedesign').hasClass('open')) {
                    that.showHideMobilePickerField(true);
                }
            }
            cleanupValidationToolTip();

            return false;
        };

        var isForExampleOrRecentSearch = function(li) {
            if (li.parents('#recentSearches_results').length || li.parents('#forExample_results').length) {
                return true;
            } else {
                return false;
            }
        };

        _openPanel = function(e) {
            that.destinationBrowseList.cleanup(that.destinationBrowseList.countryContainer);
            that.isFlyoutOpen = true;
            searchResultFlyout.find('div.panel').empty();
            searchResultFlyout.find('hidden-xs').removeClass('hidden-xs');

            var $objPanelWrapper = searchPanelContainer,
                $searchPanelFlyout = $('#searchResultFlyoutRedesign'),
                $objSearchFiledWrapper = $objPanelWrapper.find('.searchWrapper .search-field-group'),
                $objSearchRedesignPanel = that.wrapper,
                $objSearchResultContainer = $objPanelWrapper.find('.search-result-panel'),
                $objSearchFiledWHeight = $objSearchFiledWrapper.height();
            $objPanelWrapper.find('.panel').removeAttr('style');
            $objSearchRedesignPanel.removeClass('hidden');
            if (that.isFlyoutOpen === false) {
                that.isFlyoutOpen = true;
            }
            $objPanelWrapper.removeAttr('style').addClass('open').show();

            that.destinationBrowseList.loadCountries();
            searchResultFlyout.show();

            setInputWidth();
            that.showHideMobilePickerField(false);
        };

        /**
         * AutoSuggest on key events
         * @param  {[type]} e [description]
         * @return {[type]}   [description]
         */
        _autosuggest = function(e) {
            e.preventDefault();
            lastAutoSuggestResponse = {};
            // Return if up or down key is pressed
            $('.destination-flyout').hide();
            var key = e.keyCode,
                totalLI = searchResultFlyout.find('li'),
                resultsCount = totalLI.length,
                selectedLI = searchResultFlyout.find('li.selected'),
                mouseOverElement = searchResultFlyout.find('li.active'),
                firstLiChild = searchResultFlyout.find('li:first'),
                firstActiveChild = searchResultFlyout.find('li:first.active'),
                lastChild = searchResultFlyout.find('li:last'),
                selectedLIIdx,
                mouseActiveLiIdx,
                activeIdx;

            // Prevent backspace to load previous page

            if (key === 8 && searchInput.val().length === 0) {
                searchResultFlyout.find('div.panel').empty();
                _showRecentSearch();
                return false;
            }
            if (key === 40 || key === 38 || key === 27 || key === 13) { // TUIUtil.printLog('up or down key');
                if (key === 40) { // DOWN key
                    if (mouseOverElement.length) {
                        mouseActiveLiIdx = totalLI.index(mouseOverElement);
                        activeIdx = (mouseActiveLiIdx === resultsCount - 1) ? mouseActiveLiIdx : mouseActiveLiIdx + 1;
                        mouseOverElement.removeClass('active');
                        totalLI.eq(activeIdx).addClass('selected');
                        return;
                    }
                    if (lastChild.length && lastChild.hasClass('selected')) {
                        return;
                    }
                    selectedLIIdx = totalLI.index(selectedLI);
                    selectedLI.removeClass('selected');

                    if (selectedLIIdx + 1 < resultsCount) {
                        totalLI.eq(selectedLIIdx + 1).addClass('selected');
                    }
                } else if (key === 38) { // UP Key
                    if (mouseOverElement.length) {
                        mouseActiveLiIdx = totalLI.index(mouseOverElement);
                        activeIdx = (mouseActiveLiIdx === 0) ? mouseActiveLiIdx : mouseActiveLiIdx - 1;
                        mouseOverElement.removeClass('active');
                        totalLI.eq(activeIdx).addClass('selected');
                        return;
                    }
                    if (firstLiChild.length && firstLiChild.hasClass('selected')) {
                        firstLiChild.removeClass('selected');
                        searchInput.focus();
                        return;
                    }
                    selectedLIIdx = (totalLI.index(selectedLI) !== -1) ? totalLI.index(selectedLI) : 0;
                    selectedLI.removeClass('selected');
                    if (firstActiveChild.length || !selectedLIIdx) {
                        return;
                    }

                    if (resultsCount - selectedLIIdx >= 0) {
                        totalLI.eq(selectedLIIdx - 1).addClass('selected');
                    } else {
                        totalLI.eq(resultsCount - 1).addClass('selected');
                    }
                }
                /*else if (key === 27) { // ESC escape Key
					that.controller.closePanel();
					return false;
				}*/
                else if (key === 13) { // ENTER Key
                    _selectValueOnEnterAndTab(e);
                }

                return false; // do not trigger an ajax call
            } else {
                // Trigger ajax call based on the minimum letters typed in
                if (that.timeout) {
                    clearTimeout(that.timeout);
                    that.timeout = null;
                }
                if (that.currentAutoSuggestCall) {
                    that.currentAutoSuggestCall.abort();
                }

                if (searchInput.val().length >= MIN_SEARCH_CHARS) {
                    that.showSpinner(true);
                }
                that.timeout = window.setTimeout(function() {
                    if (searchPanelContainer.is(':visible') && $('.country-container').find('.scrollable-container').length) {
                        if (searchInput.val().length < MIN_SEARCH_CHARS) {
                            var _isExampleVisible = searchResultFlyout.find('#forExample_results').is(':visible');
                            if (_isExampleVisible) {
                                $('.destination-flyout').is(':visible') && $('.destination-flyout').hide();
                                _showHideFlyout(searchResultFlyout, true);
                                return;
                            }
                            $('.destination-flyout').is(':visible') && $('.destination-flyout').hide();
                            searchResultFlyout.find('div.panel').empty();
                            _showRecentSearch();
                            return false;
                        }

                        // that.showSpinner(true);
                        that.currentAutoSuggestCall = that.get()
                            .done(_appendAutoSuggest)
                            .fail(function() {
                                // add fail code here
                            });
                    }
                }, SEARCH_DELAY);
            }
        };

        _selectValueOnEnterAndTab = function(eventType) {
            var selectedLI = searchResultFlyout.find('li.selected');
            if (!selectedLI.length && eventType !== 'auto') {
                return _handleEnterForSelection(eventType);
            } else if (selectedLI.length) {
                selectedLI.trigger('click');
            }
            // _selectValue.call(selectedLI[0], eventType);
        };

        _selectMatchedValue = function(eventType, activeResponse) {
            var matchedLI = searchResultFlyout.find('li.match');
            if (matchedLI.length) {
                return _handleEnterForSelection(eventType, activeResponse);
                // matchedLI.trigger('click');
            }

        };
        /**
         * If only one element and that matches with the input value or the first name before , matches
         * with the input then select it , else show an no match message.
         * @param  {[type]} eventType [description]
         * @return {[type]}           [description]
         */
        var _handleEnterForSelection = function(eventType, activeResponse) {
            if (that.currentAutoSuggestCall) {
                that.currentAutoSuggestCall.abort();
            }
            var msg = that.searchInput.data('nomatchmsg');
            var originalVal = that.searchInput.val();
            var suggestion = searchResultFlyout.find('ul#_results').find('li');
            var ret = false;
            var inputVal = that.searchInput.val().toLowerCase();

            suggestion = suggestion.first();
            if (suggestion.length === 1) {
                var suggestionText = suggestion.find('em').text(),
                    name = '';
                suggestionText = suggestionText.trim();
                if (suggestionText.indexOf(',')) {
                    var tokens = suggestionText.split(',');
                    name = tokens[0];
                }
                suggestionText = suggestionText.trim();
                suggestionText = suggestionText.toLowerCase();
                name = name.toLowerCase();

                if (suggestionText === inputVal || name === inputVal) {
                    _selectValue.call(suggestion, eventType);
                    ret = true;
                } else if (eventType === 'auto' && !activeResponse) {
                    return;
                } else {
                    _showNoMatchMessage(msg, originalVal);
                }
            } else {
                _showNoMatchMessage(msg, originalVal);
            }
            return ret;
        };


        var _showNoMatchMessage = function(msg, originalVal) {
            searchResultFlyout.find('ul#_results').addClass('error-msg-visible').empty().append('<li class="error-msg"><span>' + msg + '<b>' + originalVal + '</b></span></li>');
        };
        /**
         * Success Callback for autosuggest search ajax call.
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        _appendAutoSuggest = function(data) {
            that.showSpinner(false);
            lastAutoSuggestResponse = data;
            searchInput.trigger('focusin').focus();
            if (TUIUtil.detectDeviceType === 'iPad') {
                searchInput.trigger('touchstart').focus();
                searchInput.on('touchstart', function() {
                    $(this).focus();
                });
            }
            /*if (!searchInput.is(':focus')) {
				searchInput.blur();
				return;
			}*/

            that.controller.closePanel(searchInput);
            searchResultFlyout = $('#searchResultFlyoutRedesign');
            var resultContainer = searchResultFlyout.find('div.panel');
            resultContainer.empty();
            data.done = that.labels.done;
            data.allDestinationLabel = that.allDestinationLabel;
            that.trimExtraResults(data);
            resultContainer.append(that.template(data));
            that.highlightResult();
            _showHideFlyout(searchResultFlyout, true);
            searchResultFlyout.show();
            that.wrapper.removeClass('loading');
            if (TUIUtil.isMSIE()) {
                searchInput.focus().val(searchInput.val());
            }
            searchResultFlyout.off('touchstart').on('touchstart', '.scroll-panel', function(e) {
                if (TUIUtil.isTouchDevice()) {
                    searchInput.blur();
                }
            });
            if (TUIUtil.getCurrentBreakPoint() === 'xs') {
                that.showHideMobilePickerField(false);
            }
        };

        /**
         * If there is only one result select it
         * @return {[type]} [description]
         */
        var selectIfOnlyOneResult = function(data, eventType, activeResponse) {
            if (data && data.autoSuggestResponse && data.autoSuggestResponse.length === 1) {
                if (data.autoSuggestResponse[0].options && data.autoSuggestResponse[0].options.length === 1) {
                    if (that.checkTagExists(data.autoSuggestResponse[0].options[0].code)) {
                        return;
                    }
                    if (activeResponse) {
                        _selectValueOnEnterAndTab(eventType);
                    } else {
                        _selectMatchedValue(eventType, activeResponse);
                    }
                }
            }
        };

        var isNumeric = function(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        };
        var getTagTypes = function(valueArray) {
            var tagTypeArr = [];
            var conceptsArr = ['LABEL', 'CONCEPT'];
            var destinationArray = ['RESORT', 'DESTINATION', 'COUNTRY', 'REGION'];

            $.each(valueArray, function(i, item) {
                var type = '';
                if (typeof item === 'string') {
                    type = item.split('|')[1];
                } else {
                    type = item.type;
                }

                if ($.inArray(type, tagTypeArr) !== -1) { // already present
                    return true;
                } // Concepts
                else if ($.inArray(type.toUpperCase(), conceptsArr) !== -1) { // matching concept
                    tagTypeArr = tagTypeArr.concat(conceptsArr);
                }
                // Destinations
                else if ($.inArray(type.toUpperCase(), destinationArray) !== -1) { // matching concept
                    tagTypeArr = tagTypeArr.concat(destinationArray);
                } else {
                    tagTypeArr.push(type);
                }


            });
            return tagTypeArr;
        };
        // Get the array of all the destinations selected by the user
        var _getTagCodes = function() {
            var tagCodesArr = [];

            $.each(searchIntakeValues, function(i, item) {
                tagCodesArr.push(item.split('|')[2]);
            });
            return tagCodesArr;
        };

        /**
         *  Filter only already added tags based on code only
         */
        var filterTags = function(currentArray, tags, type) {
            if (tags === undefined) {
                return;
            }
            $.each(currentArray, function(c, item) {
                var matched = false;
                $.each(tags, function(t, tag) {
                    if (item.code === tag) {
                        matched = true;
                    }
                });
                if (!matched) {
                    if (type === 'RS') {
                        filteredRS.push(item);
                    } else if (type === 'FE') {

                        filteredFE.push(item);
                    }
                }
            });

            if (type === 'RS') {
                return filteredRS;
            } else {
                return filteredFE;
            }
        };

        /**
         * Display the recent searches from cookie on focus on input field when no data present.
         * @return {[type]} [description]
         */
        function _showRecentSearch() {
            filteredFE = [];
            filteredRS = [];

            var wrappedJSON = {
                    autoSuggestResponse: []
                },
                // Get CODES of selected values
                tagCodesArr = _getTagCodes(),
                // Get simillar TYPES based on selectedValues
                tagTypes = getTagTypes(searchIntakeValues);

            // Filter RS based on the selected tags CODE and then TYPE
            var rsJSON = _getRecentSearchCookieData(tagCodesArr, tagTypes);
            // Filter FE based on the selected tags CODE and then TYPE and then based on the CODE and TYPES of RS as well

            var feJSON = _getForExampleCookieData(tagCodesArr, tagTypes, getTagTypes(rsJSON.options || []));

            // Now Limit the RS AND FE based on maxium count allowed.
            var updatedArrays = updateRSAndFECount(rsJSON.options, feJSON.options);

            rsJSON.options = updatedArrays.RSArray;
            feJSON.options = updatedArrays.FEArray;
            wrappedJSON.autoSuggestResponse.push(rsJSON, feJSON);

            if (rsJSON.options.length || feJSON.options.length) {
                _appendAutoSuggest(wrappedJSON);
            } else {
                that.emptyCheck();

            }
        }

        var updateRSAndFECount = function(RSArray, FEArray) {
            var remainingSlots,
                RSTempArray = [],
                FETempArray = [];

            if (RSArray && RSArray.length && maxSlots) {
                if (RSArray.length >= maxSlots) {
                    RSTempArray = RSArray.slice(0, maxSlots);
                } else {
                    RSTempArray = RSArray;
                }
            }
            RSArray = RSTempArray;
            remainingSlots = maxSlots - RSArray.length;
            if (FEArray && FEArray.length && remainingSlots) {
                if (FEArray.length >= remainingSlots) {
                    FETempArray = FEArray.slice(0, remainingSlots);
                } else {
                    FETempArray = FEArray;
                }
            }
            FEArray = FETempArray;
            return {
                RSArray: RSArray,
                FEArray: FEArray
            };
        };

        var filterBasedOnRSType = function(FEArray) {
            var finalFEArray = [];
            $.each(FEArray, function(f, fe) {
                var matched = false;
                $.each(RSArray, function(r, rs) {
                    if (fe.type === rs.type) {
                        matched = true;
                        return false;
                    }
                });
                if (!matched) {
                    finalFEArray.push(fe);
                }
            });
            FEArray = finalFEArray;
            return FEArray;
        };

        var filterBasedOnType = function(tagTypeArr, valueArray) {
            if (!tagTypeArr || tagTypeArr.length === 0) {
                return valueArray;
            }
            var filteredArray = [];

            $.each(valueArray, function(i, item) {
                if ($.inArray(item.type.toUpperCase(), tagTypeArr) !== -1) {
                    return true;
                } else {
                    filteredArray.push(item);
                }
            });
            return filteredArray;
        };

        /**
         * Recent Search Cookie Data
         * @return {[type]} [description]
         */
        var _getRecentSearchCookieData = function(tagCodesArr, tagTypeArr) {

            var json = {};
            if ($.cookie(RECENT_SEARCH_COOKIE)) {

                var cVal = $.cookie(RECENT_SEARCH_COOKIE);
                cVal = cVal.replace(/(\\r\\n|\\n|\\r)/gm, '');
                var cookieJSON = $.parseJSON(cVal);

                if (cookieJSON.recentSearchValues && cookieJSON.recentSearchValues.length) {
                    // Update cookie JSON based on tags
                    cookieJSON.recentSearchValues = filterTags(cookieJSON.recentSearchValues, tagCodesArr, 'RS');
                    // As confirmed by George RS will not be filtered based on type
                    // cookieJSON.recentSearchValues = filterBasedOnType(tagTypeArr, cookieJSON.recentSearchValues);
                    json = {
                        type: 'recentSearches',
                        groupLabel: recentSearchesLabel,
                        options: cookieJSON.recentSearchValues
                    };
                }
            }
            return json;
        };

        /**
         * For Example Search Cookie Data
         * //////CHANGE REMOVED FOR EXAMPLE COOKEI JUST USE JSON/////
         * @return {[type]} [description]
         */
        var _getForExampleCookieData = function(tagCodesArr, tagTypeArr, RSTypesArray) {
            var json = {};

            if (window.forExampleJSON) {
                var cVal = window.forExampleJSON;
                cVal = JSON.stringify(cVal);
                cVal = cVal.replace(/(\\r\\n|\\n|\\r)/gm, '');

                var cookieJSON = $.parseJSON(cVal);
                if (cookieJSON && cookieJSON.length) {
                    // Update cookie JSON based on tags
                    cookieJSON = filterTags(cookieJSON, tagCodesArr, 'FE');
                    cookieJSON = filterBasedOnType(tagTypeArr, cookieJSON);
                    cookieJSON = filterBasedOnType(RSTypesArray, cookieJSON);
                    cookieJSON = filterBasedOnType(tagTypeArr, cookieJSON);

                    json = {
                        type: 'forExample',
                        groupLabel: forExampleLabel,
                        options: cookieJSON
                    };
                }
            }
            return json;

        };

        var _convertArrayToJSON = function() {
            var jsonArr = [];
            $.each(searchIntakeValues, function(i, item) {
                var tokens = item.split('|'),
                    json = {
                        name: tokens[0],
                        code: tokens[2],
                        type: tokens[1],
                        hierarchy: tokens[3]
                    };
                if (tokens[4]) {
                    json.countryCode = tokens[4];
                }
                jsonArr.push(json);
            });
            return jsonArr;
        };

        /**
         * Various page laod events on autosuggest component.
         * This method should be called only once after page load
         * @return {[type]} [description]
         */
        _bindEvents = function() {

            // Event: Selecting a value from the autosuggest results
            searchPanelContainer.on('click', '#searchResultFlyout li,.alternate-link', _selectValue);
            searchPanelContainer.on('click', '#searchResultFlyoutRedesign li,.alternate-link', _selectValue);

            // Event: Highlighting the search text in results on keyup
            searchPanelContainer.on('keyup', '#searchPanel-field-search', function(e) {
                if (e.keyCode === 27) {
                    return false;
                } else {
                    methods.highlightResult();
                }
            });

            // searchPanelContainer.on('click', '.type-destination', _showHideSearchInputBox);
            // Event: Close Other Panel incase of mobile
            searchPanelContainer.on('click', '#searchPanel-field-search-redesign', function(e) {
                _autosuggest(e);

                if (!TUIUtil.istabletOrDesktop()) {
                    that.controller.scrollWindowTillHeader(that.wrapper, true);
                }

            });

            searchPanelContainer.on('click', '.tag-wrapper', function(e) {
                $('#searchPanel-field-search-redesign').focus();
            });

            searchResultFlyout.on('mouseover', 'li', function(e) {
                var selectedLi = searchResultFlyout.find('li.selected');
                if (selectedLi.length) {
                    selectedLi.removeClass('selected');
                }
                $(this).addClass('active');
            });

            searchResultFlyout.on('mouseleave', 'li', function(e) {
                $(this).removeClass('active');
            });


            searchPanelContainer.on('click', '.selected .icon-close-circle', function() {
                var $childName = $(this).parent(),
                    $parent = $childName.parent(),
                    $currentItem = $.trim($childName.find('span:eq(0)').text()),
                    $currentCategory = $parent.data('type'),
                    $currentItemCode = $parent.data('code'),
                    $currentItemHierarchy = $parent.data('hierarchy'),
                    $currentItemCountryCode = $parent.data('code');

                that.removeTag($currentItem, $currentCategory, $currentItemCode, $currentItemHierarchy, $currentItemCountryCode);
                $childName.removeClass('selected');
            });

            // Event: Trigger the autosuggest ajax on keydown should be after 3 keys
            searchPanelContainer.on('keyup', '#searchPanel-field-search-redesign', _autosuggest); // removed focusin
            searchPanelContainer.on('blur', '#searchPanel-field-search-redesign', function(e) {
                var responses = searchPanelContainer.find('.search-result-grp li');
                if (responses.length && lastAutoSuggestResponse) {
                    var isResponseActive = responses.first().is(':active');
                    selectIfOnlyOneResult(lastAutoSuggestResponse, 'auto', isResponseActive);
                    // $(document).trigger('click');
                }
                // searchResultFlyout.removeClass('open');
                searchInput.val('');
            });
            searchPanelContainer.on('keydown', '#searchPanel-field-search-redesign', function(e) {
                if (e.keyCode === 9) {
                    _selectValueOnEnterAndTab(e);
                } else if (e.keyCode === 8) { // BACKSPACE
                    if (searchInput.val()) {
                        return true;
                    } else { // REMOVE LAST TAG
                        if (that.tags.find('li').length) {
                            that.tags.find('li:last').find('a.icon-close-circle').trigger('click');
                        }
                    }
                } else if (e.keyCode === 38) {
                    e.preventDefault();
                }
            }); // removed focusin
            searchResultFlyout.on('mouseover', 'li', function(e) {
                var selectedLi = searchResultFlyout.find('li.selected');
                if (selectedLi.length) {
                    selectedLi.removeClass('selected');
                }
                $(this).addClass('active');
            });

            searchResultFlyout.on('mouseleave', 'li', function(e) {
                $(this).removeClass('active');
            });
            // Event: remove tag
            that.tags.on('click', 'a.icon-close-circle', function(e) {
                e.preventDefault();
                e.stopPropagation();
                var $t = $(this),
                    tag = $t.parent('li'),
                    code = tag.data('code');
                that.removeTag('', '', code, null, null, true);
                that.destinationBrowseList.tagRemoved(code);

            });
        }; // end of _bindEvents

        var resetDates = function() {
            that.controller.resetDates();
        };
        /**
         * Event binding for the all destination link on search flyout.
         * @return {[type]} [description]
         */
        var openAllDestinationFromFlyout = function() {

        };

        $.extend(SearchAutoSuggest.prototype, methods);

        return SearchAutoSuggest;
    });

/*
	Usage
		* Element: on Input element with readonly attribute.
		* To use: $('.counter-widget').counterWidget();
		* Data Attributes: data-maxVal if there is a max val available OR data-valArr if the array of values is available
*/

(function($, window) {

    $.fn.counterWidget = function(options) {

        // var maxAdultVal = options.initJson['maxAdult'];
        // var maxKids = options.initJson['maxKids'];
        // var kidsAgeArray = options.initJson['kidsAgeArray'];
        //options.allValues [1,2,3,4,5,6]
        //options.selectedValue 5

        //getting user settings from options
        var settings = $.extend(true, {}, $.fn.counterWidget.defaults, options);

        //function to get values array from data-attribute
        function getValArr(options) {
            var valArr = [],
                i = options.minParam || 0,
                tmp = options.minParam || 0;
            if (typeof(options.maxParam) === "number") {
                tmp = options.maxParam;
                while (i <= tmp) {
                    valArr.push(i);
                    i++;
                }
            } else {
                if (options.maxParam) {
                    tmp = options.maxParam;
                    valArr = tmp;
                }
            }

            return valArr;
        };

        //get current index of the value
        function getCurValIndex(ipVal, values) {
            var idx;
            $.each(values, function(indx, val) {
                if (ipVal == val) {
                    idx = indx;
                };
            });
            return idx;
        };

        //functionality
        function doOp(ele, action, values, idx, options) {
            if (action === '+') {
                if (idx === values.length - 1) {
                    return;
                } else {
                    $(ele).html(values[++idx]);
                }
            } else if (action === '-') {
                var minParam = 0;
                if (options.minParam) {
                    minParam = options.minParam;
                }
                if (idx === minParam) {
                    return;
                } else {
                    $(ele).html(values[--idx]);
                }
            }

        };

        function widgetTemplate(self, options) {
            var plus = $('<a href="">+</a>').attr('class', settings.plusClass).addClass(options.cssClass);
            minus = $('<a href="">-</a>').attr('class', settings.minusClass).addClass(options.cssClass);
            wrapperPlus = $("<span></span>").attr('class', settings.wrapperClass),
                wrapperMinus = $("<span></span>").attr('class', settings.wrapperClass),
                container = $("<div></div>").attr('class', settings.containerClass);
            wrapperMinus.append(minus).appendTo(container);
            self.appendTo(container);
            wrapperPlus.append(plus).appendTo(container);
            container.appendTo(options.appendInto);
            return container;
        };

        function bindWidgetEvent(self, wTemplate, options, values) {
            var ipVal,
                idx = 0;
            wTemplate.find('.plus').unbind('click');
            wTemplate.find('.minus').unbind('click');
            wTemplate.find('.plus').on('click', function(event) {
                event.preventDefault();
                ipVal = self.text();
                idx = getCurValIndex(ipVal, values);
                doOp(self, '+', values, idx, options);
                options.callBack(event, $(this), options);
            });


            wTemplate.find('.minus').on('click', function(event) {
                event.preventDefault();
                ipVal = self.text();
                idx = getCurValIndex(ipVal, values);
                doOp(self, '-', values, idx, options);
                options.callBack(event, $(this), options);
            });

        }

        return this.each(function() {
            var self = $(this);
            self.html(options.currentValue);
            var values = getValArr(options);
            var wTemplate = widgetTemplate(self, options);
            bindWidgetEvent(self, wTemplate, options, values);

        });
    };

    //defaults
    $.fn.counterWidget.defaults = {
        //classes should be mentioned here, not colors

        plusClass: 'plus',
        minusClass: 'minus',
        wrapperClass: 'wrapper',
        containerClass: 'mywid',
        pageContainer: 'body'
    };

})(jQuery, window);

define("vendor/counterWidget", function() {});


define('text!search-panel/templates/party-room.hbs', [], function() {
    return '<ul>\n\t<li class="col-xs-12 container-roomname">\n\t\t<header>\n\t\t\t<h4 class="room-header">\n\t\t\t\t{{#if isRoom1}}\n\t\t\t\t\t{{room1}}\n\t\t\t\t{{/if}}\n\t\t\t\t{{#if isRoom2}}\n\t\t\t\t\t{{room2}}\n\t\t\t\t{{/if}}\n\t\t\t\t{{#if isRoom3}}\n\t\t\t\t\t{{room3}}\n\t\t\t\t{{/if}}\n\t\t\t</h4>\n\t\t\t<i class="icon-arrow-down">&nbsp;</i>\n\t\t\t<div class="container-closeroom">\n\t\t\t\t{{#if isRoom2 }}\n\t\t\t\t\t<a href="#" class="icon-bubble-close"></a>\n\t\t\t\t{{/if}}\n\t\t\t\t{{#if isRoom3}}\n\t\t\t\t\t<a href="#" class="icon-bubble-close"></a>\n\t\t\t\t{{/if}}\n\t\t\t</div>\n\t\t</header>\n\t</li>\n\t<li class="col-sm-4 col-xs-12 container-adult">\n\t\t<label class="col-xs-12" for="adult-member-r{{roomNumber}}">{{adults}}</label>\n\t\t<span class="widspan">\n\t\t\t<em name="adults" class="counter-widget adult">{{adultCount}}</em>\n\t\t</span>\n\t</li>\n\t<li class="col-sm-4 col-xs-12 container-kids">\n\t\t<label class="col-xs-12" for="children-r{{roomNumber}}">{{childAge}} </label>\n\t\t<span class="widspan">\n\t\t\t<em name="children" class="counter-widget child">{{kidsCount}}</em>\n\t\t</span>\n\t</li>\n\t<li class="col-sm-4 col-xs-12 container-kidsage">\n\t\t<div class="return-date" style="display:none;">\n\t\t\t<label class="col-xs-6">{{ageMessage}}</label>\n\t\t</div>\n\t</li>\n</ul>\n';
});

define('search-panel/search-who-v3', [
    'jquery',
    'vendor/counterWidget',
    'handlebars',
    'text!./templates/party-room.hbs'
], function($, counterWidget, Handlebars, template) {

    function SearchWho(ele, opts) {
        this.ele = ele;
        this.controller = opts.controller;
        this.init();
        this.formData = {};
    }

    var that,
        rooms = [],
        room1, room2, room3,
        partySelectorInput = $('#who'),
        placeholderText = partySelectorInput.data('placeholder'),
        partyFlyout = $('#searchWho'),
        memberListContainer,
        totalAdults = 0,
        totalChildren = 0,
        initialWidth = 0,
        maxAdultLimit,
        maxChildrenLimit,
        travellerLimit,
        labels,
        adultErrorMessage = '',
        childrenLimitErrMessage = '',
        travellerLimitErrMsg = '',
        maxRoomOccupantMsg = '',
        infantErrMsg = '',
        childrenDDHTML = '',
        infantAgeErrMessage;


    var methods = {

        roomCount: 1,
        init: function() {
            //  init accordion
            that = this;
            initialWidth = that.ele.width(),
                that.template = Handlebars.compile(template);

            room1 = that.ele.find('#room-1');
            room2 = that.ele.find('#room-2');
            room3 = that.ele.find('#room-3');
            that.maxJSON = that.ele.find('.who').data('partyjmaxson');

            maxAdultLimit = that.ele.data('maxadultlimit');
            maxChildrenLimit = that.ele.data('maxchildrenlimit');
            travellerLimit = that.ele.data('maxtravellerlimit');
            labels = that.ele.data('labels');
            memberListContainer = that.ele.find('.member-list');
            adultErrorMessage = memberListContainer.data('adulterrormsg');
            infantErrMsg = memberListContainer.data('childerrormsg');
            childrenLimitErrMessage = memberListContainer.data('maxchildrenerrormsg');
            maxRoomOccupantMsg = memberListContainer.data('maxtravellererrormsg');
            travellerLimitErrMsg = memberListContainer.data('maxtravellererrormsg');

            $.subscribe('search_mode_changed', $.proxy(that.updatePartyMode, that));

            infantAgeErrMessage = memberListContainer.data('noageerrmsg') || 'Please select a valid age';
            rooms = partyFlyout.find('.choose-rooms').find('.room');

            $('.return-date').hide();
            that.addRoom();
            that.erMsgChildren();
            that.closeRoom();
            that.removeTag();
            dateChangeEvent();
            roomHeaderAccordion();

        },
        /**
         * Update party size or message based on tab change of search
         * @return {[type]} [description]
         */
        updatePartyMode: function() {
            var tabName = $('#search-panel-tabs').find('button.active').data('tabname') || 'package';
            if (tabName === 'flight') {
                maxRoomOccupantMsg = memberListContainer.data('maxseatlimitmsg');

            } else {
                maxRoomOccupantMsg = memberListContainer.data('maxtravellererrormsg');

            }

        },

        removeTag: function() {
            partySelectorInput.on('click', '.icon-close-circle', function(e) {
                that.controller.fromSubmit = false;
                e.stopPropagation();
                partySelectorInput.empty();
                partySelectorInput.attr('title', placeholderText);
                that.resetParty();
                partySelectorInput.trigger('click').focus();

            });
        },

        paintRooms: function(data) {

            that.ele.find('.room').empty().hide();

            if (!data || !data.rooms) {
                data = {
                    rooms: []
                };
            }
            if (data.rooms.length === 0) {
                data = that.ele.data('defaultsize');
            }

            $.each(data.rooms, function(i, roomData) {
                // applying counter widget According to room
                var $room = $('#' + roomData.id);
                $room.show();
                createCounter($room, roomData);
            });

            manageRoomLabel(data.rooms.length);
        },
        resetParty: function() {
            that.paintRooms(that.ele.data('defaultsize'));
            partySelectorInput.empty().append('<span class="placeholder-text">' + placeholderText + '</span>');
            that.formData = {};
        },
        getPartySizeAvailability: function(target, serviceURL) {
            // use defer to display result when result render
            var $dfd = $.Deferred();
            var postData = $.extend({}, this.controller.getFormValues(), {
                action: 'party'
            });
            TUIUtil.genericAjaxRequest({
                url: serviceURL,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(sdata) {
                updateSeatValidationData(sdata);
                $dfd.resolve(true);
            });
            return $dfd.promise();
        },

        getWhoString: function(rooms, adults, children) {
            if (!rooms) {
                rooms = 1;
            }

            if (!adults) {
                adults = 2; // Default Adult Value
            }
            var str = '';
            str += adults + ' ';
            str += (adults === 1) ? labels.adult : labels.adults;
            if (children) {
                str += ', ';
                str += children + ' ';
                str += (children === 1) ? labels.child : labels.children;
            }
            if (rooms > 1) {
                str += ', ';
                str += rooms + ' ';
                str += labels.rooms;
            }
            return str;
        },

        erMsgChildren: function() {

            var validateChilren = false;
            var countChild = 0;
            $('body').delegate('.child-selector select', 'change', that.placeholderCallback);
        },
        addRoom: function() {
            $('.room').hide();
            room1.show();
            that.ele.on('click', '.addroom-container .add-room', function(e) {
                if ($(this).hasClass('disabled')) {
                    return false;
                }
                e.preventDefault();
                var roomToShow = null;
                if ($(this).hasClass('disable')) {
                    return false;
                }

                if (!room2.is(':visible') && room3.is(':visible')) {
                    resetRoomOccupants();
                }

                $.each(rooms, function(i, room) {
                    room = $(room);
                    if (!room.is(':visible')) {
                        createCounter(room, {
                            'id': room.attr('id'),
                            'adults': '1',
                            'children': '0',
                            'childAgeList': []
                        });
                        if (room.hasClass('collapsed')) {
                            room.removeClass('collapsed');
                        }
                        room.show();
                        roomToShow = room;
                        return false;
                    }
                });
                that.placeholderCallback(null, roomToShow.find('a.adult-selector'));
                manageRoomLabel(that.formData.rooms.length);
                that.scrolltoBottom();

            });
        },

        scrolltoBottom: function() {
            var whoPanel = that.ele.find('.who-panel');
            whoPanel.animate({
                scrollTop: whoPanel.offset().top
            }, 500);
        },

        showAddRoom: function(show) {
            if (show) {
                that.ele.find('.addroom-container .add-room').show();
            } else {
                that.ele.find('.addroom-container .add-room').hide();
            }
        },
        triggerChange: function() {

            var element = rooms.not('.disable').first().find('.container-adult .minus');

            that.placeholderCallback(null, element);
        },
        /**
         * Set Input field value
         * @param {[type]} totalAdults   [description]
         * @param {[type]} totalChildren [description]
         */
        setFieldValue: function(fromCookie) {
            // recalculating adults & children
            var totalAdults = 0,
                totalChildren = 0;
            partyFlyout = $('#searchWho'); // Refreshing the obj
            partyFlyout.find('.room').each(function() {
                var $room = $(this),
                    adultCounter = $room.find('.counter-widget.adult');
                if (adultCounter.length) {
                    totalAdults += parseInt($(this).find('.counter-widget.adult').text(), 10);
                    totalChildren += parseInt($(this).find('.counter-widget.child').text(), 10);
                }
            });
            that.setPartyTags(that.getWhoString(getRoomCount(), totalAdults, totalChildren), fromCookie);
            that.controller.fromSubmit = false;

        },
        setPartyTags: function(string, force) {
            if (that.isDefaultPartySize() && !force) {
                if (that.formData && that.formData.rooms) {
                    // In case of default party size and not via cookie dont keep the room information
                    delete that.formData.rooms;
                }
                return;
            }
            partySelectorInput.attr('title', string);
            string = TUIUtil.trimText(string, partySelectorInput);
            var i,
                tagHtml = '<ul>';
            tagHtml += '<li>';
            tagHtml += '<span>';
            tagHtml += string;
            tagHtml += '</span>';
            tagHtml += '<span class="icon-close-circle" />';
            tagHtml += '</li>';
            tagHtml += '</ul>';
            partySelectorInput.empty().append(tagHtml);
        },
        isDefaultPartySize: function() {
            var defaultSize = false;
            var currentJSON = that.getFormValues();
            if (currentJSON.rooms) {
                if (currentJSON.rooms.length === 1) {
                    var room1 = currentJSON.rooms[0];
                    if (room1.adults === '2' && room1.children === '0') {
                        defaultSize = true;
                    }
                }
            } else {
                defaultSize = true;
            }
            if (partySelectorInput.find('.icon-close-circle').length) {
                defaultSize = false;
            }
            return defaultSize;

        },
        closeRoom: function() {
            that.ele.on('click', 'a.icon-bubble-close', function(e) {
                e.preventDefault();
                var room = $(this).parents('.room'),
                    roomNumber = 1;
                room.empty().hide();
                resetRoomNumber();
                that.formData.rooms = getRoomValues();
                manageRoomLabel(that.formData.rooms.length);
                that.placeholderCallback(e, $(this));
                e.stopPropagation();
            });
        },

        getFormValues: function(isFormSubmit) {
            if (isFormSubmit) {
                return that.sortRoomNumbers();
            }
            return that.formData;
        },
        sortRoomNumbers: function() {
            if (that.formData && that.formData.rooms) {
                $.each(that.formData.rooms, function(i, room) {
                    room.id = 'room-' + (i + 1);
                });
            }
            return that.formData;
        },
        showValidation: function() {
            var infantErrorIdx = existingValidationIndex('infant-limit'),
                adultChildErrorIdx = existingValidationIndex('adult-children-limit');
            if (infantErrorIdx !== -1 || adultChildErrorIdx !== -1) {
                $('.tui-tooltip.searchwho').show();
            }
        },
        placeholderCallback: function(event, elem) {
            //  START:- set who input box
            var elemContainer = $('#searchWho'), // Dont cache elemContainer here
                currentCb = (elem) ? elem : $(this),
                failed,
                currentRoom = currentCb.parents('.room');

            if (elem && (elem.hasClass('icon-close-circle') || elem.hasClass('icon-bubble-close'))) { // CloseRoomAction
                rooms.removeClass('disable');
                rooms.find('.overlay').remove();
                that.ele.find('.add-room').removeClass('disable');
                elem = room1.find('a.plus.adult-selector');
            }

            that.ele.find('.add-room').removeClass('disabled');

            if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {

                that.cleanupTooltips('.tui-tooltip-inline');
                failed = validate(currentCb, currentRoom);
                disableRooms(currentRoom, failed);
            }

            that.formData.rooms = getRoomValues();
            if (room3.is(':visible') && room2.is(':visible')) {
                that.showAddRoom(false);
            } else {
                that.showAddRoom(true);
            }
            that.setFieldValue();
        },

        /**
         * Removes the contextual tooltip
         * @param  {[type]} selector [description]
         * @return {[type]}          [description]
         */
        cleanupTooltips: function(selector) {
            if (!selector) {
                selector = '.tui-tooltip';
            }
            $('body').find(selector).remove();
            $('.choose-rooms').find('.overlay').remove();
            that.ele.find('span.tui-tooltip-error').removeClass('tui-tooltip-error');
            that.controller.errorValidations = [];
        }
    };
    var getRoomLabel = function(roomNumber) {
        var label = '';
        switch (roomNumber) {
            case 1:
                {
                    label = labels.room1;
                    break;
                }
            case 2:
                {
                    label = labels.room2;
                    break;
                }
            case 3:
                {
                    label = labels.room3;
                    break;
                }
        }
        return label;
    };
    var resetRoomNumber = function() {
        var roomNumber = 1,
            invisibleRoom = false,
            addRoomBtn = $('#searchWho').find('a.add-room');
        $.each(rooms, function(i, room) {
            room = $(room);
            room.find('header').show();
            if ($(room).is(':visible')) {
                $(room).find('h4').text(getRoomLabel(roomNumber));
                roomNumber++;
            } else {
                invisibleRoom = true;
            }
        });
        addRoomBtn[invisibleRoom ? 'show' : 'hide']();
    };
    /**
     * Seat remaining json added to element as data attribute.
     * @param  {[type]} json [description]
     * @return {[type]}      [description]
     */
    var updateSeatValidationData = function(json) {
        if (!json) {
            json = {};
        }
        that.seatValidation = json;
        if (json.maxRoomSizeMessage) {
            travellerLimitErrMsg = json.maxRoomSizeMessage;
        }
        if ($.isEmptyObject(that.formData)) {
            that.paintRooms(that.ele.data('defaultsize'));
        }
    };

    var resetRoomOccupants = function() {

        var r3Combos = room3.find('select');
        $.each(r3Combos, function(i, cb) {
            cb = $(cb);
            var id = cb.attr('id');
            if (id) {
                cb.attr(id, id.replace('3', '2'));
            }
        });

        var r2Combos = room2.find('select');
        $.each(r2Combos, function(i, cb) {
            cb = $(cb);
            var id = cb.attr('id');
            if (id) {
                cb.attr(id, id.replace('2', '3'));
            }
        });
        room3.attr('id', 'room-2');
        room2.attr('id', 'room-3');
        room2.insertAfter(room2.next());
        room2 = that.ele.find('#room-2');
        room3 = that.ele.find('#room-3');
        rooms = $('#searchWho').find('.choose-rooms').find('.room');
    };

    var validate = function(currentCb, currentRoom) {
        var totalAdults = 0,
            totalChildren = 0,
            validationFailed = false;

        if (currentCb.hasClass('returnAge')) { // age selector
            if (validateTraveller(currentCb, currentRoom) && validateAge(currentCb, currentRoom)) {
                validationFailed = !validateAll(currentCb, currentRoom);
            } else {
                validationFailed = true;
            }
        } else if (currentCb.hasClass('adult-selector')) {
            if (validateAdults(currentCb, currentRoom)) {
                validationFailed = !validateAll(currentCb, currentRoom);
            } else {
                validationFailed = true;
            }
        } else if (currentCb.hasClass('children-selector')) {
            if (validateChilren(currentCb, currentRoom)) {
                validationFailed = !validateAll(currentCb, currentRoom);
            } else {
                validationFailed = true;
            }
        } else {
            validationFailed = !validateAll(currentCb, currentRoom);
        }

        registerValidation('.tui-tooltip-inline', validationFailed, 'who');

        return validationFailed;
    };

    var validateAll = function(currentCb, currentRoom) {
        var isValid = validateTraveller(currentCb, currentRoom) && validateAdults(currentCb, currentRoom) && validateChilren(currentCb, currentRoom) && validateAge(currentCb, currentRoom) && validateSeats(currentCb, currentRoom);
        return isValid;
    };

    var validateAge = function(currentCb, currentRoom) {
        var totalAdults = parseInt(currentRoom.find('.counter-widget.adult').text(), 10),
            validationFailed = false,
            childCB,

            noOfSelect = currentCb.parents('.room').find('.return-date'),
            noofSelected = noOfSelect.find('select'),
            noOfChild = noofSelected.length,
            noOfInfants = 0;

        for (var i = 0; i < noOfChild; i++) {
            var selectedValue = $(noofSelected[i]).val();
            if (selectedValue === '-') {
                childCB = $(noofSelected[i]);
                showError('childinfantage', childCB, currentRoom, currentRoom.attr('id'));
                validationFailed = true;
                return false;
            } else if (selectedValue === '< 2' || selectedValue === '1' || selectedValue === '<2') {
                noOfInfants = noOfInfants + 1;
            }
        }


        if (noOfInfants > totalAdults) {
            validationFailed = true;
            childCB = currentCb.hasClass('returnAge') ? currentCb : noOfSelect.first();
            showError('infantage', childCB, currentRoom, currentRoom.attr('id'));
        }

        return !validationFailed;

    };
    var validateAdults = function(currentCb, currentRoom) {
        var totalAdults = 0,
            totalChildren = 0,
            validationFailed = false;
        totalAdults += parseInt(currentRoom.find('.counter-widget.adult').text(), 10);
        if (totalAdults > maxAdultLimit) {
            validationFailed = true;
            if (currentCb.prop('tagName') === 'A') {
                showError('adult', currentCb, currentRoom, currentRoom.attr('id'));
            }
            return false;
        }

        return !validationFailed;
    };
    var validateChilren = function(currentCb, currentRoom) {
        var totalAdults = 0,
            totalChildren = 0,
            validationFailed = false;

        totalChildren += parseInt(currentRoom.find('.counter-widget.child').text(), 10);
        if (totalChildren > maxChildrenLimit) {
            validationFailed = true;
            if (currentCb.prop('tagName') === 'A') {
                showError('children', currentCb, currentRoom, currentRoom.attr('id'));
            }
            return false;
        }

        return !validationFailed;
    };
    var validateTraveller = function(currentCb, currentRoom) {
        var totalAdults = 0,
            totalChildren = 0,
            validationFailed = false,
            totalTraveller = 0;
        totalAdults += parseInt(currentRoom.find('.counter-widget.adult').text(), 10);
        totalChildren += parseInt(currentRoom.find('.counter-widget.child').text(), 10);

        totalTraveller = totalAdults + totalChildren;

        if (totalTraveller > travellerLimit) {
            validationFailed = true;
            if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {
                showError('maxRoomOccupants', currentCb, currentRoom, currentRoom.attr('id'));
            }
            return false;
        }
        return !validationFailed;
    };

    var createCounter = function(room, roomData) { // function to apply widget according to room

        var roomNumber, isRoom1 = false,
            isRoom2 = false,
            isRoom3 = false;
        if (roomData.id === 'room-1') {
            roomNumber = 1;
            isRoom1 = true;
        } else if (roomData.id === 'room-2') {
            roomNumber = 2;
            isRoom2 = true;
        } else if (roomData.id === 'room-3') {
            roomNumber = 3;
            isRoom3 = true;
        }
        roomData.adultCount = roomData.adults;
        roomData.kidsCount = roomData.children;
        var templateJSON = $.extend({}, roomData, labels, {
            roomNumber: roomNumber,
            isRoom1: isRoom1,
            isRoom2: isRoom2,
            isRoom3: isRoom3
        });

        room.append(that.template(templateJSON));
        var options = {}; // obejct to pass parameters
        options.currentValue = 0;
        options.callBack = counterValueChangeCallback; // call back for form validation

        //  apply counter widget for adults according to data
        options.appendInto = room.find('.adult').closest('span');
        options.cssClass = 'adult-selector';
        options.maxParam = that.maxJSON.maxAdult;
        options.minParam = 1;

        if (roomData) {
            options.currentValue = roomData.adults;
        }
        room.find('.adult').counterWidget(options);

        // apply counter widget for children according to data
        options.appendInto = room.find('.child').closest('span');
        options.cssClass = 'children-selector';
        options.maxParam = that.maxJSON.maxKids;
        options.minParam = 0;
        if (roomData) {
            options.currentValue = roomData.children;
        }
        var kidsCounter = room.find('.child');

        kidsCounter.counterWidget(options);

        // apply counter widget for children age according to data
        updateKidsAgeWidgets(room, options, kidsCounter, roomData);
        room.show();
    };
    /**
     * Counter change callback special handling for child selector
     * @param  {[type]} event   [description]
     * @param  {[type]} obj     [description]
     * @param  {[type]} options [description]
     * @return {[type]}         [description]
     */
    var counterValueChangeCallback = function(event, obj, options) { // function to append or remove children age

        if (!obj.hasClass('children-selector')) {
            that.placeholderCallback(event, obj);
        } else if (obj.hasClass('children-selector')) {
            var room = obj.parents('.room');
            updateKidsAgeWidgets(room, options, obj);
        }
    };
    // Child age dropdown
    var childAgeComboTemplate = function(counter) {
        var $html = '<div class="age-dropdown"><select name="returningAge' + counter + '" class="returnAge">';
        $.each(that.maxJSON.kidsAgeArray, function(i, age) {
            var selected = (i === 0) ? 'selected=""' : '',
                ageValue = age;

            if (age === '1' || age === '<2' || age === '< 2') {
                ageValue = 1;
            }
            $html += '<option value="' + ageValue + '"  ' + selected + '>' + age + '</option>';
        });
        $html += '</select></div>';
        return $html;
    };

    /**
     * Create or remove the kids age widgets
     * @param  {[type]} room                  [description]
     * @param  {[type]} options               [description]
     * @param  {[type]} childrenCounterWidget [description]
     * @return {[type]}                       [description]
     */
    var updateKidsAgeWidgets = function(room, options, childrenCounterWidget, roomData) {
        options.cssClass = 'returnAge';
        options.maxParam = that.maxJSON.kidsAgeArray;

        // room.find('.child-selector').remove();
        var existingChildAgeDD = room.find('select');
        var inputARR = [];
        options.currentValue = that.maxJSON.kidsAgeArray[0];
        var kidsCount = 1 * room.find('em.counter-widget.child').text();
        if (kidsCount === 0) {
            room.find('.return-date').hide();
        } else {
            room.find('.return-date').show();
        }
        var delta = kidsCount - existingChildAgeDD.length;

        if (delta > 0) {
            addKids(room, delta, existingChildAgeDD.length, roomData);
        } else if (delta < 0) {
            removeKids(room, delta);
        }

        if (roomData) {
            $.each(room.find('.return-date').find('select'), function(i, select) {
                var selectedAge = roomData.childAgeList[i];
                if (selectedAge === 1 || selectedAge === '<2' || selectedAge === '< 2') {
                    selectedAge = 1;
                }
                $(select).val(selectedAge);
            });
        }

        var elem = room.find('.return-date').find('select').first();
        if (!elem.length) {
            elem = room.find('a.plus.children-selector');
        }

        that.placeholderCallback(null, elem);
    };
    /**
     * Add Age DD
     * @param {[type]} room  [description]
     * @param {[type]} delta [description]
     */
    var addKids = function(room, delta, existingChilds, roomData) {
        for (var i = 0; i < delta; i++) {
            var kCount;
            if (roomData) {
                kCount = i + 1;
            } else {
                kCount = existingChilds + 1;
            }

            var ageContainerHTML = '<div class="drop-down child-selector right col-xs-12">	<label class="col-sm-6 col-md-3" >' + labels.child + ' ' + kCount +
                '  </label>' + childAgeComboTemplate(i) + '</div>';
            room.find('.return-date').append(ageContainerHTML);
        }
    };
    /**
     * Remove Age DD
     * @param  {[type]} room  [description]
     * @param  {[type]} delta [description]
     * @return {[type]}       [description]
     */
    var removeKids = function(room, delta) {
        room.find('.return-date').find('.child-selector').slice(delta).remove();
    };
    /**
     * Validate against the max seat remaining
     * @param  {[type]} currentCb   [description]
     * @param  {[type]} currentRoom [description]
     * @return {[type]}             [description]
     */
    var validateSeats = function(currentCb, currentRoom) {

        var totalAdults = 0,
            totalNonInfants = 0,
            room1Total = 0,
            room2Total = 0,
            room3Total = 0,

            validationFailed = false;
        if (typeof that.seatValidation === 'undefined') {
            return !validationFailed;
        }
        $.each(rooms, function(i, room) {
            var $room = $(room);
            if ($room.is(':visible')) {
                var adults = parseInt($room.find('.counter-widget.adult').text(), 10),
                    nonInfants = countNonInfants($room),
                    roomTotal = adults + nonInfants;

                totalAdults += adults;
                totalNonInfants += nonInfants;

                if (i === 0) {
                    room1Total = roomTotal;
                } else if (i === 1) {
                    room2Total = roomTotal;
                } else if (i === 2) {
                    room3Total = roomTotal;

                }
            }
        });

        var totalTravellers = totalAdults + totalNonInfants;
        if (that.seatValidation.seatAndRoomValidation && that.seatValidation.seatAndRoomValidation.length) {

            var adultsInRoom = parseInt(currentRoom.find('.counter-widget.adult').text(), 10),
                childrenInRoom = parseInt(currentRoom.find('.counter-widget.child').text(), 10),
                totalRoomies = adultsInRoom + childrenInRoom;

            var routeAvaliable = false;
            var roomFullError = false;
            var seatFullError = false;
            var lastRoomFullError = false;

            $.each(that.seatValidation.seatAndRoomValidation, function(i, route) {
                var currentRootAvl = true;
                if (route.seatsAvailable >= totalTravellers) {

                    if (route.maxRoomSize >= room1Total) {
                        if (route.maxRoomSize >= room2Total) {
                            if (route.maxRoomSize >= room3Total) {
                                // All Good in this route
                                roomFullError = false;
                            } else {
                                roomFullError = true;
                                currentRootAvl = false; // HERE

                            }
                        } else {
                            roomFullError = true;
                            currentRootAvl = false; // HERE

                        }
                    } else {
                        roomFullError = true;
                        currentRootAvl = false; // HERE

                    }
                } else {
                    currentRootAvl = false;
                }
                if (currentRootAvl) {
                    routeAvaliable = true;
                    return false;
                }
            });

            if (!routeAvaliable) {
                validationFailed = true;
                if (roomFullError) {
                    if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {
                        showError('maxtraveller', currentCb, currentRoom, currentRoom.attr('id'));
                    }
                } else {
                    if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {
                        showError('seatFull', currentCb, currentRoom, currentRoom.attr('id'));
                    }
                }
            }
        } else if (that.seatValidation.avaliableSeats && totalTravellers > that.seatValidation.avaliableSeats) { // TODO remove it
            validationFailed = true;
            if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {
                showError('seatFull', currentCb, currentRoom, currentRoom.attr('id'));
            }
        } else {
            if (currentCb.prop('tagName') === 'A' || currentCb.prop('tagName') === 'SELECT') {
                showError('seatFull', currentCb, currentRoom, currentRoom.attr('id'));
            }
            validationFailed = true;
        }

        return !validationFailed;
    };

    var countNonInfants = function(room) {
        var childSelect = room.find('em.counter-widget.child');
        var count = 0;
        if (parseInt(childSelect.text(), 10) > 0) {
            $.each(room.find('select.returnAge'), function(i, dd) {
                var age = $(dd).val();
                if (!isNaN(age) && parseInt(age, 10) >= 2) {
                    count++;
                }
            });
        }
        return count;
    };

    var showError = function(type, currentCb, container, roomid) {

        var elem = currentCb,
            message = '',
            childrenSelects,
            firstValidSelect = [],
            cssClass = roomid + ' searchwho ',
            highlightElement = null,
            infoIcon = '<i class="icon-bubble-important"></i>';

        switch (type) {
            case 'adult':
                {
                    message = customMessage(adultErrorMessage, infoIcon);
                    cssClass = cssClass + ' adult ';
                    if (currentCb.hasClass('adult-selector')) {
                        elem = currentCb;
                    } else {
                        elem = container.find('.adult-selector').first();
                    }
                    break;
                }
            case 'children':
                {
                    message = customMessage(childrenLimitErrMessage, infoIcon);
                    cssClass = cssClass + ' children ';
                    if (currentCb.hasClass('children-selector')) {
                        elem = currentCb;
                    } else {
                        childrenSelects = container.find('.counter-widget.child');
                        $.each(childrenSelects, function(c, cItem) {
                            if ($(cItem).is(':visible') && $(cItem).text()) {
                                firstValidSelect = $(cItem);
                                return false;
                            }
                        });
                        if (!firstValidSelect.length) {
                            firstValidSelect = container.find('.child:visible').first();
                        }
                    }
                    break;
                }
            case 'maxRoomOccupants':
                {
                    message = customMessage(maxRoomOccupantMsg, infoIcon);
                    if (currentCb.hasClass('returnAge')) {
                        elem = currentCb = container.find('.children-selector');
                    }
                    cssClass = cssClass + ((currentCb.hasClass('adult-selector')) ? ' adult ' : (currentCb.hasClass('children-selector')) ? ' children ' : ' common ');
                    break;
                }
            case 'maxtraveller':
                {
                    message = customMessage(travellerLimitErrMsg, infoIcon);
                    if (currentCb.hasClass('returnAge')) {
                        elem = currentCb = container.find('.children-selector');
                    }
                    cssClass = cssClass + ((currentCb.hasClass('adult-selector')) ? ' adult ' : (currentCb.hasClass('children-selector')) ? ' children ' : ' common ');
                    break;
                }
            case 'infantage':
                {
                    message = customMessage(infantErrMsg, infoIcon);
                    cssClass = cssClass + ' childage ' + elem.data('column');
                    break;
                }
            case 'seatFull':
                {
                    message = customMessage(that.seatValidation.seatFullMessage, infoIcon);
                    if (currentCb.hasClass('returnAge')) {
                        elem = currentCb = container.find('.children-selector');
                    }
                    cssClass = cssClass + ((currentCb.hasClass('adult-selector')) ? ' adult ' : (currentCb.hasClass('children-selector')) ? ' children ' : ' common ');
                    break;
                }
            case 'childinfantage':
                {
                    message = customMessage(infantAgeErrMessage, infoIcon);
                    cssClass = cssClass + ' common';
                    if (currentCb.hasClass('returnAge')) {
                        currentCb.addClass(elem.data('column'));
                        elem = currentCb;
                    } else {
                        childrenSelects = container.find('.children-selector');

                        $.each(childrenSelects, function(c, cItem) {
                            if ($(cItem).is(':visible') && $(cItem).text()) {
                                firstValidSelect = $(cItem);
                                return false;
                            }
                        });
                        if (!firstValidSelect.length) {
                            firstValidSelect = container.find('.children-selector:visible').first();
                        }
                    }
                }
        }

        var appendAfter = container.find('ul');

        if (type === 'infantage' || type === 'childinfantage') {
            appendAfter = container.find('.return-date');
            TUIUtil.showInlineMessage(appendAfter, {
                message: message,
                cssClass: cssClass,
                highlightElement: elem.closest('span.widspan'),
                left: container.offset().left
            }, true);

        } else {
            var appendTo = getTargetElememt(currentCb, container);
            TUIUtil.showInlineMessage(appendTo, {
                message: message,
                cssClass: cssClass,
                highlightElement: elem.closest('span.widspan'),
                left: container.offset().left
            }, true);
        }

        that.ele.find('.add-room').addClass('disabled');
    };

    var customMessage = function(msg, icon) {
        return '<p>' + msg + '</p>' + icon;
    };

    var getRoomCount = function() {
        var roomCount = 0;
        var roomEle = that.ele.find('.choose-rooms').find('.room');
        roomEle.each(function() {
            var adultCount = parseInt($(this).find('.counter-widget.adult').text(), 10);
            if (adultCount > 0) {
                roomCount++;
            }
        });
        return roomCount;
    };
    var getTargetElememt = function(currentCb, container) {
        var targetElem = container.find('ul');
        if (currentCb && currentCb.length) {
            targetElem = currentCb.closest('li');

        }
        return targetElem;
    };

    /**
     * If validation failed put the error in array else cleanup the
     * item from array and respective tooltip
     * @param  {[type]} selector [description]
     * @param  {[type]} failed   [description]
     * @param  {[type]} type     [description]
     * @return {[type]}          [description]
     */
    var registerValidation = function(selector, failed, type) {
        if (!failed) {
            that.cleanupTooltips(selector);
            var idx = existingValidationIndex(type);
            if (idx !== -1) {
                that.controller.errorValidations.splice(idx);
            }
        } else {
            if (existingValidationIndex(type) === -1) {
                that.controller.errorValidations.push({
                    panelId: '#who',
                    type: type
                });
            }
        }
    };
    /**
     * Existing validation if already present return its index.
     * @param  {[type]} type [description]
     * @return {[type]}      [description]
     */
    var existingValidationIndex = function(type) {
        var idx = -1;
        $.each(that.controller.errorValidations, function(i, item) {
            if (item.type === type) {
                idx = i;
                return false;
            }
        });
        return idx;
    };


    //  START:- get who panel details
    /**
     * Get the current room values
     */
    var getRoomValues = function() {
        var roomArray = [];
        $('#searchWho .rooms-content .room').each(function(c) {

            var childAgeList = [],
                $room = $(this),
                roomId = 'room-' + (c + 1);
            var adultCounter = $room.find('.adult');

            if (adultCounter.length === 0) {
                return true;
            }

            var adultVal = $room.find('.counter-widget.adult').text(),
                childVal = $room.find('.counter-widget.child').text(),
                roomData = {};

            $room.find('.return-date select.returnAge').each(function() {
                childAgeList.push($(this).val());
            });

            roomData = {
                id: roomId,
                childAgeList: childAgeList,
                children: childVal,
                adults: adultVal
            };
            roomArray.push(roomData);
        });
        return roomArray;
    };

    var disableRooms = function(currentRoom, disable) {
        var siblings = currentRoom.siblings();
        if (disable) {
            siblings.addClass('disable');
            if (siblings.find('.overlay').length === 0) {
                siblings.append('<div class="overlay" />');
            }
        } else {
            siblings.removeClass('disable');
            siblings.find('.overlay').remove();
        }
    };

    var dateChangeEvent = function() {
        partyFlyout.on('click', '.change-date-partysize', function(eve) {
            that.controller.searchWhen.resetDates();
            that.controller.searchWhen.resetDuration();
            that.cleanupTooltips('.tui-tooltip-inline');
            that.setFieldValue();
            setTimeout(function() {
                $('#when').trigger('click');
            }, 100);

        });
    };

    var manageRoomLabel = function(numberOfRooms) {
        var firstRoomHeader = room1.find('.container-roomname h4'),
            $roomName = $('.container-roomname'),
            $breakPoint = TUIUtil.getCurrentBreakPoint();

        firstRoomHeader.removeClass('hidden');
        room1.removeClass('firstRoom');

        if (numberOfRooms && numberOfRooms === 1) {
            room1.addClass('firstRoom');

            if ($breakPoint !== 'xs') {
                firstRoomHeader.addClass('hidden');
            }


        } else if (numberOfRooms > 2) { //  more than 2 ie 3
            $roomName.removeClass('hidden');

        } else { // 2
            $roomName.removeClass('hidden');
            $roomName.find('header').show();

        }

    };

    var roomHeaderAccordion = function() {
        partyFlyout.find('.room').on('click', 'header', function(e) {
            if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                return;
            }
            e.preventDefault();
            var $this = $(this);
            $this.parents('.room').toggleClass('collapsed');
        });
    };

    for (var key in methods) {
        SearchWho.prototype[key] = methods[key];
    }

    return SearchWho;
});

/*!
 * hoverIntent v1.8.0 // 2014.06.29 // jQuery v1.9.1+
 * http://cherne.net/brian/resources/jquery.hoverIntent.html
 *
 * You may use hoverIntent under the terms of the MIT license. Basically that
 * means you are free to use hoverIntent as long as this header is left intact.
 * Copyright 2007, 2014 Brian Cherne
 */

/* hoverIntent is similar to jQuery's built-in "hover" method except that
 * instead of firing the handlerIn function immediately, hoverIntent checks
 * to see if the user's mouse has slowed down (beneath the sensitivity
 * threshold) before firing the event. The handlerOut function is only
 * called after a matching handlerIn.
 *
 * // basic usage ... just like .hover()
 * .hoverIntent( handlerIn, handlerOut )
 * .hoverIntent( handlerInOut )
 *
 * // basic usage ... with event delegation!
 * .hoverIntent( handlerIn, handlerOut, selector )
 * .hoverIntent( handlerInOut, selector )
 *
 * // using a basic configuration object
 * .hoverIntent( config )
 *
 * @param  handlerIn   function OR configuration object
 * @param  handlerOut  function OR selector for delegation OR undefined
 * @param  selector    selector OR undefined
 * @author Brian Cherne <brian(at)cherne(dot)net>
 */
(function($) {
    $.fn.hoverIntent = function(handlerIn, handlerOut, selector) {

        // default configuration values
        var cfg = {
            interval: 100,
            sensitivity: 6,
            timeout: 0
        };

        if (typeof handlerIn === "object") {
            cfg = $.extend(cfg, handlerIn);
        } else if ($.isFunction(handlerOut)) {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerOut,
                selector: selector
            });
        } else {
            cfg = $.extend(cfg, {
                over: handlerIn,
                out: handlerIn,
                selector: handlerOut
            });
        }

        // instantiate variables
        // cX, cY = current X and Y position of mouse, updated by mousemove event
        // pX, pY = previous X and Y position of mouse, set by mouseover and polling interval
        var cX, cY, pX, pY;

        // A private function for getting mouse position
        var track = function(ev) {
            cX = ev.pageX;
            cY = ev.pageY;
        };

        // A private function for comparing current and previous mouse position
        var compare = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            // compare mouse positions to see if they've crossed the threshold
            if (Math.sqrt((pX - cX) * (pX - cX) + (pY - cY) * (pY - cY)) < cfg.sensitivity) {
                $(ob).off("mousemove.hoverIntent", track);
                // set hoverIntent state to true (so mouseOut can be called)
                ob.hoverIntent_s = true;
                return cfg.over.apply(ob, [ev]);
            } else {
                // set previous coordinates for next time
                pX = cX;
                pY = cY;
                // use self-calling timeout, guarantees intervals are spaced out properly (avoids JavaScript timer bugs)
                ob.hoverIntent_t = setTimeout(function() {
                    compare(ev, ob);
                }, cfg.interval);
            }
        };

        // A private function for delaying the mouseOut function
        var delay = function(ev, ob) {
            ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            ob.hoverIntent_s = false;
            return cfg.out.apply(ob, [ev]);
        };

        // A private function for handling mouse 'hovering'
        var handleHover = function(e) {
            // copy objects to be passed into t (required for event object to be passed in IE)
            var ev = $.extend({}, e);
            var ob = this;

            // cancel hoverIntent timer if it exists
            if (ob.hoverIntent_t) {
                ob.hoverIntent_t = clearTimeout(ob.hoverIntent_t);
            }

            // if e.type === "mouseenter"
            if (e.type === "mouseenter") {
                // set "previous" X and Y position based on initial entry point
                pX = ev.pageX;
                pY = ev.pageY;
                // update "current" X and Y position based on mousemove
                $(ob).on("mousemove.hoverIntent", track);
                // start polling interval (self-calling timeout) to compare mouse coordinates over time
                if (!ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        compare(ev, ob);
                    }, cfg.interval);
                }

                // else e.type == "mouseleave"
            } else {
                // unbind expensive mousemove event
                $(ob).off("mousemove.hoverIntent", track);
                // if hoverIntent state is true, then call the mouseOut function after the specified delay
                if (ob.hoverIntent_s) {
                    ob.hoverIntent_t = setTimeout(function() {
                        delay(ev, ob);
                    }, cfg.timeout);
                }
            }
        };

        // listen for mouseenter and mouseleave
        return this.on({
            'mouseenter.hoverIntent': handleHover,
            'mouseleave.hoverIntent': handleHover
        }, cfg.selector);
    };
})(jQuery);
define("jqueryhoverIntent", function() {});

/*!
 * jQuery UI Core 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/core', ["jquery"], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    // $.ui might exist from components with no dependencies, e.g., $.ui.position
    $.ui = $.ui || {};

    $.extend($.ui, {
        version: "1.11.0",

        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });

    // plugins
    $.fn.extend({
        scrollParent: function() {
            var position = this.css("position"),
                excludeStaticParent = position === "absolute",
                scrollParent = this.parents().filter(function() {
                    var parent = $(this);
                    if (excludeStaticParent && parent.css("position") === "static") {
                        return false;
                    }
                    return (/(auto|scroll)/).test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
                }).eq(0);

            return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },

        uniqueId: (function() {
            var uuid = 0;

            return function() {
                return this.each(function() {
                    if (!this.id) {
                        this.id = "ui-id-" + (++uuid);
                    }
                });
            };
        })(),

        removeUniqueId: function() {
            return this.each(function() {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ?
                !element.disabled :
                "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
            !$(element).parents().addBack().filter(function() {
                return $.css(this, "visibility") === "hidden";
            }).length;
    }

    $.extend($.expr[":"], {
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function(dataName) {
                return function(elem) {
                    return !!$.data(elem, dataName);
                };
            }) :
            // support: jQuery <1.8
            function(elem, i, match) {
                return !!$.data(elem, match[3]);
            },

        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },

        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"),
                isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support: jQuery <1.8
    if (!$("<a>").outerWidth(1).jquery) {
        $.each(["Width", "Height"], function(i, name) {
            var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                type = name.toLowerCase(),
                orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };

            function reduce(elem, size, border, margin) {
                $.each(side, function() {
                    size -= parseFloat($.css(elem, "padding" + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, "margin" + this)) || 0;
                    }
                });
                return size;
            }

            $.fn["inner" + name] = function(size) {
                if (size === undefined) {
                    return orig["inner" + name].call(this);
                }

                return this.each(function() {
                    $(this).css(type, reduce(this, size) + "px");
                });
            };

            $.fn["outer" + name] = function(size, margin) {
                if (typeof size !== "number") {
                    return orig["outer" + name].call(this, size);
                }

                return this.each(function() {
                    $(this).css(type, reduce(this, size, true, margin) + "px");
                });
            };
        });
    }

    // support: jQuery <1.8
    if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
            return this.add(selector == null ?
                this.prevObject : this.prevObject.filter(selector)
            );
        };
    }

    // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
        $.fn.removeData = (function(removeData) {
            return function(key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        })($.fn.removeData);
    }

    // deprecated
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());

    $.fn.extend({
        focus: (function(orig) {
            return function(delay, fn) {
                return typeof delay === "number" ?
                    this.each(function() {
                        var elem = this;
                        setTimeout(function() {
                            $(elem).focus();
                            if (fn) {
                                fn.call(elem);
                            }
                        }, delay);
                    }) :
                    orig.apply(this, arguments);
            };
        })($.fn.focus),

        disableSelection: (function() {
            var eventType = "onselectstart" in document.createElement("div") ?
                "selectstart" :
                "mousedown";

            return function() {
                return this.bind(eventType + ".ui-disableSelection", function(event) {
                    event.preventDefault();
                });
            };
        })(),

        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        },

        zIndex: function(zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]),
                    position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        }
    });

    // $.ui.plugin is deprecated. Use $.widget() extensions instead.
    $.ui.plugin = {
        add: function(module, option, set) {
            var i,
                proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([option, set[i]]);
            }
        },
        call: function(instance, name, args, allowDisconnected) {
            var i,
                set = instance.plugins[name];

            if (!set) {
                return;
            }

            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }

            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };

}));

/*!
 * jQuery UI Datepicker 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/datepicker', [
            "jquery",
            "./core"
        ], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    $.extend($.ui, {
        datepicker: {
            version: "1.11.0"
        }
    });

    var datepicker_instActive;

    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            // Ignore z-index if position is set to a value where z-index is ignored by the browser
            // This makes behavior of this function consistent across browsers
            // WebKit always returns auto if the element is positioned
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
                // IE returns 0 when zIndex is not specified
                // other browsers return a string
                // we ignore the case of nested elements with an explicit value of 0
                // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                value = parseInt(elem.css("zIndex"), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }

        return 0;
    }
    /* Date picker manager.
       Use the singleton instance of this class, $.datepicker, to interact with the date picker.
       Settings for (groups of) date pickers are maintained in an instance object,
       allowing multiple different settings on the same page. */

    function Datepicker() {
        this._curInst = null; // The current instance in use
        this._keyEvent = false; // If the last event was a key event
        this._disabledInputs = []; // List of date picker inputs that have been disabled
        this._datepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
        this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
        this._appendClass = "ui-datepicker-append"; // The name of the append marker class
        this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
        this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
        this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
        this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
        this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
        this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
        this.regional = []; // Available regional settings, indexed by language code
        this.regional[""] = { // Default regional settings
            closeText: "Done", // Display text for close link
            prevText: "Prev", // Display text for previous month link
            nextText: "Next", // Display text for next month link
            currentText: "Today", // Display text for current month link
            monthNames: ["January", "February", "March", "April", "May", "June",
                "July", "August", "September", "October", "November", "December"
            ], // Names of months for drop-down and formatting
            monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
            dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
            dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
            dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], // Column headings for days starting at Sunday
            weekHeader: "Wk", // Column header for week of the year
            dateFormat: "mm/dd/yy", // See format options on parseDate
            firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
            isRTL: false, // True if right-to-left language, false if left-to-right
            showMonthAfterYear: false, // True if the year select precedes month, false for month then year
            yearSuffix: "" // Additional text to append to the year in the month headers
        };
        this._defaults = { // Global defaults for all the date picker instances
            showOn: "focus", // "focus" for popup on focus,
            // "button" for trigger button, or "both" for either
            showAnim: "fadeIn", // Name of jQuery animation for popup
            showOptions: {}, // Options for enhanced animations
            defaultDate: null, // Used when field is blank: actual date,
            // +/-number for offset from today, null for today
            appendText: "", // Display text following the input box, e.g. showing the format
            buttonText: "...", // Text for trigger button
            buttonImage: "", // URL for trigger button image
            buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
            hideIfNoPrevNext: false, // True to hide next/previous month links
            // if not applicable, false to just disable them
            navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
            gotoCurrent: false, // True if today link goes back to current selection instead
            changeMonth: false, // True if month can be selected directly, false if only prev/next
            changeYear: false, // True if year can be selected directly, false if only prev/next
            yearRange: "c-10:c+10", // Range of years to display in drop-down,
            // either relative to today's year (-nn:+nn), relative to currently displayed year
            // (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
            showOtherMonths: false, // True to show dates in other months, false to leave blank
            selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
            showWeek: false, // True to show week of the year, false to not show it
            calculateWeek: this.iso8601Week, // How to calculate the week of the year,
            // takes a Date and returns the number of the week for it
            shortYearCutoff: "+10", // Short year values < this are in the current century,
            // > this are in the previous century,
            // string value starting with "+" for current year + value
            minDate: null, // The earliest selectable date, or null for no limit
            maxDate: null, // The latest selectable date, or null for no limit
            duration: "fast", // Duration of display/closure
            beforeShowDay: null, // Function that takes a date and returns an array with
            // [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
            // [2] = cell title (optional), e.g. $.datepicker.noWeekends
            beforeShow: null, // Function that takes an input field and
            // returns a set of custom settings for the date picker
            onSelect: null, // Define a callback function when a date is selected
            onChangeMonthYear: null, // Define a callback function when the month or year is changed
            onClose: null, // Define a callback function when the datepicker is closed
            numberOfMonths: 1, // Number of months to show at a time
            showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
            stepMonths: 1, // Number of months to step back/forward
            stepBigMonths: 12, // Number of months to step back/forward for the big links
            altField: "", // Selector for an alternate field to store selected dates into
            altFormat: "", // The date format to use for the alternate field
            constrainInput: true, // The input is constrained by the current date format
            showButtonPanel: false, // True to show button panel, false to not show it
            autoSize: false, // True to size the input for the date format, false to leave as is
            disabled: false // The initial disabled state
        };
        $.extend(this._defaults, this.regional[""]);
        this.regional.en = $.extend(true, {}, this.regional[""]);
        this.regional["en-US"] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }

    $.extend(Datepicker.prototype, {
        /* Class name added to elements to indicate already configured with a date picker. */
        markerClassName: "hasDatepicker",

        //Keep track of the maximum number of rows displayed (see #7043)
        maxRows: 4,

        // TODO rename to "widget" when switching to widget factory
        _widgetDatepicker: function() {
            return this.dpDiv;
        },

        /* Override the default settings for all instances of the date picker.
         * @param  settings  object - the new settings to use as defaults (anonymous object)
         * @return the manager object
         */
        setDefaults: function(settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         * @param  settings  object - the new settings to use for this date picker instance (anonymous)
         */
        _attachDatepicker: function(target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = (nodeName === "div" || nodeName === "span");
            if (!target.id) {
                this.uuid += 1;
                target.id = "dp" + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === "input") {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },

        /* Create a new instance object. */
        _newInst: function(target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
            return {
                id: id,
                input: target, // associated target
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0, // current selection
                drawMonth: 0,
                drawYear: 0, // month being drawn
                inline: inline, // is datepicker inline or not
                dpDiv: (!inline ? this.dpDiv : // presentation div
                    datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
            };
        },

        /* Attach the date picker to an input field. */
        _connectDatepicker: function(target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).
            keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, "datepicker", inst);
            //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },

        /* Make attachments based on settings. */
        _attachments: function(input, inst) {
            var showOn, buttonText, buttonImage,
                appendText = this._get(inst, "appendText"),
                isRTL = this._get(inst, "isRTL");

            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
                input[isRTL ? "before" : "after"](inst.append);
            }

            input.unbind("focus", this._showDatepicker);

            if (inst.trigger) {
                inst.trigger.remove();
            }

            showOn = this._get(inst, "showOn");
            if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
                input.focus(this._showDatepicker);
            }
            if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
                buttonText = this._get(inst, "buttonText");
                buttonImage = this._get(inst, "buttonImage");
                inst.trigger = $(this._get(inst, "buttonImageOnly") ?
                    $("<img/>").addClass(this._triggerClass).attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    }) :
                    $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
                        src: buttonImage,
                        alt: buttonText,
                        title: buttonText
                    })));
                input[isRTL ? "before" : "after"](inst.trigger);
                inst.trigger.click(function() {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },

        /* Apply the maximum length for the date format. */
        _autoSize: function(inst) {
            if (this._get(inst, "autoSize") && !inst.inline) {
                var findMax, max, maxI, i,
                    date = new Date(2009, 12 - 1, 20), // Ensure double digits
                    dateFormat = this._get(inst, "dateFormat");

                if (dateFormat.match(/[DM]/)) {
                    findMax = function(names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
                        "monthNames" : "monthNamesShort"))));
                    date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
                        "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
                }
                inst.input.attr("size", this._formatDate(inst, date).length);
            }
        },

        /* Attach an inline date picker to a div. */
        _inlineDatepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, "datepicker", inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
            // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
            inst.dpDiv.css("display", "block");
        },

        /* Pop-up the date picker in a "dialog" box.
         * @param  input element - ignored
         * @param  date	string or Date - the initial date to display
         * @param  onSelect  function - the function to call when a date is selected
         * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
         * @param  pos int[2] - coordinates for the dialog's position within the screen or
         *					event - with x/y coordinates or
         *					leave empty for default (screen centre)
         * @return the manager object
         */
        _dialogDatepicker: function(input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY,
                inst = this._dialogInst; // internal instance

            if (!inst) {
                this.uuid += 1;
                id = "dp" + this.uuid;
                this._dialogInput = $("<input type='text' id='" + id +
                    "' style='position: absolute; top: -100px; width: 0px;'/>");
                this._dialogInput.keydown(this._doKeyDown);
                $("body").append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], "datepicker", inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
            this._dialogInput.val(date);

            this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = // should use actual width/height below
                    [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
            }

            // move input on screen for focus, but hidden behind dialog
            this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], "datepicker", inst);
            return this;
        },

        /* Detach a datepicker from its control.
         * @param  target	element - the target input field or division or span
         */
        _destroyDatepicker: function(target) {
            var nodeName,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, "datepicker");
            if (nodeName === "input") {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).
                unbind("focus", this._showDatepicker).
                unbind("keydown", this._doKeyDown).
                unbind("keypress", this._doKeyPress).
                unbind("keyup", this._doKeyUp);
            } else if (nodeName === "div" || nodeName === "span") {
                $target.removeClass(this.markerClassName).empty();
            }
        },

        /* Enable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _enableDatepicker: function(target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = false;
                inst.trigger.filter("button").
                each(function() {
                    this.disabled = false;
                }).end().
                filter("img").css({
                    opacity: "1.0",
                    cursor: ""
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().removeClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", false);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) {
                    return (value === target ? null : value);
                }); // delete entry
        },

        /* Disable the date picker to a jQuery selection.
         * @param  target	element - the target input field or division or span
         */
        _disableDatepicker: function(target) {
            var nodeName, inline,
                $target = $(target),
                inst = $.data(target, "datepicker");

            if (!$target.hasClass(this.markerClassName)) {
                return;
            }

            nodeName = target.nodeName.toLowerCase();
            if (nodeName === "input") {
                target.disabled = true;
                inst.trigger.filter("button").
                each(function() {
                    this.disabled = true;
                }).end().
                filter("img").css({
                    opacity: "0.5",
                    cursor: "default"
                });
            } else if (nodeName === "div" || nodeName === "span") {
                inline = $target.children("." + this._inlineClass);
                inline.children().addClass("ui-state-disabled");
                inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
                prop("disabled", true);
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) {
                    return (value === target ? null : value);
                }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = target;
        },

        /* Is the first field in a jQuery collection disabled as a datepicker?
         * @param  target	element - the target input field or division or span
         * @return boolean - true if disabled, false if enabled
         */
        _isDisabledDatepicker: function(target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },

        /* Retrieve the instance data for the target control.
         * @param  target  element - the target input field or division or span
         * @return  object - the associated instance data
         * @throws  error if a jQuery problem getting data
         */
        _getInst: function(target) {
            try {
                return $.data(target, "datepicker");
            } catch (err) {
                throw "Missing instance data for this datepicker";
            }
        },

        /* Update or retrieve the settings for a date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         * @param  name	object - the new settings to update or
         *				string - the name of the setting to change or retrieve,
         *				when retrieving also "all" for all instance settings or
         *				"defaults" for all global defaults
         * @param  value   any - the new value for the setting
         *				(omit if above is an object or to retrieve a value)
         */
        _optionDatepicker: function(target, name, value) {
            var settings, date, minDate, maxDate,
                inst = this._getInst(target);

            if (arguments.length === 2 && typeof name === "string") {
                return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
                    (inst ? (name === "all" ? $.extend({}, inst.settings) :
                        this._get(inst, name)) : null));
            }

            settings = name || {};
            if (typeof name === "string") {
                settings = {};
                settings[name] = value;
            }

            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }

                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, "min");
                maxDate = this._getMinMaxDate(inst, "max");
                datepicker_extendRemove(inst.settings, settings);
                // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ("disabled" in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },

        // change method deprecated
        _changeDatepicker: function(target, name, value) {
            this._optionDatepicker(target, name, value);
        },

        /* Redraw the date picker attached to an input field or division.
         * @param  target  element - the target input field or division or span
         */
        _refreshDatepicker: function(target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },

        /* Set the dates for a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  date	Date - the new date
         */
        _setDateDatepicker: function(target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },

        /* Get the date(s) for the first entry in a jQuery selection.
         * @param  target element - the target input field or division or span
         * @param  noDefault boolean - true if no default date is to be used
         * @return Date - the current date
         */
        _getDateDatepicker: function(target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return (inst ? this._getDate(inst) : null);
        },

        /* Handle keystrokes. */
        _doKeyDown: function(event) {
            var onSelect, dateStr, sel,
                inst = $.datepicker._getInst(event.target),
                handled = true,
                isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                    case 9:
                        $.datepicker._hideDatepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13:
                        sel = $("td." + $.datepicker._dayOverClass + ":not(." +
                            $.datepicker._currentClass + ")", inst.dpDiv);
                        if (sel[0]) {
                            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                        }

                        onSelect = $.datepicker._get(inst, "onSelect");
                        if (onSelect) {
                            dateStr = $.datepicker._formatDate(inst);

                            // trigger custom callback
                            onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
                        } else {
                            $.datepicker._hideDatepicker();
                        }

                        return false; // don't submit the form
                    case 27:
                        $.datepicker._hideDatepicker();
                        break; // hide on escape
                    case 33:
                        $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            -$.datepicker._get(inst, "stepBigMonths") :
                            -$.datepicker._get(inst, "stepMonths")), "M");
                        break; // previous month/year on page up/+ ctrl
                    case 34:
                        $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                            +$.datepicker._get(inst, "stepBigMonths") :
                            +$.datepicker._get(inst, "stepMonths")), "M");
                        break; // next month/year on page down/+ ctrl
                    case 35:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._clearDate(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // clear on ctrl or command +end
                    case 36:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._gotoToday(event.target);
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // current on ctrl or command +home
                    case 37:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // -1 day on ctrl or command +left
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                -$.datepicker._get(inst, "stepBigMonths") :
                                -$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +left on Mac
                        break;
                    case 38:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, -7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // -1 week on ctrl or command +up
                    case 39:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        // +1 day on ctrl or command +right
                        if (event.originalEvent.altKey) {
                            $.datepicker._adjustDate(event.target, (event.ctrlKey ?
                                +$.datepicker._get(inst, "stepBigMonths") :
                                +$.datepicker._get(inst, "stepMonths")), "M");
                        }
                        // next month/year on alt +right
                        break;
                    case 40:
                        if (event.ctrlKey || event.metaKey) {
                            $.datepicker._adjustDate(event.target, +7, "D");
                        }
                        handled = event.ctrlKey || event.metaKey;
                        break; // +1 week on ctrl or command +down
                    default:
                        handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }

            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Filter entered characters - based on date format. */
        _doKeyPress: function(event) {
            var chars, chr,
                inst = $.datepicker._getInst(event.target);

            if ($.datepicker._get(inst, "constrainInput")) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
            }
        },

        /* Synchronise manual entry and field/alternate field. */
        _doKeyUp: function(event) {
            var date,
                inst = $.datepicker._getInst(event.target);

            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), (inst.input ? inst.input.val() : null),
                        $.datepicker._getFormatConfig(inst));

                    if (date) { // only if valid
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {}
            }
            return true;
        },

        /* Pop-up the date picker for a given input field.
         * If false returned from beforeShow event handler do not show.
         * @param  input  element - the input field attached to the date picker or
         *					event - if triggered by focus
         */
        _showDatepicker: function(input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
                input = $("input", input.parentNode)[0];
            }

            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
                return;
            }

            var inst, beforeShow, beforeShowSettings, isFixed,
                offset, showAnim, duration;

            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }

            beforeShow = $.datepicker._get(inst, "beforeShow");
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);

            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);

            if ($.datepicker._inDialog) { // hide cursor
                input.value = "";
            }
            if (!$.datepicker._pos) { // position below input
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight; // add the height
            }

            isFixed = false;
            $(input).parents().each(function() {
                isFixed |= $(this).css("position") === "fixed";
                return !isFixed;
            });

            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            //to avoid flashes on Firefox
            inst.dpDiv.empty();
            // determine sizing offscreen
            inst.dpDiv.css({
                position: "absolute",
                display: "block",
                top: "-1000px"
            });
            $.datepicker._updateDatepicker(inst);
            // fix width for dynamic number of date pickers
            // and adjust position before showing
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: ($.datepicker._inDialog && $.blockUI ?
                    "static" : (isFixed ? "fixed" : "absolute")),
                display: "none",
                left: offset.left + "px",
                top: offset.top + "px"
            });

            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, "showAnim");
                duration = $.datepicker._get(inst, "duration");
                inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;

                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
                } else {
                    inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
                }

                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }

                $.datepicker._curInst = inst;
            }
        },

        /* Generate the date picker content. */
        _updateDatepicker: function(inst) {
            this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
            datepicker_instActive = inst; // for delegate hover events
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            inst.dpDiv.find("." + this._dayOverClass + " a");

            var origyearshtml,
                numMonths = this._getNumberOfMonths(inst),
                cols = numMonths[1],
                width = 17;

            inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
            if (cols > 1) {
                inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
                "Class"]("ui-datepicker-multi");
            inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
                "Class"]("ui-datepicker-rtl");

            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }

            // deffered render of the years select (to avoid flashes on Firefox)
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function() {
                    //assure that inst.yearshtml didn't change.
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },

        // #6694 - don't focus the input if it's already focused
        // this breaks the change event in IE
        // Support: IE and jQuery <1.9
        _shouldFocusInput: function(inst) {
            return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function(inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(),
                dpHeight = inst.dpDiv.outerHeight(),
                inputWidth = inst.input ? inst.input.outerWidth() : 0,
                inputHeight = inst.input ? inst.input.outerHeight() : 0,
                viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
                viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

            offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
                Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
                Math.abs(dpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function(obj) {
            var position,
                inst = this._getInst(obj),
                isRTL = this._get(inst, "isRTL");

            while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? "previousSibling" : "nextSibling"];
            }

            position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Hide the date picker from view.
         * @param  input  element - the input field attached to the date picker
         */
        _hideDatepicker: function(input) {
            var showAnim, duration, postProcess, onClose,
                inst = this._curInst;

            if (!inst || (input && inst !== $.data(input, "datepicker"))) {
                return;
            }

            if (this._datepickerShowing) {
                showAnim = this._get(inst, "showAnim");
                duration = this._get(inst, "duration");
                postProcess = function() {
                    $.datepicker._tidyDialog(inst);
                };

                // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
                } else {
                    inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
                        (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
                }

                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;

                onClose = this._get(inst, "onClose");
                if (onClose) {
                    onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
                }

                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: "absolute",
                        left: "0",
                        top: "-100px"
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $("body").append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },

        /* Tidy up after a dialog display. */
        _tidyDialog: function(inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
        },

        /* Close date picker if clicked elsewhere. */
        _checkExternalClick: function(event) {
            if (!$.datepicker._curInst) {
                return;
            }

            var $target = $(event.target),
                inst = $.datepicker._getInst($target[0]);

            if ((($target[0].id !== $.datepicker._mainDivId &&
                    $target.parents("#" + $.datepicker._mainDivId).length === 0 &&
                    !$target.hasClass($.datepicker.markerClassName) &&
                    !$target.closest("." + $.datepicker._triggerClass).length &&
                    $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) ||
                ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
                $.datepicker._hideDatepicker();
            }
        },

        /* Adjust one of the date sub-fields. */
        _adjustDate: function(id, offset, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset +
                (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
                period);
            this._updateDatepicker(inst);
        },

        /* Action for current link. */
        _gotoToday: function(id) {
            var date,
                target = $(id),
                inst = this._getInst(target[0]);

            if (this._get(inst, "gotoCurrent") && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a new month/year. */
        _selectMonthYear: function(id, select, period) {
            var target = $(id),
                inst = this._getInst(target[0]);

            inst["selected" + (period === "M" ? "Month" : "Year")] =
                inst["draw" + (period === "M" ? "Month" : "Year")] =
                parseInt(select.options[select.selectedIndex].value, 10);

            this._notifyChange(inst);
            this._adjustDate(target);
        },

        /* Action for selecting a day. */
        _selectDay: function(id, month, year, td) {
            var inst,
                target = $(id);

            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }

            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $("a", td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst,
                inst.currentDay, inst.currentMonth, inst.currentYear), $(td)); //SC: Sapient Change : Passing Date Td element
        },

        /* Erase the input field and hide the date picker. */
        _clearDate: function(id) {
            var target = $(id);
            this._selectDate(target, "");
        },

        /* Update the input field with the selected date. */
        _selectDate: function(id, dateStr, $td) { //SC: Sapient Change : Receiving Date Td element
            var onSelect,
                target = $(id),
                inst = this._getInst(target[0]);

            dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);

            onSelect = this._get(inst, "onSelect");
            if (onSelect) {
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst, $td]); // trigger custom callback //SC: Sapient Change : Lalit
            } else if (inst.input) {
                inst.input.trigger("change"); // fire the change event
            }
            var dontRefreshOnSelection = this._get(inst, 'dontRefreshOnSelection'); //SC: Sapient Change : Lalit
            if (dontRefreshOnSelection) {
                return;
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof(inst.input[0]) !== "object") {
                    inst.input.focus(); // restore focus
                }
                this._lastInput = null;
            }
        },

        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst) {
            var altFormat, date, dateStr,
                altField = this._get(inst, "altField");

            if (altField) { // update alternate field too
                altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function() {
                    $(this).val(dateStr);
                });
            }
        },

        /* Set as beforeShowDay function to prevent selection of weekends.
         * @param  date  Date - the date to customise
         * @return [boolean, string] - is this date selectable?, what is its CSS class?
         */
        noWeekends: function(date) {
            var day = date.getDay();
            return [(day > 0 && day < 6), ""];
        },

        /* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
         * @param  date  Date - the date to get the week for
         * @return  number - the number of the week within the year that contains this date
         */
        iso8601Week: function(date) {
            var time,
                checkDate = new Date(date.getTime());

            // Find Thursday of this week starting on Monday
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

            time = checkDate.getTime();
            checkDate.setMonth(0); // Compare with Jan 1
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },

        /* Parse a string value into a date object.
         * See formatDate below for the possible formats.
         *
         * @param  format string - the expected format of the date
         * @param  value string - the date in the above format
         * @param  settings Object - attributes include:
         *					shortYearCutoff  number - the cutoff year for determining the century (optional)
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  Date - the extracted date value or null if value is blank
         */
        parseDate: function(format, value, settings) {
            if (format == null || value == null) {
                throw "Invalid arguments";
            }

            value = (typeof value === "object" ? value.toString() : value + "");
            if (value === "") {
                return null;
            }

            var iFormat, dim, extra,
                iValue = 0,
                shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
                shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
                    new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                year = -1,
                month = -1,
                day = -1,
                doy = -1,
                literal = false,
                date,
                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Extract a number from the string value
                getNumber = function(match) {
                    var isDoubled = lookAhead(match),
                        size = (match === "@" ? 14 : (match === "!" ? 20 :
                            (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                        digits = new RegExp("^\\d{1," + size + "}"),
                        num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw "Missing number at position " + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                },
                // Extract a name from the string value and convert to an index
                getName = function(match, shortNames, longNames) {
                    var index = -1,
                        names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                            return [
                                [k, v]
                            ];
                        }).sort(function(a, b) {
                            return -(a[1].length - b[1].length);
                        });

                    $.each(names, function(i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw "Unknown name at position " + iValue;
                    }
                },
                // Confirm that a literal character matches the string value
                checkLiteral = function() {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw "Unexpected literal at position " + iValue;
                    }
                    iValue++;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                            day = getNumber("d");
                            break;
                        case "D":
                            getName("D", dayNamesShort, dayNames);
                            break;
                        case "o":
                            doy = getNumber("o");
                            break;
                        case "m":
                            month = getNumber("m");
                            break;
                        case "M":
                            month = getName("M", monthNamesShort, monthNames);
                            break;
                        case "y":
                            year = getNumber("y");
                            break;
                        case "@":
                            date = new Date(getNumber("@"));
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "!":
                            date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                            year = date.getFullYear();
                            month = date.getMonth() + 1;
                            day = date.getDate();
                            break;
                        case "'":
                            if (lookAhead("'")) {
                                checkLiteral();
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            checkLiteral();
                    }
                }
            }

            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw "Extra/unparsed characters found in date: " + extra;
                }
            }

            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 +
                    (year <= shortYearCutoff ? 0 : -100);
            }

            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }

            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw "Invalid date"; // E.g. 31/02/00
            }
            return date;
        },

        /* Standard date formats. */
        ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
        COOKIE: "D, dd M yy",
        ISO_8601: "yy-mm-dd",
        RFC_822: "D, d M y",
        RFC_850: "DD, dd-M-y",
        RFC_1036: "D, d M y",
        RFC_1123: "D, d M yy",
        RFC_2822: "D, d M yy",
        RSS: "D, d M y", // RFC 822
        TICKS: "!",
        TIMESTAMP: "@",
        W3C: "yy-mm-dd", // ISO 8601

        _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
            Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

        /* Format a date object into a string value.
         * The format can be combinations of the following:
         * d  - day of month (no leading zero)
         * dd - day of month (two digit)
         * o  - day of year (no leading zeros)
         * oo - day of year (three digit)
         * D  - day name short
         * DD - day name long
         * m  - month of year (no leading zero)
         * mm - month of year (two digit)
         * M  - month name short
         * MM - month name long
         * y  - year (two digit)
         * yy - year (four digit)
         * @ - Unix timestamp (ms since 01/01/1970)
         * ! - Windows ticks (100ns since 01/01/0001)
         * "..." - literal text
         * '' - single quote
         *
         * @param  format string - the desired format of the date
         * @param  date Date - the date value to format
         * @param  settings Object - attributes include:
         *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
         *					dayNames		string[7] - names of the days from Sunday (optional)
         *					monthNamesShort string[12] - abbreviated names of the months (optional)
         *					monthNames		string[12] - names of the months (optional)
         * @return  string - the date in the above format
         */
        formatDate: function(format, date, settings) {
            if (!date) {
                return "";
            }

            var iFormat,
                dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
                dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
                monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
                monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                },
                // Format a number, with leading zero if necessary
                formatNumber = function(match, value, len) {
                    var num = "" + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = "0" + num;
                        }
                    }
                    return num;
                },
                // Format a name, short or long as requested
                formatName = function(match, value, shortNames, longNames) {
                    return (lookAhead(match) ? longNames[value] : shortNames[value]);
                },
                output = "",
                literal = false;

            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                            case "d":
                                output += formatNumber("d", date.getDate(), 2);
                                break;
                            case "D":
                                output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                                break;
                            case "o":
                                output += formatNumber("o",
                                    Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                                break;
                            case "m":
                                output += formatNumber("m", date.getMonth() + 1, 2);
                                break;
                            case "M":
                                output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                                break;
                            case "y":
                                output += (lookAhead("y") ? date.getFullYear() :
                                    (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                                break;
                            case "@":
                                output += date.getTime();
                                break;
                            case "!":
                                output += date.getTime() * 10000 + this._ticksTo1970;
                                break;
                            case "'":
                                if (lookAhead("'")) {
                                    output += "'";
                                } else {
                                    literal = true;
                                }
                                break;
                            default:
                                output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },

        /* Extract all possible characters from the date format. */
        _possibleChars: function(format) {
            var iFormat,
                chars = "",
                literal = false,
                // Check whether a format character is doubled
                lookAhead = function(match) {
                    var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };

            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                        case "d":
                        case "m":
                        case "y":
                        case "@":
                            chars += "0123456789";
                            break;
                        case "D":
                        case "M":
                            return null; // Accept anything
                        case "'":
                            if (lookAhead("'")) {
                                chars += "'";
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function(inst, name) {
            return inst.settings[name] !== undefined ?
                inst.settings[name] : this._defaults[name];
        },

        /* Parse existing date and initialise date picker. */
        _setDateFromField: function(inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }

            var dateFormat = this._get(inst, "dateFormat"),
                dates = inst.lastVal = inst.input ? inst.input.val() : null,
                defaultDate = this._getDefaultDate(inst),
                date = defaultDate,
                settings = this._getFormatConfig(inst);

            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = (noDefault ? "" : dates);
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = (dates ? date.getDate() : 0);
            inst.currentMonth = (dates ? date.getMonth() : 0);
            inst.currentYear = (dates ? date.getFullYear() : 0);
            this._adjustInstDate(inst);
        },

        /* Retrieve the default date shown on opening. */
        _getDefaultDate: function(inst) {
            return this._restrictMinMax(inst,
                this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
        },

        /* A date may be specified as an exact value or a relative one. */
        _determineDate: function(inst, date, defaultDate) {
            var offsetNumeric = function(offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                },
                offsetString = function(offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
                            offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {
                        // Ignore
                    }

                    var date = (offset.toLowerCase().match(/^c/) ?
                            $.datepicker._getDate(inst) : null) || new Date(),
                        year = date.getFullYear(),
                        month = date.getMonth(),
                        day = date.getDate(),
                        pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                        matches = pattern.exec(offset);

                    while (matches) {
                        switch (matches[2] || "d") {
                            case "d":
                            case "D":
                                day += parseInt(matches[1], 10);
                                break;
                            case "w":
                            case "W":
                                day += parseInt(matches[1], 10) * 7;
                                break;
                            case "m":
                            case "M":
                                month += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                            case "y":
                            case "Y":
                                year += parseInt(matches[1], 10);
                                day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                                break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                },
                newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
                    (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

            newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },

        /* Handle switch to/from daylight saving.
         * Hours may be non-zero on daylight saving cut-over:
         * > 12 when midnight changeover, but then cannot generate
         * midnight datetime, so jump to 1AM, otherwise reset.
         * @param  date  (Date) the date to check
         * @return  (Date) the corrected date
         */
        _daylightSavingAdjust: function(date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },

        /* Set the date(s) directly. */
        _setDate: function(inst, date, noChange) {
            var clear = !date,
                origMonth = inst.selectedMonth,
                origYear = inst.selectedYear,
                newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? "" : this._formatDate(inst));
            }
        },

        /* Retrieve the date(s) directly. */
        _getDate: function(inst) {
            var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
                this._daylightSavingAdjust(new Date(
                    inst.currentYear, inst.currentMonth, inst.currentDay)));
            return startDate;
        },

        /* Attach the onxxx handlers.  These are declared statically so
         * they work with static code transformers like Caja.
         */
        _attachHandlers: function(inst) {
            var stepMonths = this._get(inst, "stepMonths"),
                id = "#" + inst.id.replace(/\\\\/g, "\\");
            inst.dpDiv.find("[data-handler]").map(function() {
                var handler = {
                    prev: function() {
                        $.datepicker._adjustDate(id, -stepMonths, "M");
                    },
                    next: function() {
                        $.datepicker._adjustDate(id, +stepMonths, "M");
                    },
                    hide: function() {
                        $.datepicker._hideDatepicker();
                    },
                    today: function() {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function() {
                        $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
                        return false;
                    },
                    selectMonth: function() {
                        $.datepicker._selectMonthYear(id, this, "M");
                        return false;
                    },
                    selectYear: function() {
                        $.datepicker._selectMonthYear(id, this, "Y");
                        return false;
                    }
                };
                $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
            });
        },

        /* Generate the HTML for the current state of the date picker. */
        _generateHTML: function(inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
                controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
                monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
                selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
                cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
                printDate, dRow, tbody, daySettings, otherMonth, unselectable,
                tempDate = new Date(),
                today = this._daylightSavingAdjust(
                    new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
                isRTL = this._get(inst, "isRTL"),
                showButtonPanel = this._get(inst, "showButtonPanel"),
                hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
                navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
                numMonths = this._getNumberOfMonths(inst),
                showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
                stepMonths = this._get(inst, "stepMonths"),
                isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
                currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
                    new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                drawMonth = inst.drawMonth - showCurrentAtPos,
                drawYear = inst.drawYear;

            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
                    maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
                maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;

            prevText = this._get(inst, "prevText");
            prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
                this._getFormatConfig(inst)));

            prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
                " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

            nextText = this._get(inst, "nextText");
            nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
                this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
                this._getFormatConfig(inst)));

            next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
                "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
                " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
                (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

            currentText = this._get(inst, "currentText");
            gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
            currentText = (!navigationAsDateFormat ? currentText :
                this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

            controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
                this._get(inst, "closeText") + "</button>" : "");

            buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
                (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
                    ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

            firstDay = parseInt(this._get(inst, "firstDay"), 10);
            firstDay = (isNaN(firstDay) ? 0 : firstDay);

            showWeek = this._get(inst, "showWeek");
            dayNames = this._get(inst, "dayNames");
            dayNamesMin = this._get(inst, "dayNamesMin");
            monthNames = this._get(inst, "monthNames");
            monthNamesShort = this._get(inst, "monthNamesShort");
            beforeShowDay = this._get(inst, "beforeShowDay");
            showOtherMonths = this._get(inst, "showOtherMonths");
            selectOtherMonths = this._get(inst, "selectOtherMonths");
            defaultDate = this._getDefaultDate(inst);
            html = "";
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = "";
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = " ui-corner-all";
                    calender = "";
                    if (isMultiMonth) {
                        calender += "<div class='ui-datepicker-group";
                        if (numMonths[1] > 1) {
                            switch (col) {
                                case 0:
                                    calender += " ui-datepicker-group-first";
                                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                                    break;
                                case numMonths[1] - 1:
                                    calender += " ui-datepicker-group-last";
                                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                                    break;
                                default:
                                    calender += " ui-datepicker-group-middle";
                                    cornerClass = "";
                                    break;
                            }
                        }
                        calender += "'>";
                    }
                    calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
                        (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
                        (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
                        this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
                            row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
                        "</div><table class='ui-datepicker-calendar'><thead>" +
                        "<tr>";
                    thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
                    for (dow = 0; dow < 7; dow++) { // days of the week
                        day = (dow + firstDay) % 7;
                        thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
                            "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
                    }
                    calender += thead + "</tr></thead><tbody>";
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
                    numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
                        calender += "<tr>";
                        tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
                            this._get(inst, "calculateWeek")(printDate) + "</td>");
                        for (dow = 0; dow < 7; dow++) { // create date picker days
                            daySettings = (beforeShowDay ?
                                beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                            otherMonth = (printDate.getMonth() !== drawMonth);
                            unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
                                (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                            tbody += "<td class='" +
                                ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
                                (otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
                                ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
                                    (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
                                    // or defaultDate is current printedDate and defaultDate is selectedDate
                                    " " + this._dayOverClass : "") + // highlight selected day
                                (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + // highlight unselectable days
                                (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
                                    (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
                                    (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
                                ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
                                (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
                                (otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
                                    (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
                                        (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
                                        (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
                                        (otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
                                        "' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + "</tr>";
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
                        ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },

        /* Generate the month and year header. */
        _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
            secondary, monthNames, monthNamesShort) {

            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
                changeMonth = this._get(inst, "changeMonth"),
                changeYear = this._get(inst, "changeYear"),
                showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
                html = "<div class='ui-datepicker-title'>",
                monthHtml = "";

            // month selection
            if (secondary || !changeMonth) {
                monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
            } else {
                inMinYear = (minDate && minDate.getFullYear() === drawYear);
                inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
                monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += "<option value='" + month + "'" +
                            (month === drawMonth ? " selected='selected'" : "") +
                            ">" + monthNamesShort[month] + "</option>";
                    }
                }
                monthHtml += "</select>";
            }

            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
            }

            // year selection
            if (!inst.yearshtml) {
                inst.yearshtml = "";
                if (secondary || !changeYear) {
                    html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
                } else {
                    // determine range of years to display
                    years = this._get(inst, "yearRange").split(":");
                    thisYear = new Date().getFullYear();
                    determineYear = function(value) {
                        var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
                            (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
                                parseInt(value, 10)));
                        return (isNaN(year) ? thisYear : year);
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ""));
                    year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
                    endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
                    inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
                    for (; year <= endYear; year++) {
                        inst.yearshtml += "<option value='" + year + "'" +
                            (year === drawYear ? " selected='selected'" : "") +
                            ">" + year + "</option>";
                    }
                    inst.yearshtml += "</select>";

                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }

            html += this._get(inst, "yearSuffix");
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
            }
            html += "</div>"; // Close datepicker_header
            return html;
        },

        /* Adjust one of the date sub-fields. */
        _adjustInstDate: function(inst, offset, period) {
            var year = inst.drawYear + (period === "Y" ? offset : 0),
                month = inst.drawMonth + (period === "M" ? offset : 0),
                day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
                date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === "M" || period === "Y") {
                this._notifyChange(inst);
            }
        },

        /* Ensure a date is within any min/max bounds. */
        _restrictMinMax: function(inst, date) {
            var minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                newDate = (minDate && date < minDate ? minDate : date);
            return (maxDate && newDate > maxDate ? maxDate : newDate);
        },

        /* Notify change of month/year. */
        _notifyChange: function(inst) {
            var onChange = this._get(inst, "onChangeMonthYear");
            if (onChange) {
                onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]);
            }
        },

        /* Determine the number of months to show. */
        _getNumberOfMonths: function(inst) {
            var numMonths = this._get(inst, "numberOfMonths");
            return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
        },

        /* Determine the current maximum date - ensure no time components are set. */
        _getMinMaxDate: function(inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
        },

        /* Find the number of days in a given month. */
        _getDaysInMonth: function(year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },

        /* Find the day of the week of the first of a month. */
        _getFirstDayOfMonth: function(year, month) {
            return new Date(year, month, 1).getDay();
        },

        /* Determines if we should allow a "next/prev" month display change. */
        _canAdjustMonth: function(inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst),
                date = this._daylightSavingAdjust(new Date(curYear,
                    curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },

        /* Is the given date in the accepted range? */
        _isInRange: function(inst, date) {
            var yearSplit, currentYear,
                minDate = this._getMinMaxDate(inst, "min"),
                maxDate = this._getMinMaxDate(inst, "max"),
                minYear = null,
                maxYear = null,
                years = this._get(inst, "yearRange");
            if (years) {
                yearSplit = years.split(":");
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }

            return ((!minDate || date.getTime() >= minDate.getTime()) &&
                (!maxDate || date.getTime() <= maxDate.getTime()) &&
                (!minYear || date.getFullYear() >= minYear) &&
                (!maxYear || date.getFullYear() <= maxYear));
        },

        /* Provide the configuration settings for formatting/parsing. */
        _getFormatConfig: function(inst) {
            var shortYearCutoff = this._get(inst, "shortYearCutoff");
            shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
                new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, "dayNamesShort"),
                dayNames: this._get(inst, "dayNames"),
                monthNamesShort: this._get(inst, "monthNamesShort"),
                monthNames: this._get(inst, "monthNames")
            };
        },

        /* Format the given date for display. */
        _formatDate: function(inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = (day ? (typeof day === "object" ? day :
                    this._daylightSavingAdjust(new Date(year, month, day))) :
                this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
            return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
        }
    });

    /*
     * Bind hover events for datepicker elements.
     * Done via delegate so the binding only occurs once in the lifetime of the parent div.
     * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
     */
    function datepicker_bindHover(dpDiv) {
        var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
        return dpDiv.delegate(selector, "mouseout", function() {
                $(this).removeClass("ui-state-hover");
                if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                    $(this).removeClass("ui-datepicker-prev-hover");
                }
                if (this.className.indexOf("ui-datepicker-next") !== -1) {
                    $(this).removeClass("ui-datepicker-next-hover");
                }
            })
            .delegate(selector, "mouseover", function() {
                if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? dpDiv.parent()[0] : datepicker_instActive.input[0])) {
                    $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
                    $(this).addClass("ui-state-hover");
                    if (this.className.indexOf("ui-datepicker-prev") !== -1) {
                        $(this).addClass("ui-datepicker-prev-hover");
                    }
                    if (this.className.indexOf("ui-datepicker-next") !== -1) {
                        $(this).addClass("ui-datepicker-next-hover");
                    }
                }
            });
    }

    /* jQuery extend now ignores nulls! */
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }

    /* Invoke the datepicker functionality.
       @param  options  string - a command, optionally followed by additional parameters or
    					Object - settings for attaching new datepicker functionality
       @return  jQuery object */
    $.fn.datepicker = function(options) {

        /* Verify an empty collection wasn't passed - Fixes #6976 */
        if (!this.length) {
            return this;
        }

        /* Initialise the date picker. */
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }

        /* Append datepicker main container to body if not exist. */
        if ($("#" + $.datepicker._mainDivId).length === 0) {
            $("body").append($.datepicker.dpDiv);
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
            return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
            return $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function() {
            typeof options === "string" ?
                $.datepicker["_" + options + "Datepicker"].
            apply($.datepicker, [this].concat(otherArgs)):
                $.datepicker._attachDatepicker(this, options);
        });
    };

    $.datepicker = new Datepicker(); // singleton instance
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.11.0";

    return $.datepicker;

}));

define('search-panel/flyout-controller', ['jquery'], function($) {
    function FlyoutController(opts) {
        this.opts = $.extend({}, {
            id: 'flyingspan',
            target: false,
            speed: 600,
            fadeSpeed: 400
        }, opts);
        this.init();
    }
    var body = $('body');
    var methods = {
        init: function() {},
        flyout: function(ele, label) {
            killAll(); // kill previous flyout html
            // create flyout html
            body.append('<span id="' + this.opts.id + '" class="flyingspan" />');
            this.flyingspan = $('#' + this.opts.id).hide();
            var pos = ele.offset(),
                that = this,
                offsetTopDiff,
                animateSpeed,
                // get target pos -------------
                targetPos = this.opts.target.offset();
            this.targetCss = {
                top: targetPos.top + 15,
                left: targetPos.left
            };

            // offsettop difference for choosing speed
            offsetTopDiff = pos.top - targetPos.top;
            if (offsetTopDiff <= 500) {
                animateSpeed = this.opts.speed;
            } else if (offsetTopDiff > 500 && offsetTopDiff <= 700) {
                animateSpeed = 800;
            } else {
                animateSpeed = 1200;
            }
            this.flyingspan.css({
                    top: pos.top,
                    left: pos.left
                }).text(label).show()
                .animate(this.targetCss, animateSpeed, function() {
                    that.flyingspan.fadeOut(that.opts.fadeSpeed, function() {
                        // killAll();
                    });
                });
        }
    };

    var killAll = function() {
        body.find('span.flyingspan').remove();
    };

    for (var key in methods) {
        FlyoutController.prototype[key] = methods[key];
    }

    return FlyoutController;
});


define('text!search-panel/templates/calendar.hbs', [], function() {
    return '<div class="row">\n\t<div class="col-md-4">\n\t\n\t</div>\n\t<div class="col-md-7 txt-right pull-right">\n\t\t<label for="days">{{travelMessage}}</label>\n\t\t<div class="styled-select">\n\n\t\t\t<select name="select-days" id="select-days">\n\t\t\t\t<option value="" data-label="exactly" id="dayDuration"></option>\n\t\t\t\t{{#each availableDuration}}\n\t\t\t\t<option value="{{days}}" data-durationtype="{{durationType}}" {{#if selected}}selected="selected"{{/if}}>{{duration}}</option>\n\t\t\t\t{{/each}}\n\t\t\t</select>\n\n\t\t</div>\n\t</div>\n</div>';
});


define('text!search-panel/templates/tool-tip.hbs', [], function() {
    return '{{#each toolTipLabels}}\n<div class=\'disabled-date-tooltip\'>\n\t\t<ul>\n\t\t\t<li><a class=\'icon-close-circle\' href=\'#\'></a>\n\t\t\t\t<div class=\'heading\'>{{mainMessage}}</div>\n\t\t\t\t<span class=\'phone\'>{{phone}}</span>\n\t\t\t\t<span class=\'time\'>{{dateTime}}</span>\n\t\t\t\t<a class=\'show-prev\' href=\'#\'>{{prevDate}}</a>\n\t\t\t\t<a class=\'show-next\' href=\'#\'>{{nextDate}}</a>\n\t\t\t</li>\n\t\t</ul>\n\t\t<div class=\'date-pointer\'></div>\n</div>\n{{/each}}';
});

/*
 *  jQuery OwlCarousel v1.3.3
 *
 *  Copyright (c) 2013 Bartosz Wojciechowski
 *  http://www.owlgraphic.com/owlcarousel/
 *
 *  Licensed under MIT
 *
 */

/* This is a search specific component with changes
 *  commented out for beginning and end
 *  e.g. line 647 (starting with below comments in quotes)
 *  "Changes made to original component for search on iOS devices"
 *  For other uses, please include the original owl.carousel.js
 */

/*JS Lint helpers: */
/*global dragMove: false, dragEnd: false, $, jQuery, alert, window, document */
/*jslint nomen: true, continue:true */

if (typeof Object.create !== "function") {
    Object.create = function(obj) {
        function F() {}
        F.prototype = obj;
        return new F();
    };
}
(function($, window, document) {

    var Carousel = {
        init: function(options, el) {
            var base = this;

            base.$elem = $(el);
            base.options = $.extend({}, $.fn.owlCarousel133.options, base.$elem.data(), options);

            base.userOptions = options;
            base.loadContent();
        },

        loadContent: function() {
            var base = this,
                url;

            function getData(data) {
                var i, content = "";
                if (typeof base.options.jsonSuccess === "function") {
                    base.options.jsonSuccess.apply(this, [data]);
                } else {
                    for (i in data.owl) {
                        if (data.owl.hasOwnProperty(i)) {
                            content += data.owl[i].item;
                        }
                    }
                    base.$elem.html(content);
                }
                base.logIn();
            }

            if (typeof base.options.beforeInit === "function") {
                base.options.beforeInit.apply(this, [base.$elem]);
            }

            if (typeof base.options.jsonPath === "string") {
                url = base.options.jsonPath;
                $.getJSON(url, getData);
            } else {
                base.logIn();
            }
        },

        logIn: function() {
            var base = this;

            base.$elem.data("owl-originalStyles", base.$elem.attr("style"));
            base.$elem.data("owl-originalClasses", base.$elem.attr("class"));

            base.$elem.css({
                opacity: 0
            });
            base.orignalItems = base.options.items;
            base.checkBrowser();
            base.wrapperWidth = 0;
            base.checkVisible = null;
            base.setVars();
        },

        setVars: function() {
            var base = this;
            if (base.$elem.children().length === 0) {
                return false;
            }
            base.baseClass();
            base.eventTypes();
            base.$userItems = base.$elem.children();
            base.itemsAmount = base.$userItems.length;
            base.wrapItems();
            base.$owlItems = base.$elem.find(".owl-item");
            base.$owlWrapper = base.$elem.find(".owl-wrapper");
            base.playDirection = "next";
            base.prevItem = 0;
            base.prevArr = [0];
            base.currentItem = 0;
            base.customEvents();
            base.onStartup();
        },

        onStartup: function() {
            var base = this;
            base.updateItems();
            base.calculateAll();
            base.buildControls();
            base.updateControls();
            base.response();
            base.moveEvents();
            base.stopOnHover();
            base.owlStatus();

            if (base.options.transitionStyle !== false) {
                base.transitionTypes(base.options.transitionStyle);
            }
            if (base.options.autoPlay === true) {
                base.options.autoPlay = 5000;
            }
            base.play();

            base.$elem.find(".owl-wrapper").css("display", "block");

            if (!base.$elem.is(":visible")) {
                base.watchVisibility();
            } else {
                base.$elem.css("opacity", 1);
            }
            base.onstartup = false;
            base.eachMoveUpdate();
            if (typeof base.options.afterInit === "function") {
                base.options.afterInit.apply(this, [base.$elem]);
            }
        },

        eachMoveUpdate: function() {
            var base = this;

            if (base.options.lazyLoad === true) {
                base.lazyLoad();
            }
            if (base.options.autoHeight === true) {
                base.autoHeight();
            }
            base.onVisibleItems();

            if (typeof base.options.afterAction === "function") {
                base.options.afterAction.apply(this, [base.$elem]);
            }
        },

        updateVars: function() {
            var base = this;
            if (typeof base.options.beforeUpdate === "function") {
                base.options.beforeUpdate.apply(this, [base.$elem]);
            }
            base.watchVisibility();
            base.updateItems();
            base.calculateAll();
            base.updatePosition();
            base.updateControls();
            base.eachMoveUpdate();
            if (typeof base.options.afterUpdate === "function") {
                base.options.afterUpdate.apply(this, [base.$elem]);
            }
        },

        reload: function() {
            var base = this;
            window.setTimeout(function() {
                base.updateVars();
            }, 0);
        },

        watchVisibility: function() {
            var base = this;

            if (base.$elem.is(":visible") === false) {
                base.$elem.css({
                    opacity: 0
                });
                window.clearInterval(base.autoPlayInterval);
                window.clearInterval(base.checkVisible);
            } else {
                return false;
            }
            base.checkVisible = window.setInterval(function() {
                if (base.$elem.is(":visible")) {
                    base.reload();
                    base.$elem.animate({
                        opacity: 1
                    }, 200);
                    window.clearInterval(base.checkVisible);
                }
            }, 500);
        },

        wrapItems: function() {
            var base = this;
            base.$userItems.wrapAll("<div class=\"owl-wrapper\">").wrap("<div class=\"owl-item\"></div>");
            base.$elem.find(".owl-wrapper").wrap("<div class=\"owl-wrapper-outer\">");
            base.wrapperOuter = base.$elem.find(".owl-wrapper-outer");
            base.$elem.css("display", "block");
        },

        baseClass: function() {
            var base = this,
                hasBaseClass = base.$elem.hasClass(base.options.baseClass),
                hasThemeClass = base.$elem.hasClass(base.options.theme);

            if (!hasBaseClass) {
                base.$elem.addClass(base.options.baseClass);
            }

            if (!hasThemeClass) {
                base.$elem.addClass(base.options.theme);
            }
        },

        updateItems: function() {
            var base = this,
                width, i;

            if (base.options.responsive === false) {
                return false;
            }
            if (base.options.singleItem === true) {
                base.options.items = base.orignalItems = 1;
                base.options.itemsCustom = false;
                base.options.itemsDesktop = false;
                base.options.itemsDesktopSmall = false;
                base.options.itemsTablet = false;
                base.options.itemsTabletSmall = false;
                base.options.itemsMobile = false;
                return false;
            }

            width = $(base.options.responsiveBaseWidth).width();

            if (width > (base.options.itemsDesktop[0] || base.orignalItems)) {
                base.options.items = base.orignalItems;
            }
            if (base.options.itemsCustom !== false) {
                //Reorder array by screen size
                base.options.itemsCustom.sort(function(a, b) {
                    return a[0] - b[0];
                });

                for (i = 0; i < base.options.itemsCustom.length; i += 1) {
                    if (base.options.itemsCustom[i][0] <= width) {
                        base.options.items = base.options.itemsCustom[i][1];
                    }
                }

            } else {

                if (width <= base.options.itemsDesktop[0] && base.options.itemsDesktop !== false) {
                    base.options.items = base.options.itemsDesktop[1];
                }

                if (width <= base.options.itemsDesktopSmall[0] && base.options.itemsDesktopSmall !== false) {
                    base.options.items = base.options.itemsDesktopSmall[1];
                }

                if (width <= base.options.itemsTablet[0] && base.options.itemsTablet !== false) {
                    base.options.items = base.options.itemsTablet[1];
                }

                if (width <= base.options.itemsTabletSmall[0] && base.options.itemsTabletSmall !== false) {
                    base.options.items = base.options.itemsTabletSmall[1];
                }

                if (width <= base.options.itemsMobile[0] && base.options.itemsMobile !== false) {
                    base.options.items = base.options.itemsMobile[1];
                }
            }

            //if number of items is less than declared
            if (base.options.items > base.itemsAmount && base.options.itemsScaleUp === true) {
                base.options.items = base.itemsAmount;
            }
        },

        response: function() {
            var base = this,
                smallDelay,
                lastWindowWidth;

            if (base.options.responsive !== true) {
                return false;
            }
            lastWindowWidth = $(window).width();

            base.resizer = function() {
                if ($(window).width() !== lastWindowWidth) {
                    if (base.options.autoPlay !== false) {
                        window.clearInterval(base.autoPlayInterval);
                    }
                    window.clearTimeout(smallDelay);
                    smallDelay = window.setTimeout(function() {
                        lastWindowWidth = $(window).width();
                        base.updateVars();
                    }, base.options.responsiveRefreshRate);
                }
            };
            $(window).resize(base.resizer);
        },

        updatePosition: function() {
            var base = this;
            base.jumpTo(base.currentItem);
            if (base.options.autoPlay !== false) {
                base.checkAp();
            }
        },

        appendItemsSizes: function() {
            var base = this,
                roundPages = 0,
                lastItem = base.itemsAmount - base.options.items;

            base.$owlItems.each(function(index) {
                var $this = $(this);
                $this
                    .css({
                        "width": base.itemWidth
                    })
                    .data("owl-item", Number(index));

                if (index % base.options.items === 0 || index === lastItem) {
                    if (!(index > lastItem)) {
                        roundPages += 1;
                    }
                }
                $this.data("owl-roundPages", roundPages);
            });
        },

        appendWrapperSizes: function() {
            var base = this,
                width = base.$owlItems.length * base.itemWidth;

            base.$owlWrapper.css({
                "width": width * 2,
                "left": 0
            });
            base.appendItemsSizes();
        },

        calculateAll: function() {
            var base = this;
            base.calculateWidth();
            base.appendWrapperSizes();
            base.loops();
            base.max();
        },

        calculateWidth: function() {
            var base = this;
            base.itemWidth = Math.round(base.$elem.width() / base.options.items);
        },

        max: function() {
            var base = this,
                maximum = ((base.itemsAmount * base.itemWidth) - base.options.items * base.itemWidth) * -1;
            if (base.options.items > base.itemsAmount) {
                base.maximumItem = 0;
                maximum = 0;
                base.maximumPixels = 0;
            } else {
                base.maximumItem = base.itemsAmount - base.options.items;
                base.maximumPixels = maximum;
            }
            return maximum;
        },

        min: function() {
            return 0;
        },

        loops: function() {
            var base = this,
                prev = 0,
                elWidth = 0,
                i,
                item,
                roundPageNum;

            base.positionsInArray = [0];
            base.pagesInArray = [];

            for (i = 0; i < base.itemsAmount; i += 1) {
                elWidth += base.itemWidth;
                base.positionsInArray.push(-elWidth);

                if (base.options.scrollPerPage === true) {
                    item = $(base.$owlItems[i]);
                    roundPageNum = item.data("owl-roundPages");
                    if (roundPageNum !== prev) {
                        base.pagesInArray[prev] = base.positionsInArray[i];
                        prev = roundPageNum;
                    }
                }
            }
        },

        buildControls: function() {
            var base = this;
            if (base.options.navigation === true || base.options.pagination === true) {
                base.owlControls = $("<div class=\"owl-controls\"/>").toggleClass("clickable", !base.browser.isTouch).appendTo(base.$elem);
            }
            if (base.options.pagination === true) {
                base.buildPagination();
            }
            if (base.options.navigation === true) {
                base.buildButtons();
            }
        },

        buildButtons: function() {
            var base = this,
                buttonsWrapper = $("<div class=\"owl-buttons\"/>");
            base.owlControls.append(buttonsWrapper);

            base.buttonPrev = $("<div/>", {
                "class": "owl-prev",
                "html": base.options.navigationText[0] || ""
            });

            base.buttonNext = $("<div/>", {
                "class": "owl-next",
                "html": base.options.navigationText[1] || ""
            });

            buttonsWrapper
                .append(base.buttonPrev)
                .append(base.buttonNext);

            buttonsWrapper.on("touchstart.owlControls mousedown.owlControls", "div[class^=\"owl\"]", function(event) {
                event.preventDefault();
            });

            buttonsWrapper.on("touchend.owlControls mouseup.owlControls", "div[class^=\"owl\"]", function(event) {
                event.preventDefault();
                if ($(this).hasClass("owl-next")) {
                    base.next();
                } else {
                    base.prev();
                }
            });
        },

        buildPagination: function() {
            var base = this;

            base.paginationWrapper = $("<div class=\"owl-pagination\"/>");
            base.owlControls.append(base.paginationWrapper);

            base.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function(event) {
                event.preventDefault();
                if (Number($(this).data("owl-page")) !== base.currentItem) {
                    base.goTo(Number($(this).data("owl-page")), true);
                }
            });
        },

        updatePagination: function() {
            var base = this,
                counter,
                lastPage,
                lastItem,
                i,
                paginationButton,
                paginationButtonInner;

            if (base.options.pagination === false) {
                return false;
            }

            base.paginationWrapper.html("");

            counter = 0;
            lastPage = base.itemsAmount - base.itemsAmount % base.options.items;

            for (i = 0; i < base.itemsAmount; i += 1) {
                if (i % base.options.items === 0) {
                    counter += 1;
                    if (lastPage === i) {
                        lastItem = base.itemsAmount - base.options.items;
                    }
                    paginationButton = $("<div/>", {
                        "class": "owl-page"
                    });
                    paginationButtonInner = $("<span></span>", {
                        "text": base.options.paginationNumbers === true ? counter : "",
                        "class": base.options.paginationNumbers === true ? "owl-numbers" : ""
                    });
                    paginationButton.append(paginationButtonInner);

                    paginationButton.data("owl-page", lastPage === i ? lastItem : i);
                    paginationButton.data("owl-roundPages", counter);

                    base.paginationWrapper.append(paginationButton);
                }
            }
            base.checkPagination();
        },
        checkPagination: function() {
            var base = this;
            if (base.options.pagination === false) {
                return false;
            }
            base.paginationWrapper.find(".owl-page").each(function() {
                if ($(this).data("owl-roundPages") === $(base.$owlItems[base.currentItem]).data("owl-roundPages")) {
                    base.paginationWrapper
                        .find(".owl-page")
                        .removeClass("active");
                    $(this).addClass("active");
                }
            });
        },

        checkNavigation: function() {
            var base = this;

            if (base.options.navigation === false) {
                return false;
            }
            if (base.options.rewindNav === false) {
                if (base.currentItem === 0 && base.maximumItem === 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem === 0 && base.maximumItem !== 0) {
                    base.buttonPrev.addClass("disabled");
                    base.buttonNext.removeClass("disabled");
                } else if (base.currentItem === base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.addClass("disabled");
                } else if (base.currentItem !== 0 && base.currentItem !== base.maximumItem) {
                    base.buttonPrev.removeClass("disabled");
                    base.buttonNext.removeClass("disabled");
                }
            }
        },

        updateControls: function() {
            var base = this;
            base.updatePagination();
            base.checkNavigation();
            if (base.owlControls) {
                if (base.options.items >= base.itemsAmount) {
                    base.owlControls.hide();
                } else {
                    base.owlControls.show();
                }
            }
        },

        destroyControls: function() {
            var base = this;
            if (base.owlControls) {
                base.owlControls.remove();
            }
        },

        next: function(speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            base.currentItem += base.options.scrollPerPage === true ? base.options.items : 1;
            if (base.currentItem > base.maximumItem + (base.options.scrollPerPage === true ? (base.options.items - 1) : 0)) {
                if (base.options.rewindNav === true) {
                    base.currentItem = 0;
                    speed = "rewind";
                } else {
                    base.currentItem = base.maximumItem;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        prev: function(speed) {
            var base = this;

            if (base.isTransition) {
                return false;
            }

            if (base.options.scrollPerPage === true && base.currentItem > 0 && base.currentItem < base.options.items) {
                base.currentItem = 0;
            } else {
                base.currentItem -= base.options.scrollPerPage === true ? base.options.items : 1;
            }
            if (base.currentItem < 0) {
                if (base.options.rewindNav === true) {
                    base.currentItem = base.maximumItem;
                    speed = "rewind";
                } else {
                    base.currentItem = 0;
                    return false;
                }
            }
            base.goTo(base.currentItem, speed);
        },

        goTo: function(position, speed, drag) {
            var base = this,
                goToPixel;

            if (base.isTransition) {
                return false;
            }
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }

            base.currentItem = base.owl.currentItem = position;
            if (base.options.transitionStyle !== false && drag !== "drag" && base.options.items === 1 && base.browser.support3d === true) {
                base.swapSpeed(0);
                if (base.browser.support3d === true) {
                    base.transition3d(base.positionsInArray[position]);
                } else {
                    base.css2slide(base.positionsInArray[position], 1);
                }
                base.afterGo();
                base.singleItemTransition();
                return false;
            }
            goToPixel = base.positionsInArray[position];

            if (base.browser.support3d === true) {
                base.isCss3Finish = false;

                if (speed === true) {
                    base.swapSpeed("paginationSpeed");
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.paginationSpeed);

                } else if (speed === "rewind") {
                    base.swapSpeed(base.options.rewindSpeed);
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.rewindSpeed);

                } else {
                    base.swapSpeed("slideSpeed");
                    window.setTimeout(function() {
                        base.isCss3Finish = true;
                    }, base.options.slideSpeed);
                }

                /***  Changes made to original component for search on iOS devices ***/

                var baseDiff = base.newRelativeX;
                if (baseDiff <= -5 && baseDiff >= -25) {
                    goToPixel = base.positionsInArray[position + 1];
                    if (position + 1 > base.maximumItem) {
                        $('.owl-next').hide();
                        return;
                    }
                    base.currentItem = base.owl.currentItem = position + 1;
                }

                /***  End of changes for search on iOS devices ***/


                base.transition3d(goToPixel);

            } else {
                if (speed === true) {
                    base.css2slide(goToPixel, base.options.paginationSpeed);
                } else if (speed === "rewind") {
                    base.css2slide(goToPixel, base.options.rewindSpeed);
                } else {
                    base.css2slide(goToPixel, base.options.slideSpeed);
                }
            }
            base.afterGo();
        },

        jumpTo: function(position) {
            var base = this;
            if (typeof base.options.beforeMove === "function") {
                base.options.beforeMove.apply(this, [base.$elem]);
            }
            if (position >= base.maximumItem || position === -1) {
                position = base.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }
            base.swapSpeed(0);
            if (base.browser.support3d === true) {
                base.transition3d(base.positionsInArray[position]);
            } else {
                base.css2slide(base.positionsInArray[position], 1);
            }
            base.currentItem = base.owl.currentItem = position;
            base.afterGo();
        },

        afterGo: function() {
            var base = this;

            base.prevArr.push(base.currentItem);
            base.prevItem = base.owl.prevItem = base.prevArr[base.prevArr.length - 2];
            base.prevArr.shift(0);

            if (base.prevItem !== base.currentItem) {
                base.checkPagination();
                base.checkNavigation();
                base.eachMoveUpdate();

                if (base.options.autoPlay !== false) {
                    base.checkAp();
                }
            }
            if (typeof base.options.afterMove === "function" && base.prevItem !== base.currentItem) {
                base.options.afterMove.apply(this, [base.$elem]);
            }
        },

        stop: function() {
            var base = this;
            base.apStatus = "stop";
            window.clearInterval(base.autoPlayInterval);
        },

        checkAp: function() {
            var base = this;
            if (base.apStatus !== "stop") {
                base.play();
            }
        },

        play: function() {
            var base = this;
            base.apStatus = "play";
            if (base.options.autoPlay === false) {
                return false;
            }
            window.clearInterval(base.autoPlayInterval);
            base.autoPlayInterval = window.setInterval(function() {
                base.next(true);
            }, base.options.autoPlay);
        },

        swapSpeed: function(action) {
            var base = this;
            if (action === "slideSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.slideSpeed));
            } else if (action === "paginationSpeed") {
                base.$owlWrapper.css(base.addCssSpeed(base.options.paginationSpeed));
            } else if (typeof action !== "string") {
                base.$owlWrapper.css(base.addCssSpeed(action));
            }
        },

        addCssSpeed: function(speed) {
            return {
                "-webkit-transition": "all " + speed + "ms ease",
                "-moz-transition": "all " + speed + "ms ease",
                "-o-transition": "all " + speed + "ms ease",
                "transition": "all " + speed + "ms ease"
            };
        },

        removeTransition: function() {
            return {
                "-webkit-transition": "",
                "-moz-transition": "",
                "-o-transition": "",
                "transition": ""
            };
        },

        doTranslate: function(pixels) {
            return {
                "-webkit-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-moz-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-o-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "-ms-transform": "translate3d(" + pixels + "px, 0px, 0px)",
                "transform": "translate3d(" + pixels + "px, 0px,0px)"
            };
        },

        transition3d: function(value) {
            var base = this;
            base.$owlWrapper.css(base.doTranslate(value));
        },

        css2move: function(value) {
            var base = this;
            base.$owlWrapper.css({
                "left": value
            });
        },

        css2slide: function(value, speed) {
            var base = this;

            base.isCssFinish = false;
            base.$owlWrapper.stop(true, true).animate({
                "left": value
            }, {
                duration: speed || base.options.slideSpeed,
                complete: function() {
                    base.isCssFinish = true;
                }
            });
        },

        checkBrowser: function() {
            var base = this,
                translate3D = "translate3d(0px, 0px, 0px)",
                tempElem = document.createElement("div"),
                regex,
                asSupport,
                support3d,
                isTouch;

            tempElem.style.cssText = "  -moz-transform:" + translate3D +
                "; -ms-transform:" + translate3D +
                "; -o-transform:" + translate3D +
                "; -webkit-transform:" + translate3D +
                "; transform:" + translate3D;
            regex = /translate3d\(0px, 0px, 0px\)/g;
            asSupport = tempElem.style.cssText.match(regex);
            support3d = (asSupport !== null && asSupport.length === 1);

            isTouch = "ontouchstart" in window || window.navigator.msMaxTouchPoints;

            base.browser = {
                "support3d": support3d,
                "isTouch": isTouch
            };
        },

        moveEvents: function() {
            var base = this;
            if (base.options.mouseDrag !== false || base.options.touchDrag !== false) {
                base.gestures();
                base.disabledEvents();
            }
        },

        eventTypes: function() {
            var base = this,
                types = ["s", "e", "x"];

            base.ev_types = {};

            if (base.options.mouseDrag === true && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl mousedown.owl",
                    "touchmove.owl mousemove.owl",
                    "touchend.owl touchcancel.owl mouseup.owl"
                ];
            } else if (base.options.mouseDrag === false && base.options.touchDrag === true) {
                types = [
                    "touchstart.owl",
                    "touchmove.owl",
                    "touchend.owl touchcancel.owl"
                ];
            } else if (base.options.mouseDrag === true && base.options.touchDrag === false) {
                types = [
                    "mousedown.owl",
                    "mousemove.owl",
                    "mouseup.owl"
                ];
            }

            base.ev_types.start = types[0];
            base.ev_types.move = types[1];
            base.ev_types.end = types[2];
        },

        disabledEvents: function() {
            var base = this;
            base.$elem.on("dragstart.owl", function(event) {
                event.preventDefault();
            });
            base.$elem.on("mousedown.disableTextSelect", function(e) {
                return $(e.target).is('input, textarea, select, option');
            });
        },

        gestures: function() {
            /*jslint unparam: true*/
            var base = this,
                locals = {
                    offsetX: 0,
                    offsetY: 0,
                    baseElWidth: 0,
                    relativePos: 0,
                    position: null,
                    minSwipe: null,
                    maxSwipe: null,
                    sliding: null,
                    dargging: null,
                    targetElement: null
                };

            base.isCssFinish = true;

            function getTouches(event) {
                if (event.touches !== undefined) {
                    return {
                        x: event.touches[0].pageX,
                        y: event.touches[0].pageY
                    };
                }

                if (event.touches === undefined) {
                    if (event.pageX !== undefined) {
                        return {
                            x: event.pageX,
                            y: event.pageY
                        };
                    }
                    if (event.pageX === undefined) {
                        return {
                            x: event.clientX,
                            y: event.clientY
                        };
                    }
                }
            }

            function swapEvents(type) {
                if (type === "on") {
                    $(document).on(base.ev_types.move, dragMove);
                    $(document).on(base.ev_types.end, dragEnd);
                } else if (type === "off") {
                    $(document).off(base.ev_types.move);
                    $(document).off(base.ev_types.end);
                }
            }

            function dragStart(event) {
                var ev = event.originalEvent || event || window.event,
                    position;

                if (ev.which === 3) {
                    return false;
                }
                if (base.itemsAmount <= base.options.items) {
                    return;
                }
                if (base.isCssFinish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }
                if (base.isCss3Finish === false && !base.options.dragBeforeAnimFinish) {
                    return false;
                }

                if (base.options.autoPlay !== false) {
                    window.clearInterval(base.autoPlayInterval);
                }

                if (base.browser.isTouch !== true && !base.$owlWrapper.hasClass("grabbing")) {
                    base.$owlWrapper.addClass("grabbing");
                }

                base.newPosX = 0;
                base.newRelativeX = 0;

                $(this).css(base.removeTransition());

                position = $(this).position();
                locals.relativePos = position.left;

                locals.offsetX = getTouches(ev).x - position.left;
                locals.offsetY = getTouches(ev).y - position.top;
                swapEvents("on");
                locals.sliding = false;
                locals.targetElement = ev.target || ev.srcElement;
            }

            function dragMove(event) {
                var ev = event.originalEvent || event || window.event,
                    minSwipe,
                    maxSwipe;

                base.newPosX = getTouches(ev).x - locals.offsetX;
                base.newPosY = getTouches(ev).y - locals.offsetY;
                base.newRelativeX = base.newPosX - locals.relativePos;
                if (typeof base.options.startDragging === "function" && locals.dragging !== true && base.newRelativeX !== 0) {
                    locals.dragging = true;
                    base.options.startDragging.apply(base, [base.$elem]);
                }

                if ((base.newRelativeX > 8 || base.newRelativeX < -8) && (base.browser.isTouch === true)) {
                    if (ev.preventDefault !== undefined) {
                        ev.preventDefault();
                    } else {
                        ev.returnValue = false;
                    }
                    locals.sliding = true;
                }

                if ((base.newPosY > 10 || base.newPosY < -10) && locals.sliding === false) {
                    $(document).off("touchmove.owl");
                }

                minSwipe = function() {
                    return base.newRelativeX / 5;
                };

                maxSwipe = function() {
                    return base.maximumPixels + base.newRelativeX / 5;
                };

                base.newPosX = Math.max(Math.min(base.newPosX, minSwipe()), maxSwipe());
                if (base.browser.support3d === true) {
                    base.transition3d(base.newPosX);
                } else {
                    base.css2move(base.newPosX);
                }
            }

            function dragEnd(event) {
                var ev = event.originalEvent || event || window.event,
                    newPosition,
                    handlers,
                    owlStopEvent;

                ev.target = ev.target || ev.srcElement;

                locals.dragging = false;

                if (base.browser.isTouch !== true) {
                    base.$owlWrapper.removeClass("grabbing");
                }

                if (base.newRelativeX < 0) {
                    base.dragDirection = base.owl.dragDirection = "left";
                } else {
                    base.dragDirection = base.owl.dragDirection = "right";
                }

                if (base.newRelativeX !== 0) {
                    newPosition = base.getNewPosition();
                    base.goTo(newPosition, false, "drag");
                    if (locals.targetElement === ev.target && base.browser.isTouch !== true) {
                        $(ev.target).on("click.disable", function(ev) {
                            ev.stopImmediatePropagation();
                            ev.stopPropagation();
                            ev.preventDefault();
                            $(ev.target).off("click.disable");
                        });
                        handlers = $._data(ev.target, "events").click;
                        owlStopEvent = handlers.pop();
                        handlers.splice(0, 0, owlStopEvent);
                    }
                }
                swapEvents("off");
            }
            base.$elem.on(base.ev_types.start, ".owl-wrapper", dragStart);
        },

        getNewPosition: function() {
            var base = this,
                newPosition = base.closestItem();

            if (newPosition > base.maximumItem) {
                base.currentItem = base.maximumItem;
                newPosition = base.maximumItem;
            } else if (base.newPosX >= 0) {
                newPosition = 0;
                base.currentItem = 0;
            }
            return newPosition;
        },
        closestItem: function() {
            var base = this,
                array = base.options.scrollPerPage === true ? base.pagesInArray : base.positionsInArray,
                goal = base.newPosX,
                closest = null;

            $.each(array, function(i, v) {
                if (goal - (base.itemWidth / 20) > array[i + 1] && goal - (base.itemWidth / 20) < v && base.moveDirection() === "left") {
                    closest = v;
                    if (base.options.scrollPerPage === true) {
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        base.currentItem = i;
                    }
                } else if (goal + (base.itemWidth / 20) < v && goal + (base.itemWidth / 20) > (array[i + 1] || array[i] - base.itemWidth) && base.moveDirection() === "right") {
                    if (base.options.scrollPerPage === true) {
                        closest = array[i + 1] || array[array.length - 1];
                        base.currentItem = $.inArray(closest, base.positionsInArray);
                    } else {
                        closest = array[i + 1];
                        base.currentItem = i + 1;
                    }
                }
            });
            return base.currentItem;
        },

        moveDirection: function() {
            var base = this,
                direction;
            if (base.newRelativeX < 0) {
                direction = "right";
                base.playDirection = "next";
            } else {
                direction = "left";
                base.playDirection = "prev";
            }
            return direction;
        },

        customEvents: function() {
            /*jslint unparam: true*/
            var base = this;
            base.$elem.on("owl.next", function() {
                base.next();
            });
            base.$elem.on("owl.prev", function() {
                base.prev();
            });
            base.$elem.on("owl.play", function(event, speed) {
                base.options.autoPlay = speed;
                base.play();
                base.hoverStatus = "play";
            });
            base.$elem.on("owl.stop", function() {
                base.stop();
                base.hoverStatus = "stop";
            });
            base.$elem.on("owl.goTo", function(event, item) {
                base.goTo(item);
            });
            base.$elem.on("owl.jumpTo", function(event, item) {
                base.jumpTo(item);
            });
        },

        stopOnHover: function() {
            var base = this;
            if (base.options.stopOnHover === true && base.browser.isTouch !== true && base.options.autoPlay !== false) {
                base.$elem.on("mouseover", function() {
                    base.stop();
                });
                base.$elem.on("mouseout", function() {
                    if (base.hoverStatus !== "stop") {
                        base.play();
                    }
                });
            }
        },

        lazyLoad: function() {
            var base = this,
                i,
                $item,
                itemNumber,
                $lazyImg,
                follow;

            if (base.options.lazyLoad === false) {
                return false;
            }
            for (i = 0; i < base.itemsAmount; i += 1) {
                $item = $(base.$owlItems[i]);

                if ($item.data("owl-loaded") === "loaded") {
                    continue;
                }

                itemNumber = $item.data("owl-item");
                $lazyImg = $item.find(".lazyOwl");

                if (typeof $lazyImg.data("src") !== "string") {
                    $item.data("owl-loaded", "loaded");
                    continue;
                }
                if ($item.data("owl-loaded") === undefined) {
                    $lazyImg.hide();
                    $item.addClass("loading").data("owl-loaded", "checked");
                }
                if (base.options.lazyFollow === true) {
                    follow = itemNumber >= base.currentItem;
                } else {
                    follow = true;
                }
                if (follow && itemNumber < base.currentItem + base.options.items && $lazyImg.length) {
                    base.lazyPreload($item, $lazyImg);
                }
            }
        },

        lazyPreload: function($item, $lazyImg) {
            var base = this,
                iterations = 0,
                isBackgroundImg;

            if ($lazyImg.prop("tagName") === "DIV") {
                $lazyImg.css("background-image", "url(" + $lazyImg.data("src") + ")");
                isBackgroundImg = true;
            } else {
                $lazyImg[0].src = $lazyImg.data("src");
            }

            function showImage() {
                $item.data("owl-loaded", "loaded").removeClass("loading");
                $lazyImg.removeAttr("data-src");
                if (base.options.lazyEffect === "fade") {
                    $lazyImg.fadeIn(400);
                } else {
                    $lazyImg.show();
                }
                if (typeof base.options.afterLazyLoad === "function") {
                    base.options.afterLazyLoad.apply(this, [base.$elem]);
                }
            }

            function checkLazyImage() {
                iterations += 1;
                if (base.completeImg($lazyImg.get(0)) || isBackgroundImg === true) {
                    showImage();
                } else if (iterations <= 100) { //if image loads in less than 10 seconds
                    window.setTimeout(checkLazyImage, 100);
                } else {
                    showImage();
                }
            }

            checkLazyImage();
        },

        autoHeight: function() {
            var base = this,
                $currentimg = $(base.$owlItems[base.currentItem]).find("img"),
                iterations;

            function addHeight() {
                var $currentItem = $(base.$owlItems[base.currentItem]).height();
                base.wrapperOuter.css("height", $currentItem + "px");
                if (!base.wrapperOuter.hasClass("autoHeight")) {
                    window.setTimeout(function() {
                        base.wrapperOuter.addClass("autoHeight");
                    }, 0);
                }
            }

            function checkImage() {
                iterations += 1;
                if (base.completeImg($currentimg.get(0))) {
                    addHeight();
                } else if (iterations <= 100) { //if image loads in less than 10 seconds
                    window.setTimeout(checkImage, 100);
                } else {
                    base.wrapperOuter.css("height", ""); //Else remove height attribute
                }
            }

            if ($currentimg.get(0) !== undefined) {
                iterations = 0;
                checkImage();
            } else {
                addHeight();
            }
        },

        completeImg: function(img) {
            var naturalWidthType;

            if (!img.complete) {
                return false;
            }
            naturalWidthType = typeof img.naturalWidth;
            if (naturalWidthType !== "undefined" && img.naturalWidth === 0) {
                return false;
            }
            return true;
        },

        onVisibleItems: function() {
            var base = this,
                i;

            if (base.options.addClassActive === true) {
                base.$owlItems.removeClass("active");
            }
            base.visibleItems = [];
            for (i = base.currentItem; i < base.currentItem + base.options.items; i += 1) {
                base.visibleItems.push(i);

                if (base.options.addClassActive === true) {
                    $(base.$owlItems[i]).addClass("active");
                }
            }
            base.owl.visibleItems = base.visibleItems;
        },

        transitionTypes: function(className) {
            var base = this;
            //Currently available: "fade", "backSlide", "goDown", "fadeUp"
            base.outClass = "owl-" + className + "-out";
            base.inClass = "owl-" + className + "-in";
        },

        singleItemTransition: function() {
            var base = this,
                outClass = base.outClass,
                inClass = base.inClass,
                $currentItem = base.$owlItems.eq(base.currentItem),
                $prevItem = base.$owlItems.eq(base.prevItem),
                prevPos = Math.abs(base.positionsInArray[base.currentItem]) + base.positionsInArray[base.prevItem],
                origin = Math.abs(base.positionsInArray[base.currentItem]) + base.itemWidth / 2,
                animEnd = 'webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend';

            base.isTransition = true;

            base.$owlWrapper
                .addClass('owl-origin')
                .css({
                    "-webkit-transform-origin": origin + "px",
                    "-moz-perspective-origin": origin + "px",
                    "perspective-origin": origin + "px"
                });

            function transStyles(prevPos) {
                return {
                    "position": "relative",
                    "left": prevPos + "px"
                };
            }

            $prevItem
                .css(transStyles(prevPos, 10))
                .addClass(outClass)
                .on(animEnd, function() {
                    base.endPrev = true;
                    $prevItem.off(animEnd);
                    base.clearTransStyle($prevItem, outClass);
                });

            $currentItem
                .addClass(inClass)
                .on(animEnd, function() {
                    base.endCurrent = true;
                    $currentItem.off(animEnd);
                    base.clearTransStyle($currentItem, inClass);
                });
        },

        clearTransStyle: function(item, classToRemove) {
            var base = this;
            item.css({
                "position": "",
                "left": ""
            }).removeClass(classToRemove);

            if (base.endPrev && base.endCurrent) {
                base.$owlWrapper.removeClass('owl-origin');
                base.endPrev = false;
                base.endCurrent = false;
                base.isTransition = false;
            }
        },

        owlStatus: function() {
            var base = this;
            base.owl = {
                "userOptions": base.userOptions,
                "baseElement": base.$elem,
                "userItems": base.$userItems,
                "owlItems": base.$owlItems,
                "currentItem": base.currentItem,
                "prevItem": base.prevItem,
                "visibleItems": base.visibleItems,
                "isTouch": base.browser.isTouch,
                "browser": base.browser,
                "dragDirection": base.dragDirection
            };
        },

        clearEvents: function() {
            var base = this;
            base.$elem.off(".owl owl mousedown.disableTextSelect");
            $(document).off(".owl owl");
            $(window).off("resize", base.resizer);
        },

        unWrap: function() {
            var base = this;
            if (base.$elem.children().length !== 0) {
                base.$owlWrapper.unwrap();
                base.$userItems.unwrap().unwrap();
                if (base.owlControls) {
                    base.owlControls.remove();
                }
            }
            base.clearEvents();
            base.$elem
                .attr("style", base.$elem.data("owl-originalStyles") || "")
                .attr("class", base.$elem.data("owl-originalClasses"));
        },

        destroy: function() {
            var base = this;
            base.stop();
            window.clearInterval(base.checkVisible);
            base.unWrap();
            base.$elem.removeData();
        },

        reinit: function(newOptions) {
            var base = this,
                options = $.extend({}, base.userOptions, newOptions);
            base.unWrap();
            base.init(options, base.$elem);
        },

        addItem: function(htmlString, targetPosition) {
            var base = this,
                position;

            if (!htmlString) {
                return false;
            }

            if (base.$elem.children().length === 0) {
                base.$elem.append(htmlString);
                base.setVars();
                return false;
            }
            base.unWrap();
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }
            if (position >= base.$userItems.length || position === -1) {
                base.$userItems.eq(-1).after(htmlString);
            } else {
                base.$userItems.eq(position).before(htmlString);
            }

            base.setVars();
        },

        removeItem: function(targetPosition) {
            var base = this,
                position;

            if (base.$elem.children().length === 0) {
                return false;
            }
            if (targetPosition === undefined || targetPosition === -1) {
                position = -1;
            } else {
                position = targetPosition;
            }

            base.unWrap();
            base.$userItems.eq(position).remove();
            base.setVars();
        }

    };

    $.fn.owlCarousel133 = function(options) {
        return this.each(function() {
            if ($(this).data("owl-init") === true) {
                return false;
            }
            $(this).data("owl-init", true);
            var carousel = Object.create(Carousel);
            carousel.init(options, this);
            $.data(this, "owlCarousel", carousel);
        });
    };

    $.fn.owlCarousel133.options = {

        items: 5,
        itemsCustom: false,
        itemsDesktop: [1199, 4],
        itemsDesktopSmall: [979, 3],
        itemsTablet: [768, 2],
        itemsTabletSmall: false,
        itemsMobile: [479, 1],
        singleItem: false,
        itemsScaleUp: false,

        slideSpeed: 200,
        paginationSpeed: 800,
        rewindSpeed: 1000,

        autoPlay: false,
        stopOnHover: false,

        navigation: false,
        navigationText: ["prev", "next"],
        rewindNav: true,
        scrollPerPage: false,

        pagination: true,
        paginationNumbers: false,

        responsive: true,
        responsiveRefreshRate: 200,
        responsiveBaseWidth: window,

        baseClass: "owl-carousel",
        theme: "owl-theme",

        lazyLoad: false,
        lazyFollow: true,
        lazyEffect: "fade",

        autoHeight: false,

        jsonPath: false,
        jsonSuccess: false,

        dragBeforeAnimFinish: true,
        mouseDrag: true,
        touchDrag: true,

        addClassActive: false,
        transitionStyle: false,

        beforeUpdate: false,
        afterUpdate: false,
        beforeInit: false,
        afterInit: false,
        beforeMove: false,
        afterMove: false,
        afterAction: false,
        startDragging: false,
        afterLazyLoad: false
    };
}(jQuery, window, document));

define("vendor/owl.carousel.search", function() {});

/* globals TUIUtil, tuiConfig, define */

/**
 * C A L A N D A R
 * @param  {[type]} $                 [description]
 * @param  {[type]} jqueryhoverIntent [description]
 * @param  {[type]} datepicker        [description]
 * @param  {[type]} Handlebars        [description]
 * @param  {[type]} template
 * @return {[type]}                   [description]
 */
define('search-panel/search-when', ['base',
    'jquery',
    'jqueryhoverIntent',
    'vendor/datepicker',
    'handlebars',
    './flyout-controller',
    'text!./templates/calendar.hbs',
    'text!./templates/tool-tip.hbs',
    'vendor/owl.carousel.search'
], function(base, $, jqueryhoverIntent, datepicker, Handlebars, FlyoutController, calendarTemplate, toolTipTemplate, owlCarousel) {

    // extend datepicker with afterShow method. callback to be fired afer the table is rendered.
    $.datepicker._updateDatepickerOriginal = $.datepicker._updateDatepicker;
    $.datepicker._updateDatepicker = function(inst) {
        $.datepicker._updateDatepickerOriginal(inst);
        var afterShow = this._get(inst, 'afterShow');
        if (afterShow) {
            afterShow.apply((inst.input ? inst.input[0] : null)); // trigger custom callback
        }
    };

    function SearchWhen(ele, opts) {
        this.ele = ele;
        this.dateInput = $('#when');

        this.controller = opts.controller;
        this.calendarTemplate = Handlebars.compile(calendarTemplate);
        this.toolTipTemplate = Handlebars.compile(toolTipTemplate);
        this.opts = $.extend(true, {}, {
            datepickerWrapper: '#search-when-datepicker',
            datepicker: {
                numberOfMonths: 2,
                dateFormat: 'dd/mm/yy',
                weekHeader: 'Week',
                showWeek: true,
                firstDay: 1,
                nextText: '',
                prevText: '',
                stepMonths: 2,
                minDate: 0 // ,
                    // maxDate:'22/12/2014'
            },
            input: $([]),
            holidayURL: tuiConfig.calendar.holidayURL,
            serviceURL: tuiConfig.calendar.calendarServiceURL,
            refreshDateURL: this.dateInput.data('daterefreshservice'),
            searchButton: $('#searchNowBtn'),
            labels: {
                day: 'day',
                week: 'week',
                within: 'within'
            }
        }, opts, {
            labels: this.ele.data('labels') || {}
        });

        this.data = this.dateInput.data('defaultdata') || {};

        this.datePickerWrapper = $(this.opts.datepickerWrapper);
        this.clickCount = 0;
        this.dateGlobals = {
            cur: -1,
            prv: -1,
            parsedDates: [0, 0]
        };
        this.datesToHighlight = {
            publicHolidays: [],
            disabledDates: [],
            defaultDates: [],
            updatedDates: [],
            holidayTooltips: []
        };
        this.optionDayDuration = $('#dayDuration');
        this.dayDurationLabel = '';
        // this.template = Handlebars.compile(template);
        this.userAction = false;
        this.useExact = false;
        this.startdate = 0;
        this.labels = this.ele.data('labels');
        this.data.userSelectedDate = false;
        this.data.userSelectedDestination = {
            name: '',
            type: '',
            code: '',
            hierarchy: ''
        };
        this.whenErrorValidations = [];
    }
    var that;
    var methods = {
        init: function() {
            that = this;
            // callback on month change [not used as monthnav has been descoped]
            function changeMonthYear(event, displayedMonth, displayedYear) {
                var monthsTabs = that.ele.find('.month-top-list'),
                    endMonth = monthsTabs.find('li').filter('.disabled').first().attr('data-month');

                endMonth = parseInt(endMonth, 10) - 1;
                monthsTabs.find('li').removeClass('first').next().removeClass('last');
                if (endMonth !== displayedMonth) {
                    monthsTabs.find('li[data-month="' + displayedMonth + '"]').addClass('first').next().addClass('last');
                } else {
                    monthsTabs.find('li[data-month="' + displayedMonth + '"]').addClass('last').prev().addClass('first');
                }
            }
            // this.bindDatePicker();
            this.bindHolidayTooltip();
            // create flyout controller object for calendar
            that.flyoutController = new FlyoutController({
                target: $('#when')
            });
            resetCalendarEvent();

            $.subscribe('breakpointchange', $.proxy(that.changeCalendar, that));
            return this;
        },
        getCalendarCount: function() {
            var screenSize = TUIUtil.getCurrentBreakPoint();
            return (screenSize === 'xs' || screenSize === 'sm') ? 1 : 2;
        },
        bindDatePicker: function(months, availableDatesArr) {
            // set datepicker options
            var numMonths = (months && months.length) ? months.length : this.getCalendarCount(),
                minDate = availableDatesArr[0],
                datepickerOpts = $.extend({}, {
                    onSelect: $.proxy(that.select, that),
                    beforeShowDay: $.proxy(that.beforeShowDay, that),
                    afterShow: $.proxy(that.afterShow, that)
                }, this.opts.datepicker);
            this.datepickerOpts = datepickerOpts;
            this.datepickerOpts.minDate = minDate;
            this.datepickerOpts.numberOfMonths = numMonths;
            this.datepickerOpts.stepMonths = numMonths;
            this.datepicker = this.datePickerWrapper.datepicker(this.datepickerOpts);
        },
        updateSelectedDst: function(title, category, code, hierarchy) { // to post the user selected destination
            if (!this.data.userSelectedDestination) {
                this.data.userSelectedDestination = {};
            }
            this.data.userSelectedDestination.name = title;
            this.data.userSelectedDestination.type = category;
            this.data.userSelectedDestination.code = code;
            this.data.userSelectedDestination.hierarchy = hierarchy;

        },
        updateCalender: function(obj, removeDuration) {
            this.data.duration = obj.duration;
            this.data.from = obj.from;
            this.data.flexible = obj.flexible;
            this.data.to = obj.to;
            this.data.durationId = obj.durationId;
            this.data.durationText = obj.durationText;
            this.fromResponse = true;
            this.setFieldValue();
            if (TUIUtil.getCurrentBreakPoint() === 'xs') {
                if (!obj.flexible) {
                    that.resetFlexiblity();
                } else {
                    that.setFlexiblity(obj.flexible);
                }
            }
            if (removeDuration) {
                that.resetDuration();
            }

        },
        getUpdatedDate: function() { // ajax call for date auto-suggest
            var postJSON = that.controller.getFormValues();
            TUIUtil.genericAjaxRequest({
                dontPool: true,
                url: that.opts.refreshDateURL || $('#when').data('daterefreshservice'),
                cache: false,
                type: 'post',
                dataType: 'json',
                contentType: 'application/json',
                data: JSON.stringify(postJSON),
                success: function(data) {
                    markStartDate(data, data.duration);
                    that.updateTag(data.durationText, that.durationField);
                    that.updateCalender({
                        from: data.from,
                        duration: data.duration,
                        flexible: data.flexibility,
                        to: data.to,
                        durationId: data.durationId,
                        durationText: data.durationText
                    });
                    // Storing the duration in cookie for backend purpose only
                    $.cookie('FIRST_AVAILABLE_DURATION',
                        JSON.stringify({
                            duration: data.duration,
                            durationId: data.durationId,
                            durationText: data.durationText
                        }), {
                            path: '/'
                        }
                    );

                }
            });
        },

        topMonthNav: function() {
            this.ele.on('click', '[data-month]', function(e) {
                if ($(this).hasClass('disabled')) {
                    return;
                }
                var monthsTabs = that.ele.find('.month-top-list');
                var nextDisabledMonth = parseInt(monthsTabs.find('li').filter('.disabled').first().attr('data-month'), 10);
                var year = $('.ui-datepicker-year:first').text();
                var month = $(this).data('month');
                var newDate = '01/' + month + '/' + year; // TODO change the year as per the calendar value
                if (nextDisabledMonth - 1 !== month) {
                    monthsTabs.find('li').removeClass('first').next().removeClass('last');
                    $(this).addClass('first').next().addClass('last');
                }
                that.datepicker.datepicker('setDate', newDate);
                that.updateMonth();

            });
            this.ele.find('#search-when-datepicker').on('click', function() {
                var month = $('.first').data('month');
                that.updateMonth();
            });
        },
        updateMonth: function(tabActive) {
            return;
        },
        bindHolidayTooltip: function(argument) {
            this.ele.on('mouseenter', 'td.public-holiday .ui-state-default', function(e) {
                var curElement = $(this),
                    hoveredDate = parseInt($.trim(curElement.closest('td').attr('class').split('public-holiday ph')[1].split('_ms')[0]), 10),
                    curHolidayIndex,
                    curHolidayTooltipData,
                    holidayToolTip = [],
                    curTooltipWidth, curTooltipHeight,
                    holidayList = $('<div class="holiday-tooltip" style="visibility:hidden"><ul></ul><div class="date-pointer"></div><a href="#" id="holiday-close" class="icon-close-circle"></a></div>');
                curHolidayIndex = that.datesToHighlight.publicHolidays.indexOf(hoveredDate);

                curHolidayTooltipData = that.datesToHighlight.holidayTooltips[curHolidayIndex];

                for (var i = 0; i < curHolidayTooltipData.length; i++) {
                    holidayToolTip.push('<li>' + curHolidayTooltipData[i].place + ' <span>' + curHolidayTooltipData[i].dateRange + '</span></li>');
                }
                holidayList.find('ul').append(holidayToolTip);
                $('body').append(holidayList);
                curTooltipWidth = holidayList.find('ul').width() / 2;
                curTooltipHeight = holidayList.height() + 7; // padding bottom 7 px included in height

                holidayList.css({
                    'top': parseInt(curElement.offset().top - curTooltipHeight, 10) + 'px',
                    'left': parseInt(curElement.offset().left - curTooltipWidth, 10) + 'px',
                    'visibility': 'visible'
                });
                // Change tooltip position in case of no hidden from right

                var toolTipLeft = holidayList.offset().left,
                    toolTipWidth = holidayList.width(),
                    docWidth = $(window).width();
                if (docWidth <= toolTipLeft + toolTipWidth) {
                    holidayList.css({
                        'left': 'auto',
                        'right': '10px'
                    });
                    var targetElem = $(e.target);
                    var targetLeft = targetElem.offset().left;
                    toolTipLeft = holidayList.offset().left;
                    holidayList.find('.date-pointer').css({
                        'left': targetLeft - toolTipLeft + targetElem.width() / 2 - 6 + 'px'
                    });
                }

                $('#holiday-close').on('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    $('.holiday-tooltip').remove();
                });

            });
            that.ele.on('mouseleave', 'td.public-holiday .ui-state-default', function() {
                $('.holiday-tooltip').remove();
            });
        },
        select: function(datetext, inst) {
            var d1, d2,
                prv = this.dateGlobals.prv,
                cur = Date.parse(new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay));
            ++this.clickCount;

            if (prv === -1 || prv === cur) {
                d1 = datetext;
                d2 = false;
                this.dateGlobals.parsedDates = [cur, cur];
            } else {
                d1 = $.datepicker.formatDate(tuiConfig.calendar.dateformat, new Date(prv), {});
                d2 = $.datepicker.formatDate(tuiConfig.calendar.dateformat, new Date(cur), {});
                this.dateGlobals.parsedDates = [prv, cur];
            }

            // set globals
            this.dateGlobals.prv = cur;
            this.dateGlobals.cur = cur;

            // maintain clickCount
            if (prv === cur) {
                --this.clickCount;
            }
            if (this.clickCount > 2 || cur < prv) {
                this.clickCount = 1;
                this.dateGlobals.parsedDates[0] = -1;
                d2 = false;
            }

            this.datePickerWrapper[this.clickCount === 1 ? 'addClass' : 'removeClass']('hoversActive');
            this.userAction = true;

            this.updateStoredData({
                from: d1,
                to: (d2) ? d2 : this.getDefaultRangeEndDate(d1)
            });

            if (this.clickCount === 1) {
                // store the parsed startdate for setting visual state
                this.startdate = cur;
            }

        },
        beforeShowDay: function(date) {
            var parsed = Date.parse(date),
                stored = this.dateGlobals.parsedDates,
                isSelectedRange = stored[0] !== -1 && parsed >= stored[0] && parsed <= stored[1],
                isPublicHoliday = $.inArray(parsed, this.datesToHighlight.publicHolidays) !== -1,
                isDisabled = $.inArray(parsed, this.datesToHighlight.availableDates) === -1,
                canBeHovered = this.clickCount === 1 && parsed > stored[1],
                start = parsed === this.startdate,
                end = (parsed === stored[1]);

            var addClass = canBeHovered || isSelectedRange || isPublicHoliday || isDisabled || end;
            return [!isDisabled, (addClass ? this.className(isSelectedRange, isPublicHoliday, canBeHovered, isDisabled, date, start, end) : 'day-cell')];
        },
        getHolidays: function(param) {
            return $.ajax({
                url: that.opts.holidayURL,
                dataType: 'json',
                data: {
                    'holidayGroupName': param
                } || {}
            });
        },
        selectHolidaysToShow: function(node) {
            function _done(data) {
                var curPublicHolidays = [],
                    curDate;
                that.datesToHighlight.holidayTooltips = [];
                $.each(data.publicHolidays, function(i, v) {
                    curDate = Date.parse(new Date(data.publicHolidays[i].publicHoliday));
                    curPublicHolidays.push(data.publicHolidays[i].publicHoliday);
                    if (data.publicHolidays[i].holidayDesc) {
                        that.datesToHighlight.holidayTooltips.push(data.publicHolidays[i].holidayDesc);
                    } else {
                        that.datesToHighlight.holidayTooltips.push(null);
                    }

                });
                that.processDateArrays(curPublicHolidays, 'publicHolidays');
                // that.datepicker.datepicker('refresh');
            }

            function _fail() {}
            if (node) {
                this.getHolidays(node.value)
                    .done(_done)
                    .fail(_fail);
            }
        },
        datePickerInitialized: false,
        renderCalendar: function(sdata, curTarget) {

            that.datePickerInitialized = false;
            that.cleanup(curTarget);
            removeErrorMessage();
            if (sdata.to && sdata.to.indexOf('NaN') !== -1) {
                sdata.to = sdata.from;
            }
            if (sdata.availableMonths && sdata.availableMonths.length) {
                sdata.availableMonths = adjustMonths(sdata.availableMonths);
            }
            if (!sdata.availableMonths || !sdata.availableMonths.length) {
                that.resetDates();
                showErrorMessage();
                // if error scenario in calendar push error in calendar error array
                that.whenErrorValidations.push({
                    panelId: '#when',
                    type: 'no-dates'
                });
                return false;
            }
            if (sdata.duration) {
                sdata.duration = sdata.duration * 1;
            }
            sdata.travelMessage = that.labels.travelMessage;
            markStartDate(sdata);
            that.data = $.extend({}, that.data, sdata);

            that.refreshDatesData(sdata);

            if (!that.datePickerInitialized) {
                that.bindDatePicker(sdata.availableMonths, sdata.availableDates);
                that.datePickerInitialized = true;
            }
            // find the dynamic option within duration select
            that.optionDayDuration = $('#dayDuration');
            that.dayDurationLabel = that.optionDayDuration.attr('data-label') + ' ';
            if (that.data.availableDates && that.data.availableDates.length) {
                var choosenMinDate;
                var dateChunk = that.data.availableDates[0].split('/'),
                    firstDate = Date.parse(TUIUtil.dateConverter(that.data.availableDates[0])),
                    todayDate = new Date().getTime();
                if (firstDate <= todayDate) {
                    choosenMinDate = 0;
                } else {
                    choosenMinDate = that.data.availableDates[0];
                }

                $.extend(that.datepickerOpts, {
                    minDate: choosenMinDate,
                    maxDate: that.data.availableDates[that.data.availableDates.length - 1]
                });
            }
            that.datepicker = that.datePickerWrapper.datepicker(that.datepickerOpts);
            that.datepicker.datepicker('refresh');

            // public holidays change
            $('#select-public-holidays').on('change', function() {
                that.selectHolidaysToShow(this);
            });

            // duration change
            $('#select-days').on('change', function(e) {
                that.userAction = true;
                var selectedOption = $(this).find('option').filter('[value=' + this.value + ']');
                that.useExact = selectedOption.is(that.optionDayDuration);
                that.updateSelectedRange(this.value);
            });

            // hover state for range selection
            that.ele.on('mouseenter', '.hoversActive td.canBeHovered', function() {
                var $t = $(this),
                    tds = that.datepicker.find('td.canBeHovered'),
                    index = tds.index($t) + 1;

                tds
                    .slice(0, index).addClass('hover')
                    .end()
                    .slice(index).removeClass('hover');
            });
        },
        processDateArrays: function(array, key) {
            if (!key) {
                return;
            }
            var date, parts, parsedDates = [];
            array = array || [];
            // re map array values to parsed datestamps
            $.map(array, function(val) {
                parts = val.split('/');
                if (parts[2].length < 4) {
                    parts[2] = '20' + parts[2];
                }
                date = new Date(parts[2], parts[1] - 1, parts[0]);
                parsedDates.push(Date.parse(date));
            });
            this.datesToHighlight[key] = parsedDates;
        },
        afterShow: function() {
            $('.disabled-date-tooltip').remove();

            var tds = this.datePickerWrapper.find('td'),
                selected = tds.filter('.date-range-selected'),
                selectedFirst = selected.first();
            if (!selected.length) {
                selectedFirst = tds.filter('.canBeHovered').first().prev();
            }

            selectedFirst.addClass('date-range-selected');

            // update option
            this.updateDayDuration(selected.length || (this.data.duration + 1));

            // this.setFieldValue();

            if (selected.length) {
                $.publish('search.change');
            }

            if (this.triggerItem) {
                this.datePickerWrapper.find('td').filter('.disdate' + this.triggerItem + '_ms').trigger('click');
                this.triggerItem = false;
            }
        },
        updateDayDuration: function(n) {
            if (n < -1) {
                return;
            }
            n = n !== 0 ? --n : n;
            this.optionDayDuration
                .text(this.dayDurationLabel + (isNaN(n) ? '-' : n) + ' days')
                .val(n);

            if (this.useExact) {
                this.data.duration = ~~n;
            }
            if (!this.userAction) {
                this.optionDayDuration.parents('select').val(n);
                this.optionDayDuration.parents('select').trigger('change');
            }
        },
        updateSelectedRange: function(n) {
            if (n < 0) {
                return;
            }
            this.updateStoredData({
                duration: n
            });
            this.setFieldValue();
        },
        getFormValues: function() {
            var d = this.data;
            if (!d.duration) {
                delete d.duration;
            }
            if (d.availableDates) {
                delete d.availableDates;
            }
            if (d.availableDuration) {
                delete d.availableDuration;
            }
            if (d.availableMonths) {
                delete d.availableMonths;
            }
            if (d.travelMessage) {
                delete d.travelMessage;
            }
            if (d.offerEndDate) {
                delete d.offerEndDate;
            }
            if (d.holidaysStatesList) {
                delete d.holidaysStatesList;
            }
            if (!d.from) {
                delete d.from;
            }
            
            return d;
        },

        updateView: function() {
            this.setFieldValue();
        },
        updateStoredData: function(obj) {
            this.data = $.extend(this.data, obj);
            if (this.data.duration) {
                this.data.duration = this.data.duration * 1;
            }
        },
        updateDataFromCookie: function(obj, isSetToDefault) {
            if (isSetToDefault) {
                that.resetDates();
                return;
            }
            if (obj.from) {
                this.processDateArrays([obj.from], 'cookieRange');
                this.dateGlobals.parsedDates = this.datesToHighlight.cookieRange;
            }
            if (obj.duration) {
                this.data.duration = obj.duration;
            }
            if (obj.durationText) {
                this.data.durationText = obj.durationText;
            }
            if (obj.durationId) {
                this.data.durationId = obj.durationId;
            }

            this.setDuration(this.data.durationText, this.data.duration);

            if (typeof obj.flexible !== 'undefined') {
                this.data.flexible = obj.flexible;
            }

            this.setFlexiblity(this.data.flexible);
            this.updateStoredData(obj);
            if (!isNaN(parseInt(this.data.duration, 10))) {
                this.data.duration = this.data.duration * 1;
            }
            if (obj.from) {
                this.setFieldValue();
            }


        },
        resetCalendar: function(noAjax, isCalanderreset) {
            that.data = {};
            that.data.userSelectedDate = false;
            delete that.data.userSelectedDestination;
            that.resetDates();
            that.ele.find('td.date-range-selected').removeClass('date-range-selected');
            that.resetFlexiblity();
            that.resetDuration();


            if (!noAjax) {
                that.refreshDurations(that.ele, that.dateInput.data('service'), isCalanderreset);
            }
        },
        resetDates: function() {
            if (this.data) {
                if (this.data.from) {
                    delete this.data.from;
                }
                if (this.data.to) {
                    delete this.data.to;
                }
                if (this.data.duration) {
                    delete this.data.duration;
                }
                if (this.data.flexible) {
                    delete this.data.flexible;
                    // that.resetFlexiblity(); for future use
                }
                if (this.data.durationId) {
                    delete this.data.durationId;
                    that.resetDuration();
                }
                this.setFieldValue();
            }
        },
        changeCalendar: function() {
            return; // Not required as of now as it corrupts Calendar Selected data
            /*this.datepicker.datepicker('destroy');
			this.bindDatePicker();
			this.datepicker.datepicker('refresh');*/
        },
        getCalendarData: function(target, serviceURL) {
            var $dfd = $.Deferred();
            // Use defer to check display
            var postData = $.extend({}, this.controller.getFormValues(), {
                action: 'calendar'
            });
            TUIUtil.genericAjaxRequest({
                url: serviceURL, // taking service url from jsp data-service attribute
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(sdata) {
                that.renderCalendar(sdata, target);
                $dfd.resolve(true);
            });
            return $dfd.promise();
        },
        cleanup: function() {
            this.datePickerWrapper.empty();
            this.datePickerWrapper.removeClass('hasDatepicker');
            // that.ele.find('.row-border-top').show();
        },
        showUnavailableTooltip: function($curDate, e) {
            // TODO: the selectors used in this function can be optimised only use global class selectors when really needed
            e.stopPropagation();
            var curAvailableDates = [],
                isFirstAvailable,
                isLastAvailable,
                curDateIndex,
                curDate = parseInt($.trim($curDate.attr('class').split('disabled disdate')[1].split('_ms')[0]), 10);

            $.each(that.datesToHighlight.availableDates, function(d, dateStr) {
                curAvailableDates.push(that.datesToHighlight.availableDates[d]);
            });
            curAvailableDates.push(curDate);
            curAvailableDates.sort(function(a, b) {
                return a - b;
            });
            curDateIndex = curAvailableDates.indexOf(curDate);
            isFirstAvailable = curDateIndex === 0 ? true : false;
            isLastAvailable = curDateIndex === curAvailableDates.length - 1 ? true : false;

            var toolTipData = $.parseJSON(that.ele.find('.panel').attr('data-disableDateLabels')),
                toolTipHTML = that.toolTipTemplate(toolTipData);

            if ($('.disabled-date-tooltip').length === 0) {
                $('body').append(toolTipHTML);
            }

            var tableElem = $curDate.parents('.ui-datepicker-calendar'),
                leftPos = parseInt($curDate.offset().left, 10),
                searchWhen = $('#searchWhen'),
                calendarRight = parseInt(searchWhen.offset().left, 10) + parseInt(searchWhen.width(), 10),
                tooltipLeft = parseInt($curDate.offset().left - $('.disabled-date-tooltip').width() / 2 + 20, 10),
                tooltipTop = parseInt($curDate.offset().top - $('.disabled-date-tooltip').height(), 10) + 8;

            $('.disabled-date-tooltip').show().css({
                'top': tooltipTop + 'px',
                'left': tooltipLeft + 'px'
            });

            var pointerLeft = leftPos - parseInt($('.disabled-date-tooltip').offset().left, 10);
            $('.date-pointer').css({
                'left': pointerLeft + 10 + 'px'
            });

            tooltipLeft = parseInt($('.disabled-date-tooltip').offset().left, 10);
            var tooltipRight = tooltipLeft + parseInt($('.disabled-date-tooltip').width(), 10);
            if (tooltipRight >= calendarRight) {
                $('.disabled-date-tooltip').show().css({
                    'top': tooltipTop + 'px',
                    'left': tooltipLeft - (tooltipRight - calendarRight + 10) + 'px'
                });
                $('.date-pointer').css({
                    'left': pointerLeft + tooltipRight - calendarRight + 20 + 'px'
                });
            }

            if (tooltipLeft <= 0) {
                $('.disabled-date-tooltip').show().css({
                    'top': tooltipTop + 'px',
                    'left': 10 + 'px'
                });
                $('.date-pointer').css({
                    'left': pointerLeft + tooltipRight - calendarRight + 25 + 'px'
                });
            }

            if (isFirstAvailable) {
                $('.disabled-date-tooltip .show-prev').addClass('disabled');
            }
            if (isLastAvailable) {
                $('.disabled-date-tooltip .show-next').addClass('disabled');
            }

            $('body').on('click', '.disabled-date-tooltip', function(e) {
                e.stopPropagation();
            });
            $('body').on('click', '.disabled-date-tooltip a.show-next', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (!$(this).hasClass('disabled')) {
                    that.setAvailableDate(curAvailableDates[curDateIndex + 1]);
                }
            });
            $('body').on('click', '.disabled-date-tooltip a.show-prev', function(e) {
                e.preventDefault();
                e.stopPropagation();
                if (!$(this).hasClass('disabled')) {
                    that.setAvailableDate(curAvailableDates[curDateIndex - 1]);
                }
            });
            $('.icon-close-circle').on('click', function() {
                $('.disabled-date-tooltip').hide();
            });

            // Does this get unbound ?? we can't leave this event on the document
            $(document).on('click', function() {
                $('.disabled-date-tooltip').hide();
            });
        },
        setAvailableDate: function(dateToReset) {
            var newDate = $.datepicker.formatDate(tuiConfig.calendar.dateformat, new Date(dateToReset), {});
            // alert('goto:'+newDate);
            this.datepicker.datepicker('setDate', newDate);
        },
        className: function(isSelectedRange, isPublicHoliday, canBeHovered, isDisabled, date, start, end, triggerToolTip) {
            var className = [];
            if (isPublicHoliday) {
                className.push('public-holiday ph' + Date.parse(date) + '_ms');
            }
            if (canBeHovered) {
                className.push('canBeHovered');
            }
            if (isDisabled) {
                className.push('disabled disdate' + Date.parse(date) + '_ms');
            }
            if (start) {
                className.push('date-range-selected  first');
            }
            if (triggerToolTip) {
                className.push('triggerToolTip');
            }
            return className.join(' ');
        },
        refreshDatesData: function(data) {
            if (data.from) {
                this.dateGlobals.parsedDates = [
                    Date.parse(TUIUtil.dateConverter(data.from)),
                    Date.parse(TUIUtil.dateConverter(data.from))
                ];
            } else {
                this.dateGlobals.parsedDates = [];
            }
            if (data.availableDates && data.availableDates.length) {
                this.datesToHighlight.availableDates = [];
                $.each(data.availableDates, function(d, dateStr) {
                    that.datesToHighlight.availableDates.push(Date.parse(TUIUtil.dateConverter(dateStr)));
                });
            }
        },
        getDefaultRangeEndDate: function(startRangeDate) {
            var eDate = startRangeDate,
                sDate = TUIUtil.dateConverter(startRangeDate);
            if (this.data && this.data.duration) {
                var days = sDate.getDate() + that.data.duration;
                sDate.setDate(days);
                var yyyy = '' + sDate.getFullYear();
                eDate = sDate.getDate() + '/' + (sDate.getMonth() + 1) + '/' + yyyy.substring(2);
            }
            return eDate;
        }
    };

    var markStartDate = function(sdata, duration) {
        var sDuration = getSelectedDuration(sdata, duration);

        if (sdata.from && sDuration) {
            var from = sdata.from,
                fDate,
                tokens = from.split('/');
            if (tokens.length === 3) {
                fDate = new Date(from.replace(/(\d{2})\/(\d{2})\/(\d{4})/, '$2/$1/$3'));
                fDate.setDate(fDate.getDate() + (sDuration - 1));
            }
            sdata.to = fDate.getDate() + '/' + (fDate.getMonth() + 1) + '/' + fDate.getFullYear();
        }
    };

    var getSelectedDuration = function(sdata, duration) {
        if (duration) {
            return duration;
        }
        var sDuration = null;

        if (!sdata.availableDuration || !sdata.availableDuration.length) {
            sdata.availableDuration = [];
        }
        $.each(sdata.availableDuration, function(s, duration) {
            if (duration.selected) {
                sDuration = duration.days;
                return false;
            }
        });
        if (sDuration) {
            sDuration = sDuration * 1;
        }

        return sDuration;
    };

    var showErrorMessage = function() {
        that.datePickerWrapper.empty();
        that.ele.find('.row-border-top').hide();


        TUIUtil.showInlineMessage(that.datePickerWrapper, {
            message: '<i class="icon-warning"></i> ' + that.labels.emptyCalendarMessage || 'Sorry we dont have any dates avaliable , kindly modify other parameters',
            cssClass: 'common icon-war empty-calendar-messgae',
            highlightElement: [],
            arrow: false,
            container: that.ele,
            left: 0
        }, true);
    };
    var removeErrorMessage = function() {
        that.ele.find('.empty-calendar-messgae').remove();
        that.ele.find('.calendar-top').show();
        that.ele.find('#calendarHeader').show();
        that.ele.find('.group').show();
        if (TUIUtil.getCurrentBreakPoint() === 'lg') {
            that.ele.find('.row-border-top').show();
        }
        this.whenErrorValidations = []; // clear validation/error array
    };
    /**
     * Reset calendar
     * @return {[type]} [description]
     */
    var resetCalendarEvent = function() {
        $('#clear-calendar').off('click').on('click', function(e) {
            that.resetCalendar(false, true);
        });
    };
    /**
     * Fill the unvailable months
     * ["01/06/2015, 01/08/2015,  01/12/2015,   01/02/2015"]
     * @param  {[type]} availableMonths [description]
     * @return {[type]}                 [description]
     */
    var adjustMonths = function(availableMonths) {
        var months = [],
            toFill = 0;
        $.each(availableMonths, function(i, thisMonth) {

            months.push(thisMonth.days);

            var currMonthtokens = thisMonth.days.split('/');
            var currMonthNumber = currMonthtokens[1] * 1;

            if (i + 1 < availableMonths.length) {
                var nextMonthTokens = availableMonths[i + 1].days.split('/');
                var nextMonthNumber = nextMonthTokens[1] * 1;
                if (nextMonthNumber !== currMonthNumber + 1) {


                    if (nextMonthNumber < currMonthNumber) {
                        for (var f = currMonthNumber; f < 12; f++) {

                            months.push('01/' + getMonthNumber(currMonthtokens[1] + f + 1) + '/' + currMonthtokens[2]);
                        }
                        for (var f2 = 0; f2 < nextMonthNumber; f2++) {
                            months.push('01/' + getMonthNumber(f2 + 1) + '/' + nextMonthTokens[2]);
                        }
                    } else {
                        for (var f3 = currMonthNumber; f3 < nextMonthNumber; f3++) {
                            months.push('01/' + getMonthNumber(f3 + 1) + '/' + nextMonthTokens[2]);
                        }
                    }
                }
            }
        });

        months = months.unique();

        var finalArray = [];
        $.each(months, function(i, dString) {
            var tokens = dString.split('/');

            finalArray.push({
                'duration': that.labels.monthLabels[(tokens[1] - 1) * 1] + ' ' + tokens[2],
                'days': dString,
                'selected': false
            });

        });
        return finalArray;
    };
    /**
     * 5 -> 05
     * @param  {[type]} string [description]
     * @return {[type]}        [description]
     */
    var getMonthNumber = function(string) {
        var mNum = string;
        mNum = mNum * 1;
        if (mNum < 10) {
            mNum = '0' + mNum;
        }
        return mNum;
    };

    for (var key in methods) {
        SearchWhen.prototype[key] = methods[key];
    }

    return SearchWhen;
});


define('text!search-panel/templates/selectList.hbs', [], function() {
    return '{{#each this}}\n<li data-days="{{days}}" {{#if selected}}class="selected"{{/if}} data-durationid="{{durationId}}">{{duration}}</li>\n{{/each}}';
});

/* global define, tuiConfig */

define(
    'search-panel/search-when-nordics', ['base', 'jquery', './search-when', 'handlebars', 'text!./templates/selectList.hbs', 'vendor/owl.carousel.search'],
    function(base, $, SearchWhen, Handlebars, templateSelectList, owlCarousel) {

        function SearchWhenNordic(ele, opts) {
            var that = this;
            opts.durationSelector = opts.durationSelector || [];
            this.labels = ele.data('labels');
            opts.datepicker = $.extend({}, {
                onChangeMonthYear: $.proxy(that.changeMonth, that),
                weekHeader: this.labels.week,
                dayNamesMin: this.labels.dayNamesShort,
                monthNames: this.labels.monthLabels,
                dayNames: this.labels.dayNames,
                dontRefreshOnSelection: true
            }, opts.datepicker);

            SearchWhen.apply(this, arguments);
            this.durationSelect = $(this.opts.durationSelector);
            this.durationField = $('#field-duration');
            this.durationPanel = $('#search-duration-flyout');
            this.durationListWrapper = this.durationPanel.find('ul#duration-list');
            this.monthSelect = $('#monthNav');
            this.calendarHeader = $('#calendarHeader');
            this.duration = this.durationSelect.val() || 0;
            this.data.duration = this.duration;
            this.templateSelectList = Handlebars.compile(templateSelectList);

            this.flexibleSelect = $('.flexibility-list.desktop');
            this.flexibleInput = $('a#field-flexibility');

            this.monthBtns = $('#calendarHeader a');
            this.durationLabels = this.durationPanel.data('labels');
            this.triggerItem = false;
            this.durationErrorValidations = [];
            SearchWhen.prototype.init.call(this);
        }

        var helpers = {
            parseMonthYear: function(string) {
                if (!string) {
                    return '';
                }
                var chunks = string.split('/'),
                    date = $.datepicker.parseDate('dd/mm/yy', '01/' + chunks[1] + '/' + chunks[2]);
                return Date.parse(date);
            }
        };
        var that,
            _timer = null;
        var methods = {
            init: function() {
                // use this pattern to call the parents method + add any additional actions
                SearchWhen.prototype.init.call(this);
                // only the init method needs to return itself - this is unique to this class

                that = this;

                $.subscribe('search/when/update', $.proxy(that.updateView, that));
                $.subscribe('search/when/setLabel', $.proxy(that.setDefaultInputlabel, that));
                $.subscribe('breakpointchange', function() {
                    that.updateTag($('#duration-list li.selected').html(), that.durationField);
                });
                // set stored flexible by based on selected state in html
                changeFlexibility();
                changeDurationEvent();
                // set min max dates
                function _setMinMaxDates(availableDates, newFDate) {
                    var min = availableDates[0],
                        max = availableDates[availableDates.length - 1];

                    that.datepicker.datepicker('option', 'minDate', min);
                    that.datepicker.datepicker('option', 'maxDate', max);

                    if (newFDate) {
                        that.datepicker.datepicker('setDate', newFDate);
                    }

                    that.maxDate = helpers.parseMonthYear(max);
                    that.minDate = helpers.parseMonthYear(min);
                }

                function checkIfValidFromDate(fromDate, availableDates) {
                    fromDate = fromDate;
                    if ($.inArray(fromDate, availableDates) === -1) {
                        fromDate = availableDates[0];
                    }
                    return fromDate;
                }

                function _getDate(dateString, dir) {
                    var date = new Date(dateString);

                    switch (dir) {
                        case 'prev':
                            {
                                return new Date(date.setMonth(date.getMonth() - 1));
                            }
                        default:
                            {
                                return new Date(date.setMonth(date.getMonth() + 1));
                            }
                    }
                }

                function _nextPrev(e) {
                    e.preventDefault();
                    var $t = $(e.currentTarget),
                        dir = $t.data('event');

                    if (dir === 'prev') {
                        var prevMonth = that.monthSelect.find('option:selected').prev();
                        if (prevMonth.length) {
                            that.monthSelect.val(prevMonth.val());
                            that.monthSelect.trigger('change');
                        }
                    } else {
                        var nextMonth = that.monthSelect.find('option:selected').next();
                        if (nextMonth.length) {
                            that.monthSelect.val(nextMonth.val());
                            that.monthSelect.trigger('change');
                        }
                    }
                }

                this.ele.on('click', 'a.calendar-next, a.calendar-prev', _nextPrev);
                that.removeTag();

                return this;
            },
            getCalendarCount: function() {
                // overides the base class which calcs calendar number based on breakpoint
                return 12;
            },
            setFlexiblity: function(flexible) {
                that.setFlexiblityListComponent();

                var li = that.flexibleSelect.find('li.selected');

                if (!li.length && !flexible) {
                    return;
                }
                if (!flexible && li.length) {
                    flexible = li.attr('data-value');
                }

                that.flexibleSelect.find('li').removeClass('selected').children('span').removeClass('active');
                that.flexibleSelect.find('li[data-value="' + flexible + '"]').addClass('selected').children('span').addClass('active');
                li = that.flexibleSelect.find('li.selected');
                that.setFieldValue();
                that.updateFlexTags(li.text());
                that.data.flexible = flexible;
                that.data.flexibleText = li.text();
            },

            resetFlexiblity: function() {
                that.updateTag('', that.flexibleInput);
                that.setFlexiblityListComponent();
                that.flexibleSelect.find('li').removeClass('selected').children('span').removeClass('active');
                var defaultFlexibility = that.flexibleSelect.find('li[data-value="3 DAYS"]');
                defaultFlexibility.addClass('selected').children('span').addClass('active');
                that.data.flexible = defaultFlexibility.attr('data-value');
                that.data.flexibleText = defaultFlexibility.text();
                // that.updateFlexTags(that.data.flexibleText);
            },

            setFlexiblityListComponent: function() {
                if (that.flexibleInput.is(':visible')) {
                    that.flexibleSelect = $('#flexibilty-list');
                } else {
                    that.flexibleSelect = $('#flexible-by');
                }
            },

            setDuration: function(durationString, durationId) {

                if (!durationString) {
                    var selectedLI = that.durationPanel.find('li[data-durationid="' + durationId + '"]');
                    if (!selectedLI.length) {
                        selectedLI = that.durationPanel.find('li.selected');
                    }
                    if (selectedLI.length) {
                        durationString = selectedLI.html();
                        that.data.duration = selectedLI.data('days');
                        that.data.durationId = selectedLI.data('durationid');
                        that.data.durationText = selectedLI.html();
                    } else {
                        return;
                    }
                } else {
                    that.data.durationText = durationString;
                }

                that.updateTag(durationString, that.durationField);
                // that.setFieldValue();
            },

            resetDuration: function() {
                var durationString = '';
                that.durationPanel.find('li.selected').removeClass('selected');
                delete that.data.duration;
                delete that.data.durationId;
                delete that.data.durationText;
                that.updateTag(durationString, that.durationField);

                that.setFieldValue();
            },

            refreshDurations: function(target, serviceURL, isCaledarReset) {
                var lastObj = {
                        duration: that.data.duration,
                        from: that.data.from,
                        to: that.data.to,
                        durationId: that.data.durationId,
                        userSelectedDate: that.data.userSelectedDate

                    },
                    $dfd = $.Deferred();
                var resetCalendar = (isCaledarReset) ? true : false;
                var postData = $.extend({}, this.controller.getFormValues(), {
                    resetCalendar: resetCalendar,
                    action: 'duration'
                });
                TUIUtil.genericAjaxRequest({
                    url: serviceURL, // taking service url from jsp data-service attribute
                    dataType: 'json',
                    cache: false,
                    type: 'post',
                    contentType: 'application/json',
                    data: JSON.stringify(postData)
                }).done(function(data) {
                    that.data = $.extend({}, lastObj, data);
                    that.renderLists();
                    that.setDuration(null, null);
                    that.renderCalendar(data);
                    $dfd.resolve(true);
                });
                return $dfd.promise();
            },

            updateStoredData: function() {
                var d = this.data,
                    stored = this.dateGlobals.parsedDates;

                if (stored.length > 0 && stored[0] !== -1 && stored[0]) {
                    tuiConfig.calendar.dateformat = 'dd/mm/yy';
                    d.from = $.datepicker.formatDate(tuiConfig.calendar.dateformat, new Date(stored[0]), {});
                    if (stored[1]) {
                        d.to = $.datepicker.formatDate(tuiConfig.calendar.dateformat, new Date(stored[1]), {});
                    } else {
                        d.to = d.from;
                    }
                }
            },
            removeTag: function() {
                this.opts.input.on('click', '.icon-close-circle', function(e) {
                    e.stopPropagation();
                    that.controller.fromSubmit = false;
                    that.opts.input.empty();
                    that.opts.input.attr('title', that.opts.input.data('placeholder'));
                    // that.data = {};
                    delete that.data.from;
                    delete that.data.to;
                    that.data.userSelectedDate = false;
                    delete that.data.userSelectedDestination;
                    // SearchWhen.prototype.resetDates.call();
                    that.resetFromTo();
                    // that.resetCalendar();
                    that.opts.input.trigger('click');

                });

                that.durationField.on('click', '.icon-close-circle', function(e) {
                    e.stopPropagation();
                    that.controller.fromSubmit = false;
                    that.durationField.empty();
                    // that.data = {};
                    that.resetDuration();
                    that.durationField.attr('title', that.durationField.data('placeholder'));
                    that.durationField.trigger('click');
                });

                that.flexibleInput.on('click', '.icon-close-circle', function(e) {
                    e.stopPropagation();
                    that.controller.fromSubmit = false;
                    that.flexibleInput.empty();
                    that.flexibleInput.trigger('click');
                    that.resetFlexiblity();
                });
            },
            updateTag: function(string, inputField) {
                if (!string) {
                    var placeHolderSpan = '<span class="placeholder-text">' + inputField.data('placeholder') + '</span>';
                    inputField.empty().html(placeHolderSpan);
                    inputField.attr('title', inputField.data('placeholder'));
                } else {
                    string = TUIUtil.trimText(string, inputField);
                    inputField.attr('title', string);
                    var i,
                        tagHtml = '<ul>';
                    tagHtml += '<li>';
                    tagHtml += '<span>';
                    tagHtml += string;
                    tagHtml += '</span>';
                    tagHtml += '<span class="icon-close-circle">';
                    tagHtml += '</li>';
                    tagHtml += '</ul>';
                    inputField.html(tagHtml);
                }
            },
            setFieldValue: function() {
                var d = this.data,
                    text = '';
                if (!d.from) {
                    var datePlaceHoldertext = '<span class="placeholder-text">' + this.opts.input.data('placeholder') + '</span>',
                        durationPlaceHolderText = '<span class="placeholder-text">' + $('a#field-duration.selected-tags').data('placeholder') + '</span>';

                    this.opts.input.html(datePlaceHoldertext);
                    return;
                }

                if (d.from) { // && !isDefaultDate
                    var to,
                        from;
                    text = changeMonthFormat(d.from);
                }
                if (!that.flexibleInput.is(':visible')) {
                    text += getFlexibleText(d);
                }
                that.updateTag(text, that.opts.input);
            },
            updateView: function() {
                SearchWhen.prototype.updateView.call(this);
            },
            /**
             * Setting User selected date boolean in Session storage
             * so that its remembered accross sessions but should be lost
             * when session ends.
             * @param {[type]} bool [description]
             */
            setUserDate: function(bool) {
                if (window.sessionStorage) {
                    window.sessionStorage.setItem('IS_USER_DATE', bool);
                    this.data.userSelectedDate = bool;
                }
            },
            isUserDate: function() {
                var bool = false;
                if (this.data.from) {
                    if (window.sessionStorage) {
                        var sessionValue = window.sessionStorage.getItem('IS_USER_DATE');
                        if (sessionValue === 'true') {
                            bool = true;
                        }
                    }
                }
                return bool;
            },
            select: function(datetext, inst, $td) {
                var $this = $(this);
                var stored = this.dateGlobals.parsedDates,
                    start = new Date(inst.selectedYear, inst.selectedMonth, inst.selectedDay);
                stored[0] = Date.parse(start);
                // stored[1] = stored[0] + this.duration*86400000;
                if(!this.data.duration){
                    this.data.duration = 7;
                }
                stored[1] = start.setDate(start.getDate() + (parseInt(this.data.duration, 10) - 1));
                this.updateStoredData();
                this.data.userSelectedDate = true;
                this.setUserDate(true);
                that.setFieldValue();
                if ($td) {
                    highlightDate($td);
                }
                if (TUIUtil.getCurrentBreakPoint() === 'xs') {
                    return; // No flying span in mobile
                }
                window.setTimeout(function() {
                    that.flyoutController.flyout($td, inst.selectedDay);
                }, 100);

            },
            beforeShowDay: function(date) {
                var parsed = Date.parse(date),
                    stored = this.dateGlobals.parsedDates,
                    isSelectedRange = stored[0] !== -1 && parsed >= stored[0] && parsed <= stored[1],
                    isPublicHoliday = $.inArray(parsed, this.datesToHighlight.publicHolidays) !== -1,
                    isDisabled = $.inArray(parsed, this.datesToHighlight.availableDates) === -1,
                    canBeHovered = false,
                    addClass = canBeHovered || isSelectedRange || isPublicHoliday || isDisabled,
                    start = parsed === stored[0],
                    end = parsed === stored[1],
                    triggerTooltip = false;
                if (isDisabled && parsed === stored[0]) {
                    stored[0] = -1;
                    isSelectedRange = false;
                    this.data.to = false;
                    this.data.from = false;
                    triggerTooltip = true;
                    this.triggerItem = parsed;
                }
                return [!isDisabled, (addClass ? this.className(isSelectedRange, isPublicHoliday, canBeHovered, isDisabled, date, start, end, triggerTooltip) : 'day-cell')];
            },
            renderCalendar: function() {
                SearchWhen.prototype.renderCalendar.apply(this, arguments);
                if (that.ele.find('.empty-calendar-messgae').length) {
                    return false;
                }
                this.maxDate = helpers.parseMonthYear(this.datepicker.datepicker('option', 'maxDate'));
                this.minDate = helpers.parseMonthYear(this.datepicker.datepicker('option', 'minDate'));
                var curDate = this.datepicker.datepicker('getDate');
                this.monthBtnState($.datepicker.formatDate('dd/mm/yy', curDate));
                this.renderLists();
                var fromDate = this.data.from;
                if (fromDate) {
                    fromDate = '01' + fromDate.substr(2, fromDate.length);
                    // this.defaultMonth(fromDate);  // Commenting it DEV-14924
                    this.fromResponse = false;
                    this.setFieldValue();
                }
                that.addOwlCarousel();

            },
            updateFlexTags: function(string) {
                that.updateTag(string, that.flexibleInput);
            },
            setDefaultInputlabel: function() {},
            renderLists: function() {
                // duration
                removeDurationErrorMessage();
                if (!this.data.availableDuration || !this.data.availableDuration.length) {
                    that.resetDuration();
                    showDurationErrorMessage();
                    // if error scenario in calendar push error in calendar error array
                    that.durationErrorValidations.push({
                        panelId: '#field-duration',
                        type: 'no-duration'
                    });
                    return false;
                }
                this.durationPanel.find('ul#duration-list').html(this.templateSelectList(this.data.availableDuration));
                // this.data.duration = this.durationPanel.find('li.selected').data('days');
                // this.data.durationId = this.durationPanel.find('li.selected').data('durationid');
            },

            getServerData: function(target) {
                var url = this.opts.input.data('service');

                return TUIUtil.genericAjaxRequest({
                    url: url, // taking service url from jsp data-service attribute
                    dataType: 'json',
                    cache: false,
                    type: 'post',
                    contentType: 'application/json',
                    data: JSON.stringify(this.controller.getFormValues()),
                    showLoader: true,
                    showLoaderAt: target.find('.panel')
                });
            },
            resetFromTo: function() {
                if (that.data) {
                    if (that.data.from) {
                        delete that.data.from;
                    }
                    if (that.data.to) {
                        delete that.data.to;
                    }

                    if (that.data.flexible) {
                        delete that.data.flexible;
                        that.resetFlexiblity();
                    }

                    that.setFieldValue();
                }
            },
            changeMonth: function(y, m) {
                var dateString = '01/' + (m.toString().length === 1 ? '0' + m : m) + '/' + y;
                this.monthSelect
                    .find('option')
                    .prop('selected', false)
                    .filter('[value="' + dateString + '"]')
                    .prop('selected', true);
                this.monthBtnState(dateString);
            },
            defaultMonth: function(startDate) {
                var chunks = startDate.split('/');
                if (chunks.length !== 3) {
                    return;
                }
                var dateObj = new Date(chunks[2], chunks[1] - 1, chunks[0]);
                this.datepicker.datepicker('setDate', new Date(dateObj));
                this.monthSelect
                    .find('option')
                    .prop('selected', false)
                    .filter('[value="' + startDate + '"]')
                    .prop('selected', true);
            },
            monthBtnState: function(dateString) {
                var date = helpers.parseMonthYear(dateString);
                this.monthBtns.filter('.calendar-prev')[date <= this.minDate ? 'addClass' : 'removeClass']('disabled')
                    .end().filter('.calendar-next')[date >= this.maxDate ? 'addClass' : 'removeClass']('disabled');
            },
            addOwlCarousel: function() {
                if (checkLessMonthsInMD()) {
                    that.ele.find('.ui-datepicker-inline').addClass('owl-carousel single-item');
                    return;
                }
                var datepicker = that.ele.find('.ui-datepicker-inline');
                datepicker.find('.ui-datepicker-row-break').remove();
                datepicker.addClass('owl-carousel');
                var owl = that.ele.find('.owl-carousel');
                var currentBP = TUIUtil.getCurrentBreakPoint();
                owl.owlCarousel133({
                    loop: false,
                    margin: 0,
                    navigation: true,
                    singleItem: (currentBP !== 'xs') ? false : true,
                    rewindNav: false,
                    mouseDrag: false, // To fix the click swipe issue
                    items: 3,
                    itemsDesktop: [2500, 3],
                    itemsDesktopSmall: [991, 2], // between 991pc and 768px
                    itemsTablet: [767, 1], // below 767px
                    itemsTabletSmall: false,
                    itemsMobile: false,
                    responsive: true,

                    afterInit: function() {
                        if ($('.date-range-selected').closest('.ui-datepicker-group').hasClass('ui-datepicker-group-first')) {
                            $('.owl-prev').hide();
                        } else {
                            $('.owl-prev').show();
                        }
                    },
                    afterMove: function() {
                        if (owlInstance.currentItem === 0) {
                            $('.owl-prev').hide();
                        } else {
                            $('.owl-prev').show();
                        }
                        if (owlInstance.currentItem === owlInstance.maximumItem) {
                            $('.owl-next').hide();
                        } else {
                            $('.owl-next').show();
                        }
                    }
                });
                var owlInstance = $('.owl-carousel').data('owlCarousel');
                if (that.data.availableMonths) {
                    owl.find('.owl-prev').wrapInner('<span/>').append($('<i class="icon-way-left"/>'));
                    owl.find('.owl-next').wrapInner('<span/>').append($('<i class="icon-way-right"/>'));
                }
                if (that.data.availableMonths && that.data.availableMonths.length === 2 && currentBP !== 'xs') {
                    that.ele.find('.owl-buttons').hide();
                }

                if (_timer !== null) {
                    clearTimeout(_timer);
                }
                _timer = setTimeout(function() {
                    var activeElementIndex = $('.date-range-selected').closest('.owl-item').index();

                    if (activeElementIndex >= 1) {
                        owlInstance.goTo(activeElementIndex, 100, true);
                    } else {
                        owl.find('.owl-prev').hide();
                    }
                }, 100);

            }
        };
        /**
         * Check if less than 3 months in Desktop
         * @return {[type]} [description]
         */
        var checkLessMonthsInMD = function() {
            var datePickerWrapper = $('#search-when-datepicker');
            if (that.data.availableMonths && that.data.availableMonths.length === 1) {
                datePickerWrapper.addClass('single-month');
                return true;
            }
            datePickerWrapper.removeClass('single-month');
            return false;
        };

        // Show Error Message if no duration is available
        var showDurationErrorMessage = function() {
            that.durationListWrapper.empty();

            TUIUtil.showInlineMessage(that.durationListWrapper, {
                message: '<i class="icon-warning"></i> ' + that.durationLabels.emptyDurationMessage || 'Sorry we dont have any duration avaliable , kindly modify other parameters',
                cssClass: 'common icon-war empty-duration-message',
                highlightElement: [],
                arrow: false,
                container: that.ele,
                left: 0
            }, true);
        };

        // Remove Duration Error Message if no duration is available
        var removeDurationErrorMessage = function() {
            that.ele.find('.empty-duration-message').remove();
            that.durationErrorValidations = []; // clear validation/error array
        };
        var changeMonthFormat = function(from, to) {
            var calendarLabel = $('#searchWhen').data('labels'),
                tokens,
                dateStr,
                date,
                month,
                dayName,
                formatted = '' + from + ' - ' + to; // fallback

            if (from) {
                tokens = from.split('/');
                dateStr = tokens.reverse().join('/');
                date = new Date(dateStr);

                if (date) {
                    var dayNumber = date.getDay();
                    if (dayNumber === 7) {
                        dayNumber = 0;
                    }
                    dayName = calendarLabel.dayNamesShort[dayNumber];
                }
                if (tokens.length === 3) {
                    month = tokens[1] * 1;

                    formatted = dayName + ' ' + dateStr;
                }
            }
            return formatted;
        };

        var changeFlexibility = function() {
            $('#flexible-by , #flexibilty-list').on('click', 'li', function(e) {

                that.data.flexible = $(this).attr('data-value');
                that.data.flexibleText = $(this).text();
                that.setFlexiblity(that.data.flexible);

            });
        };

        var getFlexibleText = function() {
            var fText = '';

            that.setFlexiblityListComponent();

            var selectedLI = that.flexibleSelect.find('li.selected').first();
            if (!that.data || !that.data.flexible) {
                if (selectedLI.length === 0) {
                    return fText;
                } else {
                    that.data.flexible = selectedLI.attr('data-value');
                    that.data.flexibleText = selectedLI.text();
                }
            } else { // When first destination is choosen date selected automatically
                that.flexibleSelect.find('li').removeClass('selected').find('span').removeClass('active');

                selectedLI = that.flexibleSelect.find('li[data-value="' + that.data.flexible + '"]');
                selectedLI.addClass('selected').find('span').addClass('active');
                that.data.flexibleText = selectedLI.text();
            }
            fText = ' (' + that.data.flexibleText + ')';
            return fText;
        };


        var changeDurationEvent = function() {
            that.durationPanel.on('click', 'li', function(e) {
                var $duration = $(this);
                $duration.siblings().removeClass('selected');
                $duration.addClass('selected');
                that.data.durationId = $duration.data('durationid');
                that.data.duration = $duration.data('days');
                that.setDuration($duration.html(), that.data.durationId);

            });
        };

        var highlightDate = function($td) {
            that.ele.find('td.date-range-selected').removeClass('date-range-selected');
            that.ele.find('a.ui-state-active').parents('td').removeClass('date-range-selected').removeClass('first').removeClass('ui-datepicker-current-day');

            that.ele.find('a.ui-state-active').removeClass('ui-state-active');

            $td.addClass('date-range-selected  first ui-datepicker-current-day');
            $td.find('a').addClass('ui-state-active');
        };
        // set min max dates
        var _setMinMaxDates = function(availableDates, newFDate) {
            var min = availableDates[0],
                max = availableDates[availableDates.length - 1];

            that.datepicker.datepicker('option', 'minDate', min);
            that.datepicker.datepicker('option', 'maxDate', max);

            if (newFDate) {
                that.datepicker.datepicker('setDate', newFDate);
            }

            that.maxDate = helpers.parseMonthYear(max);
            that.minDate = helpers.parseMonthYear(min);
        };
        /**
         * Month Next Prev Action
         */
        var _nextPrev = function(e) {
            e.preventDefault();
            var $t = $(e.currentTarget),
                dir = $t.data('event');

            if (dir === 'prev') {
                var prevMonth = that.monthSelect.find('option:selected').prev();
                if (prevMonth.length) {
                    that.monthSelect.val(prevMonth.val());
                    that.monthSelect.trigger('change');
                }
            } else {
                var nextMonth = that.monthSelect.find('option:selected').next();
                if (nextMonth.length) {
                    that.monthSelect.val(nextMonth.val());
                    that.monthSelect.trigger('change');
                }
            }
        };

        SearchWhenNordic.prototype = $.extend({}, SearchWhen.prototype, methods);

        return SearchWhenNordic;
    });


define('text!search-panel/templates/airport-template-v3.hbs', [], function() {
    return '\n<div class="row ">\n\t{{#airportCols airportList}}\n\t\t<div class="airport-item {{#if disabled}}disabled{{/if}}" >\n\t\t\t<input type="checkbox" class="custom-checkbox" name="{{airportCode}}" id="{{airportCode}}" value="{{airportCode}}"  {{#if disabled}}disabled="disabled"{{/if}}   {{#if checked}} checked="checked"{{/if}}  data-airportname="{{airportName}}"  >\n\t\t\t<label class="custom-label {{#if disabled}}disabled{{/if}}"  for="{{airportCode}}">{{airportName}} \n\t\t\t\t<span class="airport-code ">{{airportCode}} </span>\n\t\t\t\t<span class="icon-close-circle remove-airport"></span>\n\t\t\t</label>\n\t\t</div>\n\t{{/airportCols}}\n</div>\n';
});

/* global TUIUtil, tuiConfig, define */
/**
 * A I R P O R T
 * @param  {[type]} $             [description]
 * @param  {[type]} Handlebars    [description]
 * @param  {[type]} template
 * @param  {[type]}
 * @return {[type]} [description]
 */
define('search-panel/search-where-v3', [
    'jquery',
    'handlebars',
    'text!./templates/airport-template-v3.hbs'
], function($, Handlebars, template) {

    function SearchWhere(ele, opts) {
        this.ele = ele;
        this.count = 0;
        this.formData = {
            airportText: '',
            selectedAirports: []
        };
        this.opts = {
            speed: 400,
            selectedTxt: 'selected'
        };
        this.selectedAirports = [];
        // this.defaultAirport = $('#airport').data('default-airport');
        this.serviceURL = $('#airport').data('service'); // tuiConfig.search.airportServiceURL;
        this.template = Handlebars.compile(template);
        this.userAction = false;
        this.controller = opts.controller || false;
        this.inputs = $([]);
        this.clearAllBtn = $('#whereClearAll');
        this.selectedDisplay = $('#whereSelectedDisplay');
        this.parentInput = $('#airport');
        this.labels = this.ele.data('labels');
        this.opts.selectedTxt = this.labels.selected;
        this.init();
    }
    var that;
    var airportsContainer = $('#searchWhere');
    var methods = {
        init: function() {
            that = this;
            that.load = true;

            // checkbox change event
            this.ele.off('change').on('change', 'input[type=checkbox]', function() {
                var $t = $(this),
                    checked = $t.is(':checked'),
                    groupParent = $t.data('group-parent') || false;

                if (checked) {
                    $t.parents('li').addClass('blue-active');
                    // $t.addClass('icon-check');
                } else {
                    $t.parents('li').removeClass('blue-active');
                    // $t.removeClass('icon-check');
                }

                if (groupParent) {
                    that.inputs.filter('[data-group=' + groupParent + ']')
                        .prop('checked', checked).trigger('change');
                }
                markSelected($t);
                //  manage stored values
                var airportNameText = $(this).data('airportname');
                if (airportNameText === undefined) {
                    airportNameText = $(airportsContainer).data('labels').anyAirport;
                }
                if (!groupParent && !$t.hasClass('select-all-selected')) {
                    that[checked ? 'addItem' : 'removeItem'](this.value);
                }
                that.manageSelectAllClearAll();
                that.updateDisplay();
            });

            this.ele.one('click', 'input[type=checkbox]', function() {
                that.userAction = true;
            });

            //  clear|selectAll events
            this.ele.find('.airport-list-wrapper').on('click', 'input[type=checkbox]', $.proxy(that.checkStatus, that));
            this.ele.on('click', '.clear-all-selected', $.proxy(that.clearAll, that));
            this.ele.on('click', '.select-all-selected', $.proxy(that.selectAll, that));

            this.parentInput.on('click', '.icon-close-circle', that.removeTags);

            // that.updateDisplay();
            $.subscribe('breakpointchange', function() {
                if (that.parentInput.find('.placeholder-text').length) {
                    return;
                }
                var airportName = that.parentInput.data('untrimmedvalue'),
                    count = that.parentInput.data('selectedAirportsCount');
                var updatedString = TUIUtil.trimText(airportName, that.parentInput, count);
                if (count) {
                    that.updateInputText(updatedString + '+' + count);
                } else {
                    that.updateInputText(updatedString);
                }
            });
        },
        closePanel: function() {
            that.ele.find('.icon-x').trigger('click');
        },
        addItem: function(val) {
            if (this.selectedAirports.indexOf(val) < 0) {
                this.selectedAirports.push(val);
            }
        },

        removeItem: function(val) {
            var i = this.selectedAirports.indexOf(val);
            if (i >= 0) {
                this.selectedAirports.splice(i, 1);
            }
        },
        removeTags: function(e) {
            e.stopPropagation();
            that.controller.formSubmit = false;
            that.resetAirports();
            that.parentInput.trigger('click').focus();

        },
        getAirportDisplayText: function(selectedAirportsCount, inputField) {
            var inputVal,
                firstCheckedAirportName = getFirstAirportName();
            var totalAirportsCount;
            totalAirportsCount = getTotalCountOfAirports();
            if (selectedAirportsCount === 1) {
                inputVal = TUIUtil.trimText(firstCheckedAirportName, inputField);
                inputField.data('untrimmedvalue', firstCheckedAirportName);
            } else if (selectedAirportsCount > 1 && selectedAirportsCount !== totalAirportsCount) {
                inputVal = TUIUtil.trimText(firstCheckedAirportName, inputField, selectedAirportsCount) + '+' + (selectedAirportsCount - 1);
                inputField.data('selectedAirportsCount', selectedAirportsCount - 1);
                inputField.data('untrimmedvalue', firstCheckedAirportName);
            } else if (selectedAirportsCount === totalAirportsCount) {
                inputVal = $(airportsContainer).data('labels').anyAirport || '';
                inputField.data('untrimmedvalue', inputVal);
            } else {
                inputVal = '';
            }
            return inputVal;
        },
        updateDisplay: function() {
            var selectedCount = this.selectedAirports.length,
                inputVal = '';
            this.clearAllBtn[selectedCount ? 'removeClass' : 'addClass']('disabled');
            this.selectedDisplay.text(selectedCount + ' ' + this.opts.selectedTxt);
            inputVal = this.getAirportDisplayText(selectedCount, this.parentInput);
            this.parentInput.val(inputVal);
            this.updateInputText(this.getAirportDisplayText(selectedCount, this.parentInput));
            $.publish('search.change');
        },
        getFormValues: function(type) {
            if (this.formData.selectedAirports.length === 0 && (type === 'submit' || type === 'SEARCH_PIPE')) {
                this.formData.selectedAirports = [];
                this.selectedAirports = [];
                this.formData.selectedAirports = this.selectedAirports;
            } else {
                var airportText = this.parentInput.val();
                if (airportText) {
                    this.formData.airportText = airportText;
                } else {
                    this.formData.airportText = $(airportsContainer).data('labels').anyAirport || '';
                }
                this.formData.selectedAirports = this.selectedAirports;
            }
            return this.formData;
        },
        selectAll: function(e) {
            var checked = e.target.checked;
            if (checked) {
                that.inputs.not(':disabled').prop('checked', true).closest('li').addClass('blue-active');
            } else {
                that.inputs.not(':disabled').prop('checked', false).closest('li').removeClass('blue-active');
            }

            that.inputs.not(':disabled').each(function() {
                var $t = $(this),
                    checked = $t.is(':checked'),
                    groupParent = $t.data('group-parent') || false;
                if (!groupParent && !$t.hasClass('select-all-selected')) {
                    that[checked ? 'addItem' : 'removeItem'](this.value);
                }
            });
            that.manageSelectAllClearAll();
            that.updateDisplay();
            if (checked) {
                that.closePanel();
            }
        },
        resetAirports: function() {
            that.parentInput.find('ul').remove();
            that.selectedAirports = [];
            that.count = 0;
            that.updateInputText(null);
        },
        clearAll: function(e) {
            if ($(e.target).hasClass('disabled')) {
                return;
            }
            this.inputs.filter(':checked').prop('checked', false).trigger('change');
            that.manageSelectAllClearAll();
        },
        checkStatus: function(e) {
            var itemContainer = $('#searchWhere'),
                listContainer = itemContainer.find('.airport-list-wrapper'),
                selectAll = itemContainer.find('.select-all-selected'),
                total = listContainer.find('input').not(':disabled').length,
                activeItem = listContainer.find('input:checked').not(':disabled').length;

            if (total === activeItem) {
                if (total === 0) {
                    selectAll.prop('checked', false);
                    selectAll.parent().removeClass('blue-active');
                } else {
                    selectAll.prop('checked', true);
                    selectAll.parent().addClass('blue-active');
                }

            } else {
                selectAll.prop('checked', false);
                selectAll.parent().removeClass('blue-active');
            }

        },
        manageSelectAllClearAll: function() {
            var itemContainer = $('#searchWhere'),
                listContainer = itemContainer.find('.airport-list-wrapper'),
                clearAll = itemContainer.find('.clear-all-selected'),
                selectAll = itemContainer.find('.select-all-selected'),
                selectAllLabel = $('label[for="' + selectAll.attr('id') + '"]'),
                total = listContainer.find('input').not(':disabled').length,
                activeItem = listContainer.find('input:checked').not(':disabled').length;

            if (activeItem === 0) {
                clearAll.addClass('disabled');
            } else {
                clearAll.removeClass('disabled');
            }

            if (total === activeItem) {
                if (total === 0) {
                    selectAll.attr('disabled', 'disabled');
                    selectAllLabel.addClass('disabled');
                }

            } else {
                selectAll.removeAttr('disabled');
                selectAllLabel.removeClass('disabled');
            }
        },
        getAirportList: function() {
            var wrapper = this.ele.find('.airport-list-wrapper');
            wrapper.empty();
            // use defer to display result when result render
            var $dfd = $.Deferred();
            var postData = $.extend({}, this.controller.getFormValues(), {
                action: 'departureAirport'
            });
            TUIUtil.genericAjaxRequest({
                url: that.serviceURL,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(sdata) {
                that.selectedAirports = []; // reset previous selection
                that.count = 0;
                wrapper.empty();
                wrapper.append(that.template(sdata)); // _slideDown(_t);
                wrapper.find('input:checked').parents('li').addClass('blue-active');
                that.inputs = that.ele.find('input[type=checkbox]');
                updateData();
                that.updateDisplay();
                $.publish('search/where/update');
                $dfd.resolve(true);
                that.manageSelectAllClearAll();
                that.checkStatus();
                // that.updateWidth(); // not required after search panels are inline without scrollbar
                // that.addScrollbar();
            });
            return $dfd.promise();
        },

        addScrollbar: function() {
            var panel = that.ele.find('.panel');
            panel.removeAttr('style');

            var scroll = that.ele.find('.enscroll-track').parent();

            that.ele.find('.enscroll-track').parent().remove();

            if (!TUIUtil.istabletOrDesktop()) {
                panel.css({
                    'overflow': 'auto'
                });
                $(scroll).remove();

                panel.enscroll({
                    verticalTrackClass: 'track4',
                    verticalHandleClass: 'handle4',
                    minScrollbarLength: 20,
                    pollChanges: true,
                    easingDuration: 100
                });
            }

        },
        updateWidth: function() {
            var panel = that.ele.find('.panel'),
                scrollablePanel = panel.find('.airports-flyout');
            scrollablePanel.width(panel.width() - 12);
        },
        setMaxHeight: function(panelHeight) {
            var flyout = that.ele.find('.airports-flyout'),
                delay = 0;
            if (!flyout.length) {
                delay = 2000;
            }
            /*setTimeout(function(){
				flyout.css('max-height', panelHeight - 100);
			},delay);*/
            flyout.css('max-height', panelHeight - 100);
        },

        /**
         * Updates placeholder or tags in airport field
         * @param  {[type]} airportNameArray [This is airport name array]
         * @return {[type]}            [none]
         */
        updateInputText: function(airportString) {
            that.parentInput.val(airportString);
            if (!airportString) {
                var placeHolderText = '<span class="placeholder-text">' + that.parentInput.data('placeholder') + '</span>';
                that.parentInput.empty().html(placeHolderText);
                that.parentInput.attr('title', that.parentInput.data('placeholder'));
            } else {
                var i,
                    tagHtml = '<ul>';
                tagHtml += '<li>';
                tagHtml += '<span>';
                tagHtml += airportString;
                tagHtml += '</span>';
                tagHtml += '<span class="icon-close-circle">';
                tagHtml += '</li>';
                tagHtml += '</ul>';
                that.parentInput.attr('title', getFirstAirportName());
                that.parentInput.html(tagHtml);
            }
        }

    };

    function getFirstAirportName() {
        var firstAirport = $(airportsContainer).find('.airport-list-wrapper').find('input[type="checkbox"]:checked').first();
        return firstAirport.data('airportname');

    }

    function getTotalCountOfAirports() {
        return $(airportsContainer).find('.airport-list-wrapper').find('input[type="checkbox"]').length;
    }

    function updateData() {
        var selectedCount = 0,
            $t;
        that.ele.find('input[type="checkbox"]').each(function() {
            $t = $(this);
            if ($t.attr('id') === 'selectAll-airports') {
                return;
            }
            if ($t.is(':checked') && $t.parents('dt[data-group]').length === 0) {
                selectedCount++;
                that.selectedAirports[that.selectedAirports.length] = $.trim($t.val());
            }
        });
        that.count = selectedCount;

        if (that.count < 0) {
            that.count = 0;
        }
        that.formData.selectedAirports = that.selectedAirports;
    }

    /**
     * Returns the text length that should be trimmed based on the input .
     * @param  {[type]} fieldWidth [description]
     * @param  {[type]} reduceBy   [description]
     * @return {[type]}            [description]
     */
    function returnTextLength(fieldWidth, reduceBy) {
        if (typeof fieldWidth === 'string' && fieldWidth.indexOf('px')) {
            fieldWidth = fieldWidth.split('px')[0];
        }
        var ratio = 13 / 104;
        var textLength = fieldWidth * ratio;
        textLength = Math.floor(textLength);
        if (reduceBy) {
            textLength -= reduceBy;
        }
        return textLength;
    }

    /**
     * Fly the selected checkbox to airport field
     * @param  {Function} cb [description]
     * @return {[type]}      [description]
     */
    var flySpan = function(cb) {
        var curHTML = cb.next().html(),
            spanClone = '<span class="flyingspan">' + curHTML + '</span>',
            offsetTopField = $('#airport').offset().top,
            offsetLeftField = $('#airport').offset().left,
            offsetTopEle = cb.parent().offset().top,
            offsetLeftEle = cb.parent().offset().left,
            reqOffsetTop = offsetTopField - offsetTopEle,
            reqOffsetLeft = offsetLeftField - offsetLeftEle;

        $(spanClone).appendTo($('body')).css({
            top: offsetTopEle,
            left: offsetLeftEle
        }).animate({
            top: offsetTopField + 15 + 'px',
            left: offsetLeftField + 'px'
        }, that.opts.speed, function() {
            $('.flyingspan').fadeOut(that.opts.speed, function() {
                $('.flyingspan').remove();
                that.controller.scrollTillSearchPanel();
            });
        });
    };

    function markSelected(cb) {
        cb = $(cb);

        if (cb.hasClass('select-all-selected')) {
            return;
        }
        var curDataGroup,
            $siblingsDD,
            groupUncheckedCount;
        if (cb.is(':checked')) {
            if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                flySpan(cb);
            } else {
                that.controller.scrollTillSearchPanel();
            }
            that.count = that.count + 1;
        } else { // UNCHECKED
            that.count = that.count - 1;
            if ($.inArray($.trim(cb.val()), that.selectedAirports) > -1) {
                var curIndex = that.selectedAirports.indexOf($.trim(cb.val()));
                that.selectedAirports.splice(curIndex, 1);
            }
            if (that.count < 0) {
                that.count = 0;
            }
        }
    }

    for (var key in methods) {
        SearchWhere.prototype[key] = methods[key];
    }

    return SearchWhere;
});

/* global TUIUtil, tuiConfig, define */
/**
 * A I R P O R T
 * @param  {[type]} $             [description]
 * @param  {[type]} Handlebars    [description]
 * @param  {[type]} template
 * @param  {[type]}
 * @return {[type]} [description]
 */
define('search-panel/search-where-to-v3', [
    'jquery',
    'handlebars',
    'text!./templates/airport-template-v3.hbs'
], function($, Handlebars, template) {

    function SearchWhereTo(ele, opts) {
        this.ele = ele;

        this.count = 0;
        this.formData = {
            airportTextTo: '',
            selectedAirportsTo: []
        };
        this.opts = {
            speed: 400,
            selectedTxt: 'selected'
        };
        this.selectedAirportsTo = [];
        // this.defaultAirport = $('#airport').data('default-airport');
        this.serviceURL = $('#airport-to').data('service'); // tuiConfig.search.airportServiceURL;
        this.template = Handlebars.compile(template);
        this.userAction = false;
        this.controller = opts.controller || false;
        this.inputs = $([]);

        this.parentInput = $('#airport-to');

        this.labels = this.ele.data('labels');
        this.opts.selectedTxt = this.labels.selected;
        this.init();
    }
    var that;
    var airportsContainer = $('#searchWhereTo');
    var methods = {
        init: function() {
            that = this;
            that.load = true;

            // checkbox change event
            this.ele.off('change').on('change', 'input[type=checkbox]', function() {
                var $t = $(this),
                    checked = $t.is(':checked'),
                    groupParent = $t.data('group-parent') || false;

                if (checked) {
                    $t.parents('li').addClass('blue-active');
                    // $t.addClass('icon-check');
                } else {
                    $t.parents('li').removeClass('blue-active');
                    // $t.removeClass('icon-check');
                }

                if (groupParent) {
                    that.inputs.filter('[data-group=' + groupParent + ']')
                        .prop('checked', checked).trigger('change');
                }

                markSelected($t);

                // manage stored values
                var airportNameText = $(this).data('airportname');
                if (airportNameText === undefined) {
                    airportNameText = $(airportsContainer).data('labels').anyAirport;
                }


                if (!groupParent && !$t.hasClass('select-all-selected')) {
                    that[checked ? 'addItem' : 'removeItem'](this.value);
                }


                that.manageSelectAllClearAll();

                that.updateDisplay();
            });

            this.ele.one('click', 'input[type=checkbox]', function() {
                that.userAction = true;
            });

            // clear|selectAll events
            this.ele.find('.airport-list-wrapper').on('click', 'input[type=checkbox]', $.proxy(that.checkStatus, that));
            this.ele.on('click', '.clear-all-selected', $.proxy(that.clearAll, that));
            this.ele.on('click', '.select-all-selected', $.proxy(that.selectAll, that));

            this.parentInput.on('click', '.icon-close-circle', that.removeTags);

            // that.updateDisplay();
            $.subscribe('breakpointchange', function() {
                if (that.parentInput.find('.placeholder-text').length) {
                    return;
                }
                var airportName = that.parentInput.data('untrimmedvalue'),
                    count = that.parentInput.data('selectedAirportsCount');
                var updatedString = TUIUtil.trimText(airportName, that.parentInput, count);
                if (count) {
                    that.updateInputText(updatedString + '+' + count);
                } else {
                    that.updateInputText(updatedString);
                }

            });

        },
        closePanel: function() {
            that.ele.find('.icon-x').trigger('click');
        },
        addItem: function(val) {
            if (this.selectedAirportsTo.indexOf(val) < 0) {
                this.selectedAirportsTo.push(val);
            }
        },
        removeItem: function(val) {
            var i = this.selectedAirportsTo.indexOf(val);
            if (i >= 0) {
                this.selectedAirportsTo.splice(i, 1);
            }
        },
        removeTags: function(e) {
            e.stopPropagation();
            that.controller.formSubmit = false;
            that.resetAirports();
            that.parentInput.trigger('click').focus();

        },

        getAirportDisplayText: function(selectedAirportsCount, inputField) {
            var inputVal;
            var firstCheckedAirportName = getFirstAirportName();
            var totalAirportsCount = getTotalCountOfAirports();
            if (selectedAirportsCount === 1) {
                inputVal = TUIUtil.trimText(firstCheckedAirportName, inputField);
                inputField.data('untrimmedvalue', firstCheckedAirportName);
            } else if (selectedAirportsCount > 1 && selectedAirportsCount !== totalAirportsCount) {
                inputVal = TUIUtil.trimText(firstCheckedAirportName, inputField, selectedAirportsCount) + '+' + (selectedAirportsCount - 1);
                inputField.data('selectedAirportsCount', selectedAirportsCount - 1);
                inputField.data('untrimmedvalue', firstCheckedAirportName);
            } else if (selectedAirportsCount === totalAirportsCount) {
                inputVal = $(airportsContainer).data('labels').anyAirport || '';
                inputField.data('untrimmedvalue', inputVal);
            } else {
                inputVal = '';
            }
            return inputVal;
        },
        updateDisplay: function() {
            var selectedCount = this.selectedAirportsTo.length,
                inputVal = '';

            inputVal = this.getAirportDisplayText(selectedCount, this.parentInput);
            this.parentInput.val(inputVal);
            // this.parentInput.data('untrimmedvalue', inputVal);
            this.updateInputText(this.getAirportDisplayText(selectedCount, this.parentInput));

            $.publish('search.change');


        },
        getFormValues: function(type) {
            if (this.formData.selectedAirportsTo.length === 0 && (type === 'submit' || type === 'SEARCH_PIPE')) {
                this.formData.selectedAirportsTo = [];
                this.selectedAirportsTo = [];
                this.formData.selectedAirportsTo = this.selectedAirportsTo;
            } else {
                var airportTextTo = this.parentInput.val();
                if (airportTextTo) {
                    this.formData.airportTextTo = airportTextTo;
                } else {
                    this.formData.airportTextTo = $(airportsContainer).data('labels').anyAirport || '';
                }
                this.formData.selectedAirportsTo = this.selectedAirportsTo;
            }

            return this.formData;
        },
        selectAll: function(e) {
            var checked = e.target.checked;
            if (checked) {
                that.inputs.not(':disabled').prop('checked', true).closest('li').addClass('blue-active');
            } else {
                that.inputs.not(':disabled').prop('checked', false).closest('li').removeClass('blue-active');
            }

            that.inputs.not(':disabled').each(function() {
                var $t = $(this),
                    checked = $t.is(':checked'),
                    groupParent = $t.data('group-parent') || false;
                if (!groupParent && !$t.hasClass('select-all-selected')) {
                    that[checked ? 'addItem' : 'removeItem'](this.value);
                }
            });
            that.manageSelectAllClearAll();
            that.updateDisplay();
            if (checked) {
                that.closePanel();
            }
        },
        resetAirports: function() {
            that.parentInput.find('ul').remove();
            that.selectedAirportsTo = [];
            that.count = 0;
            that.updateInputText(null);
        },
        clearAll: function(e) {
            if ($(e.target).hasClass('disabled')) {
                return;
            }
            this.inputs.filter(':checked').prop('checked', false).trigger('change');
            that.manageSelectAllClearAll();
        },
        checkStatus: function(e) {
            var itemContainer = airportsContainer,
                listContainer = itemContainer.find('.airport-list-wrapper'),
                selectAll = itemContainer.find('.select-all-selected'),
                total = listContainer.find('input').not(':disabled').length,
                activeItem = listContainer.find('input:checked').not(':disabled').length;

            if (total === activeItem) {
                if (total === 0) {
                    selectAll.prop('checked', false);
                    selectAll.parent().removeClass('blue-active');
                } else {
                    selectAll.prop('checked', true);
                    selectAll.parent().addClass('blue-active');
                }

            } else {
                selectAll.prop('checked', false);
                selectAll.parent().removeClass('blue-active');
            }

        },
        manageSelectAllClearAll: function() {
            var itemContainer = airportsContainer,
                listContainer = itemContainer.find('.airport-list-wrapper'),
                clearAll = itemContainer.find('.clear-all-selected'),
                selectAll = itemContainer.find('.select-all-selected'),
                selectAllLabel = $('label[for="' + selectAll.attr('id') + '"]'),
                total = listContainer.find('input').not(':disabled').length,
                activeItem = listContainer.find('input:checked').not(':disabled').length;

            if (activeItem === 0) {
                clearAll.addClass('disabled');
            } else {
                clearAll.removeClass('disabled');
            }

            if (total === activeItem) {
                if (total === 0) {
                    selectAll.attr('disabled', 'disabled');
                    selectAllLabel.addClass('disabled');
                }

            } else {
                selectAll.removeAttr('disabled');
                selectAllLabel.removeClass('disabled');
            }
        },
        getAirportList: function() {
            var wrapper = this.ele.find('.airport-list-wrapper');
            wrapper.empty();
            // use defer to display result when result render
            var $dfd = $.Deferred();
            var postData = $.extend({}, this.controller.getFormValues(), {
                action: 'arrivalAirport'
            });
            TUIUtil.genericAjaxRequest({
                url: that.serviceURL,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(postData)
            }).done(function(sdata) {
                that.selectedAirportsTo = []; // reset previous selection
                that.count = 0;
                wrapper.empty();
                wrapper.append(that.template(sdata)); // _slideDown(_t);
                wrapper.find('input:checked').parents('li').addClass('blue-active');
                that.inputs = that.ele.find('input[type=checkbox]');
                updateData();
                that.updateDisplay();
                $.publish('search/where/update');
                $dfd.resolve(true);
                that.manageSelectAllClearAll();
                that.checkStatus();
                // that.updateWidth(); // not required after search panels are inline without scrollbar
                // that.addScrollbar();
            });
            return $dfd.promise();
        },

        addScrollbar: function() {
            var panel = that.ele.find('.panel');
            panel.removeAttr('style');

            var scroll = that.ele.find('.enscroll-track').parent();

            that.ele.find('.enscroll-track').parent().remove();

            if (!TUIUtil.istabletOrDesktop()) {
                panel.css({
                    'overflow': 'auto'
                });
                $(scroll).remove();

                panel.enscroll({
                    verticalTrackClass: 'track4',
                    verticalHandleClass: 'handle4',
                    minScrollbarLength: 20,
                    pollChanges: true,
                    easingDuration: 100
                });
            }

        },
        updateWidth: function() {
            var panel = that.ele.find('.panel'),
                scrollablePanel = panel.find('.airports-flyout');
            scrollablePanel.width(panel.width() - 12);
        },
        setMaxHeight: function(panelHeight) {
            var flyout = that.ele.find('.airports-flyout'),
                delay = 0;
            if (!flyout.length) {
                delay = 2000;
            }
            /*setTimeout(function(){
				flyout.css('max-height', panelHeight - 100);
			},delay);*/
            flyout.css('max-height', panelHeight - 100);
        },

        /**
         * Updates placeholder or tags in airport field
         * @param  {[type]} airportNameArray [This is airport name array]
         * @return {[type]}            [none]
         */
        updateInputText: function(airportString) {
            that.parentInput.val(airportString);
            if (!airportString) {
                var placeHolderText = '<span class="placeholder-text">' + that.parentInput.data('placeholder') + '</span>';
                that.parentInput.empty().html(placeHolderText);
                that.parentInput.attr('title', that.parentInput.data('placeholder'));
            } else {
                var i,
                    tagHtml = '<ul>';
                tagHtml += '<li>';
                tagHtml += '<span>';
                tagHtml += airportString;
                tagHtml += '</span>';
                tagHtml += '<span class="icon-close-circle">';
                tagHtml += '</li>';

                tagHtml += '</ul>';
                that.parentInput.attr('title', getFirstAirportName());
                that.parentInput.html(tagHtml);
            }
        }

    };

    function getFirstAirportName() {
        var firstAirport = $(airportsContainer).find('.airport-list-wrapper').find('input[type="checkbox"]:checked').first();
        return firstAirport.data('airportname');

    }

    function getTotalCountOfAirports() {
        return $(airportsContainer).find('.airport-list-wrapper').find('input[type="checkbox"]').length;
    }

    function updateData() {
        var selectedCount = 0,
            $t;
        that.ele.find('input[type="checkbox"]').each(function() {
            $t = $(this);
            if ($t.attr('id') === 'selectAll-airports-to') {
                return;
            }
            if ($t.is(':checked') && $t.parents('dt[data-group]').length === 0) {
                selectedCount++;
                that.selectedAirportsTo[that.selectedAirportsTo.length] = $.trim($t.val());
            }
        });
        that.count = selectedCount;

        if (that.count < 0) {
            that.count = 0;
        }
        that.formData.selectedAirportsTo = that.selectedAirportsTo;
    }

    /**
     * Returns the text length that should be trimmed based on the input .
     * @param  {[type]} fieldWidth [description]
     * @param  {[type]} reduceBy   [description]
     * @return {[type]}            [description]
     */
    function returnTextLength(fieldWidth, reduceBy) {
        if (typeof fieldWidth === 'string' && fieldWidth.indexOf('px')) {
            fieldWidth = fieldWidth.split('px')[0];
        }
        var ratio = 13 / 104;
        var textLength = fieldWidth * ratio;
        textLength = Math.floor(textLength);
        if (reduceBy) {
            textLength -= reduceBy;
        }
        return textLength;
    }

    /**
     * Fly the selected checkbox to airport field
     * @param  {Function} cb [description]
     * @return {[type]}      [description]
     */
    var flySpan = function(cb) {
        var curHTML = cb.next().html(),
            spanClone = '<span class="flyingspan">' + curHTML + '</span>',
            offsetTopField = $('#airport-to').offset().top,
            offsetLeftField = $('#airport-to').offset().left,
            offsetTopEle = cb.parent().offset().top,
            offsetLeftEle = cb.parent().offset().left,
            reqOffsetTop = offsetTopField - offsetTopEle,
            reqOffsetLeft = offsetLeftField - offsetLeftEle;

        $(spanClone).appendTo($('body')).css({
            top: offsetTopEle,
            left: offsetLeftEle
        }).animate({
            top: offsetTopField + 15 + 'px',
            left: offsetLeftField + 'px'
        }, that.opts.speed, function() {
            $('.flyingspan').fadeOut(that.opts.speed, function() {
                $('.flyingspan').remove();
                that.controller.scrollTillSearchPanel();
            });
        });
    };

    function markSelected(cb) {
        cb = $(cb);

        if (cb.hasClass('select-all-selected')) {
            return;
        }
        var curDataGroup,
            $siblingsDD,
            groupUncheckedCount;
        if (cb.is(':checked')) {
            if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                flySpan(cb);
            } else {
                that.controller.scrollTillSearchPanel();
            }
            that.count = that.count + 1;
        } else { // UNCHECKED
            that.count = that.count - 1;
            if ($.inArray($.trim(cb.val()), that.selectedAirportsTo) > -1) {
                var curIndex = that.selectedAirportsTo.indexOf($.trim(cb.val()));
                that.selectedAirportsTo.splice(curIndex, 1);
            }
            if (that.count < 0) {
                that.count = 0;
            }
        }
    }

    for (var key in methods) {
        SearchWhereTo.prototype[key] = methods[key];
    }

    return SearchWhereTo;
});


define('text!search-panel/templates/tab-destinations.hbs', [], function() {
    return '<!--Best For Destinations templates start-->\n <!--script id="destination-collection" type="text/x-handlebars-template"-->\n\t <!--<article class="dest-content destination" data-tabcontent="destination">-->\n\t \t<ul class="image-list group">\n\t \t{{#each destination}}\n\t \t\t<li class="col-lg-2 col-md-3 {{#if selected}}selected{{/if}} {{#if disabled}}disabled{{/if}}"  data-destinations="{{data-values}}" data-code="{{dataCode data-values}}">\n\t \t\t{{#if disabled}}<div class="overlay"></div>{{/if}}\n\t \t\t\t<figure>\n\t \t\t\t\t<div class="media">\n\n\t\t\t\t\t\t\t<p>\n\t\t\t\t\t\t\t\t<span class="checked-icon"></span>\n\t\t\t\t\t\t\t</p>\n\t\t \t\t\t\t\t<span class="concept-logo {{icon-class}} {{#if customclass}}defaultIcon{{/if}}">\n\t\t \t\t\t\t\t{{#if customclass}}{{name}}{{/if}}\n\t\t \t\t\t\t\t</span>\n\n\t\t \t\t\t\t\t<img class="lazyload-img" src="{{img-path}}" alt="{{img-alt}}">\n\n\t\t \t\t\t\t\t<!--img class="lazyload-img" src="" alt="{{img-alt}}" data-x-small="{{imgXSmall}}" data-small="{{imgSmall}}" data-medium="{{imgMedium}}" data-large="{{imgLarge}}"-->\n\t\t \t\t\t\t\t<figcaption>\n\t\t\t \t\t\t\t\t<div class="dest-selected">\n\t\t\t \t\t\t\t\t\t<input type="checkbox" {{#if selected}}checked{{/if}} {{#if disabled}}disabled{{/if}} name="conceptTitle" class="custom-checkbox {{#if disabled}}disabled {{/if}}" value="title">\n\n\t\t\t \t\t\t\t\t\t<label for="{{name}}"  class="custom-label {{#if disabled}}disabled{{/if}}" ><span class="dest-title" title="{{name}}">{{name}} </span></label>\n\n\t\t\t \t\t\t\t\t\t<span class="dest-sub" title="{{regionText region}}"> {{regionText region}}</span>\n\t\t \t\t\t\t\t\t</div>\n\t\t \t\t\t\t\t</figcaption>\n\t \t\t\t\t</div>\n\t \t\t\t</figure>\n\t \t\t</li>\n \t\t{{/each}}\n\t \t</ul>\n\t <!--/article-->\n <!--/script-->\n<!--Destination Collection templates ends-->\n';
});

/* global window, define */
define('common/tabs', ['jquery',
    'handlebars',
    'text!search-panel/templates/tab-destinations.hbs'
], function($, Handlebars, tabTemplate) {
    function Tabs(ele, opts) {
        this.ele = ele;
        this.opts = $.extend({}, {
            callback: false,
            tabClasses: [],
            triggerSelector: 'ul.tabs a',
            hashChange: false,
            ajaxService: opts.ajaxService || false
        }, opts);
        this.tabTemplate = Handlebars.compile(tabTemplate);
        this.current = this.opts.tabClasses[0];
        this.currentHash = false;
        this.newHash = null;
        this.init();
    }
    var that;
    var methods = {
        init: function() {
            that = this;
            // bind events
            this.ele.on('click', this.opts.triggerSelector, $.proxy(that.switchView, that));

            if (this.opts.hashChange) {
                window.onhashchange = function(e) {
                    that.navigateToHash(e);
                };
                this.navigateToHash({
                    type: null
                });
            }

        },
        switchView: function(e) {

            var anchor = $(e.currentTarget);
            var redirect = anchor.data('href');
            if (redirect) {
                window.location.href = redirect;
                return true;
            }
            if (!this.opts.hashChange) {
                e.preventDefault();
            }

            var tabName = e.currentTarget.getAttribute('data-tabName') || e.currentTarget.getAttribute('href') || '',
                $ele = $(e.currentTarget);

            if (this.opts.ignoreActiveTabClick && anchor.hasClass('active')) {
                return false;
            }
            // add class to wrapper
            this.ele
                .removeClass(this.opts.tabClasses.join(' '))
                .addClass(tabName);
            // }
            // set tab state
            $ele
                .parent()
                .siblings()
                .find('a.active')
                .removeClass('active')
                .end()
                .end()
                .end()
                .addClass('active');

            this.current = tabName;
            // fire any additional callback if defined
            this.callback(tabName);
        },
        callback: function(tabName) {
            if (this.opts.hashChange && this.currentHash === this.newHash) {
                return;
            }
            this.currentHash = this.newHash;
            if (!this.opts.callback || !tabName) {
                return;
            }
            if (typeof this.opts.callback === 'function') {
                this.opts.callback(tabName);
                return;
            }
            if (this.opts.callback[tabName]) {
                this.opts.callback[tabName]();
            }
        },
        navigateToHash: function() {
            var hash = window.location.hash,
                trigger;
            if (hash.length) {
                hash = hash.replace('#', '');
                this.newHash = hash;

                // check if the hash is availble within the tab set

                trigger = this.ele.find(this.opts.triggerSelector)
                    .filter('[data-tabName="' + hash + '"]').click();

            } else {
                return false;
            }
        },
        loadData: function(ele, tabname) {
            var serviceUrl = ele.data('service');
            var elemContainer = ele.closest('[data-role=tabWrapper]').find('[data-tabcontent=' + tabname + ']');
            if (tabname !== 'allDestinations') {
                elemContainer.parent().find('article').hide();
                elemContainer.show().empty();
                TUIUtil.toggleLoader(elemContainer);
                $.ajax({
                    url: serviceUrl,
                    type: 'POST',
                    data: {
                        'name': 'xyz'
                    }
                }).done(function(data) {
                    data = $.parseJSON(data);
                    elemContainer.empty().html(that.tabTemplate(data));
                }).error(function() {});
            } else {
                var allDestinations = $('.all-destinations');
                allDestinations.parent().find('article').hide();
                allDestinations.show();
            }
        }
    };

    for (var key in methods) {
        Tabs.prototype[key] = methods[key];
    }

    return Tabs;
});
define(
    'search-panel/search-tabs', ['base', 'jquery', 'jqueryCookie', 'common/tabs', 'vendor/owl.carousel.search'],
    function(base, $, jqueryCookie, Tabs, owlCarousel) {
        function SearchTabs(ele, opts) {
            if (!ele || !ele.length) {
                return false;
            }
            this.ele = ele;
            this.opts = $.extend({}, {
                tabClasses: [
                    'package',
                    'flight',
                    'hotel'
                ],
                emotionalHeader: $('#emotional-header'),
                searchNowBtn: $('#searchNowBtn'),
                responseURL: tuiConfig.search.responseURL
            }, opts);
            this.controller = opts.controller;

            this.init();
        }

        var that,
            form = $('.search-panel form'),
            searchPanel = [],
            delta = 5,
            searchTabs = $('#search-panel-tabs'),
            tabContainer = searchTabs.find('.tab-nav'),
            listContainer = searchTabs.find('.tab-nav-list'),
            leftShade = searchTabs.find('.fade-left'),
            rightShade = searchTabs.find('.fade-right'),
            methods = {
                init: function() {

                    that = this;
                    searchPanel = that.controller.ele;
                    that.tabs = new Tabs(searchPanel, {
                        triggerSelector: '#search-panel-tabs button',
                        tabClasses: [
                            'package',
                            'flight',
                            'hotel'
                        ],
                        ignoreActiveTabClick: true,
                        callback: that.switchFieldOrders
                    });
                    that.checkIfNoTabs();
                    that.updateSearchOnCookieType();
                    that.pageLoad = true;
                    if (that.getSearchMode('SEARCH_TYPE')) {
                        that.ele.find('button[data-tabname="' + that.getSearchMode('SEARCH_TYPE') + '"]').trigger('click');
                    }
                    that.pageLoad = false;

                    // that.bindTouchEvents();

                },
                checkIfNoTabs: function() {
                    if (!that.ele.find('.tab-nav-list').find('li').length) {
                        that.ele.hide();
                        that.controller.ele.addClass('no-tabs');
                    }
                },

                /*bindTouchEvents: function() {
				listContainer.on('touchend', function (event) {
					clearTimeout($.data(this, 'scrollTimer'));
					$.data(this, 'scrollTimer', setTimeout( that.swipeCallback, 200));
				});
			},

			swipeCallback: function() {
				var containerWidth = tabContainer.width(),
					listWidth = listContainer.width(),
					visibleArea = listWidth - containerWidth - delta,
					scrollBarPosition = tabContainer.scrollLeft();
					that.monitorScrolling(scrollBarPosition, visibleArea);
			},

			monitorScrolling: function(scrollBarPosition , visibleArea) {
				that.lastScrollbarPosition = scrollBarPosition;
				var iteration = 0;
				var monitorMomentum = setTimeout(function() {
					if (iteration > 15) {
						clearTimeout(monitorMomentum);
						return;
					}
					iteration+=1;
					clearTimeout(monitorMomentum);
					that.currentScrollbarPosition = tabContainer.scrollLeft();

					if (that.lastScrollbarPosition === that.currentScrollbarPosition) {
						that.showHideFading(that.currentScrollbarPosition, visibleArea);
					}
					else {
						that.lastScrollbarPosition = that.currentScrollbarPosition;
						that.monitorScrolling(that.lastScrollbarPosition, visibleArea);
					}
				}, 250);
			},

			showHideFading: function(scrollBarPosition, visibleArea) {
				if (scrollBarPosition <= delta) {
					rightShade.removeClass('hide');
					rightShade.addClass('show');
					leftShade.removeClass('show');
					leftShade.addClass('hide');
				}
				else if (scrollBarPosition >= visibleArea) {
					leftShade.removeClass('hide');
					leftShade.addClass('show');
					rightShade.removeClass('show');
					rightShade.addClass('hide');
				}
				else {
					rightShade.removeClass('hide');
					rightShade.addClass('show');
					leftShade.removeClass('hide');
					leftShade.addClass('show');
				}
			},*/

                getSearchMode: function(cookieName) {
                    return $.cookie(cookieName) || 'package';
                },
                switchFieldOrders: function(tabClass) {
                    var tab = that.ele.find('button[data-tabname="' + tabClass + '"]');

                    var tabName = tabClass;
                    // var destinationOrder = tab.data('destination-order');
                    // if (destinationOrder === 'right') {
                    // 	$('.field-search').removeClass('left').addClass('right').css('float', 'right');
                    // 	$('.field-airport').removeClass('right').addClass('left').css('float', 'left');
                    // }
                    // else {
                    // 	$('.field-search').removeClass('right').addClass('left').css('float', 'left');
                    // 	$('.field-airport').removeClass('left').addClass('right').css('float', 'right');
                    // }
                    searchPanel.removeClass('package').removeClass('hotel').removeClass('flight');
                    if (tabName === 'flight') {
                        searchPanel.addClass('flight');
                        that.updateActiveButtonTab(tab, 'flight');
                        that.updateSearchTypeCookie('flight');

                    } else if (tabName === 'package') {
                        searchPanel.addClass('package');
                        that.updateActiveButtonTab(tab, 'package');
                        that.updateSearchTypeCookie('package');

                    } else if (tabName === 'hotel') {
                        searchPanel.addClass('hotel');
                        that.updateActiveButtonTab(tab, 'hotel');
                        that.updateSearchTypeCookie('hotel');
                    } else {
                        that.updateActiveButtonTab(tab);
                    }
                    $.publish('search_mode_changed');
                    if (!that.pageLoad && $('#result-page-wrapper').length) {
                        that.redirectToSearchPage();
                    }
                },
                /**
                 * Search Type stored in cookie for page refresh
                 * @param  {[type]} type [description]
                 * @return {[type]}      [description]
                 */
                updateSearchTypeCookie: function(type) {
                    $.cookie('SEARCH_TYPE', type || 'package', {
                        expires: 30,
                        path: '/'
                    });
                },
                updateActiveButtonTab: function(activeTab, tabName) {
                    $(activeTab).parents('.tab-nav-list').find('.tab-btn').removeClass('active');
                    $(activeTab).addClass('active');

                    if ($(activeTab).data('href')) {
                        window.location.href = $(activeTab).data('href');
                    }
                    if (tabName) {
                        that.updateSearchOnCookieType(tabName);
                    }
                },
                createCookieJSON: function(searchType) {
                    var cookieData = {};
                    if (searchType === 'flight') {
                        cookieData.searchType = 'flightvalues';
                        cookieData.partyType = 'FLIGHT_PARTY_COOKIE';
                    } else {
                        cookieData.searchType = 'formvalues';
                        cookieData.partyType = 'PARTY_COOKIE';
                    }
                    return cookieData;
                },
                updateSearchOnCookieType: function(tabName) {
                    var searchType = tabName || that.getSearchMode('SEARCH_TYPE');
                    if (searchType) {
                        var cJSON = that.createCookieJSON(searchType),
                            partyCookie = that.controller.getCookie(cJSON.partyType),
                            cookieValue = that.controller.getCookie(cJSON.searchType);
                        if (cookieValue) {
                            that.controller.setFormValues($.parseJSON(cookieValue));
                            if (partyCookie) {
                                that.controller.setPartyFromCookie($.parseJSON(partyCookie));
                            } else {
                                that.controller.setPartyFromCookie(null);
                            }
                        } else {
                            that.controller.setFormValues(that.controller.getFormValues(), true);
                            that.controller.setPartyFromCookie(null);
                        }

                    }
                },
                redirectToSearchPage: function() {
                    if (that.ele.data('searchpagepath') || $('[data-searchpagepath]').length) {
                        var path = that.ele.data('searchpagepath') || $('[data-searchpagepath]').data('searchpagepath');
                        window.location.href = path;
                    }
                }

            };
        SearchTabs.prototype = $.extend({}, SearchTabs.prototype, methods);
        return SearchTabs;
    });

/* globals Image */
define('emotional-header/emotional-header', ['jquery', 'pubSub'], function($) {
    function EmotionalHeader(ele, opts) {
        this.ele = ele;
        this.opts = $.extend({}, {}, opts);
        this.img = ele.find('div.img img');
        this.init();
    }

    var methods = {
        init: function() {
            var that = this;
            $.subscribe('emotionalHeader.swapImg', function() {
                that.swapImg(arguments[1]);
            });
        },
        swapImg: function(src) {
            if (!src) {
                return;
            }
            var img = new Image(),
                that = this;
            img.onload = function() {
                that.img.attr('src', src);
            };
            img.src = src;
        }
    };

    for (var key in methods) {
        EmotionalHeader.prototype[key] = methods[key];
    }

    return EmotionalHeader;
});

/*global jQuery:false*/

/**
 * enscroll.js - jQuery plugin to add custom scrollbars to HTML block elements
 * Copyright (C) 2012 Jason T. Stoudt
 * Released under the MIT license
 * http://enscrollplugin.com/license.html
 **/

;
(function($, win, doc, undefined) {

    var defaultSettings = {
            verticalScrolling: true,
            horizontalScrolling: false,
            verticalScrollerSide: 'right',
            showOnHover: false,
            scrollIncrement: 20,
            minScrollbarLength: 40,
            pollChanges: true,
            drawCorner: true,
            drawScrollButtons: false,
            clickTrackToScroll: true,
            easingDuration: 500,
            propagateWheelEvent: true,
            verticalTrackClass: 'vertical-track',
            horizontalTrackClass: 'horizontal-track',
            horizontalHandleClass: 'horizontal-handle',
            verticalHandleClass: 'vertical-handle',
            scrollUpButtonClass: 'scroll-up-btn',
            scrollDownButtonClass: 'scroll-down-btn',
            scrollLeftButtonClass: 'scroll-left-btn',
            scrollRightButtonClass: 'scroll-right-btn',
            cornerClass: 'scrollbar-corner',
            zIndex: 1,
            addPaddingToPane: true,
            horizontalHandleHTML: '<div class="left"></div><div class="right"></div>',
            verticalHandleHTML: '<div class="top"></div><div class="bottom"></div>'
        },

        preventDefault = function(event) {
            if (event.preventDefault) {
                event.preventDefault();
            } else {
                event.returnValue = false;
            }

            if (event.stopPropagation) {
                event.stopPropagation();
            } else {
                event.cancelBubble = true;
            }
        },

        // normalize requestAnimationFrame function and polyfill if needed
        reqAnimFrame = win.requestAnimationFrame ||
        win.mozRequestAnimationFrame ||
        win.webkitRequestAnimationFrame ||
        win.oRequestAnimationFrame ||
        win.msRequestAnimationFrame ||
        function(f) {
            setTimeout(f, 17);
        },

        getComputedValue = function(elem, property) {
            var w = $(elem).css(property),
                matches = /^-?\d+/.exec(w);
            return matches ? +matches[0] : 0;
        },

        testScrollHeight = function(nodeName) {
            var styles = {
                    width: '5px',
                    height: '1px',
                    overflow: 'hidden',
                    padding: '8px 0',
                    visibility: 'hidden',
                    whiteSpace: 'pre-line',
                    font: '10px/1 serif'
                },
                pane = document.createElement(nodeName),
                textNode = document.createTextNode('a\na'),
                result, attr;

            for (attr in styles) {
                pane.style[attr] = styles[attr];
            }

            pane.appendChild(textNode);
            document.body.appendChild(pane);

            result = (pane.scrollHeight < 28);

            document.body.removeChild(pane);

            return result;
        },

        PI_OVER_2 = 0.5 * Math.PI,

        TEN_LOG2 = 10 * Math.log(2),

        easeOutSin = function(c, d, t) {
            var b = PI_OVER_2 / d,
                a = c * b;

            return Math.round(a * Math.cos(b * t));
        },

        easeOutExpo = function(c, d, t) {
            return Math.round(c * TEN_LOG2 * Math.pow(2, -10 * t / d + 1) / d);
        },

        timeFromPosition = function(b, c, d, x) {
            return 2 * d / Math.PI * Math.asin((x - b) / c);
        },

        showScrollbars = function(scheduleHide) {
            var data = $(this).data('enscroll'),
                that = this,
                settings = data.settings,
                hideScrollbars = function() {
                    var data = $(this).data('enscroll'),
                        settings = data.settings;

                    if (data && settings.showOnHover) {
                        if (settings.verticalScrolling &&
                            $(data.verticalTrackWrapper).is(':visible')) {
                            $(data.verticalTrackWrapper).stop().fadeTo(275, 0);
                        }

                        if (settings.horizontalScrolling &&
                            $(data.horizontalTrackWrapper).is(':visible')) {
                            $(data.horizontalTrackWrapper).stop().fadeTo(275, 0);
                        }
                        data._fadeTimer = null;
                    }
                };

            if (data && settings.showOnHover) {
                if (data._fadeTimer) {
                    clearTimeout(data._fadeTimer);
                } else {
                    if (settings.verticalScrolling &&
                        $(data.verticalTrackWrapper).is(':visible')) {
                        $(data.verticalTrackWrapper).stop().fadeTo(275, 1);
                    }

                    if (settings.horizontalScrolling &&
                        $(data.horizontalTrackWrapper).is(':visible')) {
                        $(data.horizontalTrackWrapper).stop().fadeTo(275, 1);
                    }
                }

                if (scheduleHide !== false) {
                    data._fadeTimer = setTimeout(function() {
                        hideScrollbars.call(that);
                    }, 1750);
                }
            }
        },

        scrollVertical = function(pane, dy) {
            var $pane = $(pane),
                data = $pane.data('enscroll'),
                y0 = $pane.scrollTop();

            if (data && data.settings.verticalScrolling) {
                $pane.scrollTop(y0 + dy);
                if (data.settings.showOnHover) {
                    showScrollbars.call(pane);
                }
            }
        },

        scrollHorizontal = function(pane, dx) {
            var $pane = $(pane),
                data = $pane.data('enscroll'),
                x0 = $pane.scrollLeft();
            if (data && data.settings.horizontalScrolling) {
                $pane.scrollLeft(x0 + dx);
                if (data.settings.showOnHover) {
                    showScrollbars.call(pane);
                }
            }
        },

        startVerticalDrag = function(event) {
            // only handle events for left mouse button dragging
            if (event.which !== 1) {
                return;
            }

            var pane = event.data.pane,
                $pane = $(pane),
                data = $pane.data('enscroll'),
                dragging = true,
                $track, handle, handleY, oldHandleY, mouseYOffset,
                trackYOffset, bodyCursor, trackDiff, paneDiff,

                moveHandle = function() {
                    if (!dragging) {
                        return;
                    }

                    if (handleY !== oldHandleY) {
                        if (!data._scrollingY) {
                            data._scrollingY = true;
                            data._startY = $pane.scrollTop();
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }

                        handle.style.top = handleY + 'px';

                        data._endY = handleY * paneDiff / trackDiff;
                        oldHandleY = handleY;
                    }

                    reqAnimFrame(moveHandle);

                    if (data.settings.showOnHover) {
                        showScrollbars.call(pane);
                    }
                },

                moveDrag = function(event) {
                    if (dragging) {
                        handleY = event.clientY - trackYOffset - mouseYOffset;
                        handleY = Math.min(handleY < 0 ? 0 : handleY, trackDiff);
                    }
                    return false;
                },

                endDrag = function() {
                    dragging = false;

                    doc.body.style.cursor = bodyCursor;
                    this.style.cursor = '';
                    $track.removeClass('dragging');

                    $(doc.body)
                        .off('mousemove.enscroll.vertical')
                        .off('mouseup.enscroll.vertical');

                    $(doc).off('mouseout.enscroll.vertical');

                    $pane.on('scroll.enscroll.pane', function(event) {
                        paneScrolled.call(this, event);
                    });

                    return false;
                };

            $track = $(data.verticalTrackWrapper).find('.enscroll-track');
            handle = $track.children().first()[0];
            handleY = parseInt(handle.style.top, 10);
            paneDiff = pane.scrollHeight -
                (data._scrollHeightNoPadding ? $(pane).height() : $(pane).innerHeight());

            mouseYOffset = event.clientY - $(handle).offset().top;
            trackDiff = $track.height() - $(handle).outerHeight();
            trackYOffset = $track.offset().top;

            $pane.off('scroll.enscroll.pane');

            $(doc.body).on({
                'mousemove.enscroll.vertical': moveDrag,
                'mouseup.enscroll.vertical': function(event) {
                    endDrag.call(handle, event);
                }
            });

            $(doc).on('mouseout.enscroll.vertical', function(event) {
                if (event.target.nodeName && event.target.nodeName.toUpperCase() === 'HTML') {
                    endDrag.call(handle, event);
                }
            });

            if (!$track.hasClass('dragging')) {
                $track.addClass('dragging');
                bodyCursor = $(doc.body).css('cursor');
                this.style.cursor = doc.body.style.cursor = 'ns-resize';
            }

            reqAnimFrame(moveHandle);

            return false;
        },

        startHorizontalDrag = function(event) {
            // dragging the scrollbar handle only works with left mouse button
            if (event.which !== 1) {
                return;
            }

            var pane = event.data.pane,
                $pane = $(pane),
                data = $(pane).data('enscroll'),
                dragging = true,
                $track, handle, handleX, oldHandleX, paneDiff,
                mouseXOffset, trackXOffset, bodyCursor, trackDiff,

                moveHandle = function() {
                    if (!dragging) {
                        return;
                    }

                    if (handleX !== oldHandleX) {
                        if (!data._scrollingX) {
                            data._scrollingX = true;
                            data._startX = $pane.scrollLeft();
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }

                        handle.style.left = handleX + 'px';

                        data._endX = handleX * paneDiff / trackDiff;
                        oldHandleX = handleX;
                    }

                    reqAnimFrame(moveHandle);

                    if (data.settings.showOnHover) {
                        showScrollbars.call(pane);
                    }
                },

                moveDrag = function(event) {
                    if (dragging) {
                        handleX = event.clientX - trackXOffset - mouseXOffset;
                        handleX = Math.min(handleX < 0 ? 0 : handleX, trackDiff);
                    }
                    return false;
                },

                endDrag = function() {
                    dragging = false;

                    $track.removeClass('dragging');

                    doc.body.style.cursor = bodyCursor;
                    this.style.cursor = '';
                    $track.removeClass('dragging');

                    $(doc.body)
                        .off('mousemove.enscroll.horizontal')
                        .off('mouseup.enscroll.horizontal');

                    $(doc).off('mouseout.enscroll.horizontal');

                    $pane.on('scroll.enscroll.pane', function(event) {
                        paneScrolled.call(this, event);
                    });

                    return false;
                };

            $track = $(data.horizontalTrackWrapper).find('.enscroll-track');
            handle = $track.children().first()[0];
            handleX = parseInt(handle.style.left, 10);
            paneDiff = pane.scrollWidth - $(pane).innerWidth();
            mouseXOffset = event.clientX - $(handle).offset().left;
            trackDiff = $track.width() - $(handle).outerWidth();
            trackXOffset = $track.offset().left;

            $pane.off('scroll.enscroll.pane');

            $(doc.body).on({
                'mousemove.enscroll.horizontal': moveDrag,
                'mouseup.enscroll.horizontal': function(event) {
                    endDrag.call(handle, event);
                }
            });

            $(doc).on('mouseout.enscroll.horizontal', function(event) {
                if (event.target.nodeName && event.target.nodeName.toUpperCase() === 'HTML') {
                    endDrag.call(handle, event);
                }
            });

            if (!$track.hasClass('dragging')) {
                $track.addClass('dragging');
                bodyCursor = $('body').css('cursor');
                this.style.cursor = doc.body.style.cursor = 'ew-resize';
            }

            reqAnimFrame(moveHandle);

            return false;

        },

        scrollAnimate = function($pane) {
            var data = $pane.data('enscroll'),
                d = data._duration,
                c, curPos, t;

            if (data._scrollingX === true) {
                c = data._endX - data._startX;
                if (c === 0) {
                    data._scrollingX = false;
                } else {
                    curPos = $pane.scrollLeft();
                    t = timeFromPosition(data._startX, c, d, curPos);
                    if (c > 0) {
                        if (curPos >= data._endX || curPos < data._startX) {
                            data._scrollingX = false;
                        } else {
                            scrollHorizontal($pane,
                                Math.max(1, easeOutSin(c, d, t)));
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }
                    } else {
                        if (curPos <= data._endX || curPos > data._startX) {
                            data._scrollingX = false;
                        } else {
                            scrollHorizontal($pane,
                                Math.min(-1, easeOutSin(c, d, t)));
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }
                    }
                }
            }

            if (data._scrollingY === true) {
                c = data._endY - data._startY;
                if (c === 0) {
                    data._scrollingY = false;
                } else {
                    curPos = $pane.scrollTop();
                    t = timeFromPosition(data._startY, c, d, curPos);
                    if (c > 0) {
                        if (curPos >= data._endY || curPos < data._startY) {
                            data._scrollingY = false;
                        } else {
                            scrollVertical($pane,
                                Math.max(1, easeOutSin(c, d, t)));
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }
                    } else {
                        if (curPos <= data._endY || curPos > data._startY) {
                            data._scrollingY = false;
                        } else {
                            scrollVertical($pane,
                                Math.min(-1, easeOutSin(c, d, t)));
                            reqAnimFrame(function() {
                                scrollAnimate($pane);
                            });
                        }
                    }
                }
            }

        },

        scrollAnimateHorizontal = function($pane, delta) {
            var data = $pane.data('enscroll'),
                curPos = $pane.scrollLeft(),
                scrollMax = $pane[0].scrollWidth - $pane.innerWidth();

            if (!data.settings.horizontalScrolling || data._scrollingY) {
                return false;
            }

            if (!data._scrollingX) {
                data._scrollingX = true;
                data._startX = curPos;
                data._endX = data._startX;
                reqAnimFrame(function() {
                    scrollAnimate($pane);
                });
            }

            data._endX = delta > 0 ? Math.min(curPos + delta, scrollMax) :
                Math.max(0, curPos + delta);

            return delta < 0 && curPos > 0 || delta > 0 && curPos < scrollMax;
        },

        scrollAnimateVertical = function($pane, delta) {
            var data = $pane.data('enscroll'),
                curPos = $pane.scrollTop(),
                scrollMax = $pane[0].scrollHeight - (data._scrollHeightNoPadding ? $pane.height() : $pane.innerHeight());

            if (!data.settings.verticalScrolling || data._scrollingX) {
                return false;
            }

            if (!data._scrollingY) {
                data._scrollingY = true;
                data._startY = curPos;
                data._endY = data._startY;
                reqAnimFrame(function() {
                    scrollAnimate($pane);
                });
            }

            data._endY = delta > 0 ? Math.min(curPos + delta, scrollMax) :
                Math.max(0, curPos + delta);

            return delta < 0 && curPos > 0 || delta > 0 && curPos < scrollMax;
        },

        mouseScroll = function(event) {
            var $pane = $(this),
                data = $pane.data('enscroll'),
                scrollIncrement = data.settings.scrollIncrement,
                deltaX = 'deltaX' in event ? -event.deltaX :
                'wheelDeltaX' in event ? event.wheelDeltaX :
                0,
                deltaY = 'deltaY' in event ? -event.deltaY :
                'wheelDeltaY' in event ? event.wheelDeltaY :
                'wheelDelta' in event ? event.wheelDelta :
                0,
                delta;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                delta = (deltaX > 0 ? -scrollIncrement : scrollIncrement) << 2;
                if (scrollAnimateHorizontal($pane, delta) || !data.settings.propagateWheelEvent) {
                    preventDefault(event);
                }
            } else {
                delta = (deltaY > 0 ? -scrollIncrement : scrollIncrement) << 2;
                if (scrollAnimateVertical($pane, delta) || !data.settings.propagateWheelEvent) {
                    preventDefault(event);
                }
            }
        },

        paneScrolled = function() {
            var $this = $(this),
                data = $this.data('enscroll'),
                handle, track, pct;

            if (data) {
                if (data.settings.verticalScrolling) {
                    track = $(data.verticalTrackWrapper).find('.enscroll-track')[0];
                    handle = track.firstChild;
                    pct = $this.scrollTop() / (this.scrollHeight - (data._scrollHeightNoPadding ? $this.height() : $this.innerHeight()));
                    pct = isNaN(pct) ? 0 : pct;

                    handle.style.top = (pct * ($(track).height() - $(handle).outerHeight())) + 'px';
                }

                if (data.settings.horizontalScrolling) {
                    track = $(data.horizontalTrackWrapper).find('.enscroll-track')[0];
                    handle = track.firstChild;
                    pct = $this.scrollLeft() / (this.scrollWidth - $this.innerWidth());
                    pct = isNaN(pct) ? 0 : pct;

                    handle.style.left = (pct * ($(track).width() - $(handle).innerWidth())) + 'px';
                }
            }
        },

        keyHandler = function(event) {
            var $this = $(this),
                data = $this.data('enscroll'),
                scrollIncrement;

            // dont' have key events if this element is a user-input element
            if (/(input)|(select)|(textarea)/i.test(this.nodeName)) {
                return;
            }

            // don't handle events that have just bubbled up
            if (event.target === this && data) {
                scrollIncrement = data.settings.scrollIncrement;

                switch (event.keyCode) {
                    case 32: // space
                    case 34: // page down
                        scrollAnimateVertical($this, $this.height());
                        return false;
                    case 33: // page up
                        scrollAnimateVertical($this, -$this.height());
                        return false;
                    case 35: // end
                        scrollAnimateVertical($this, this.scrollHeight);
                        return false;
                    case 36: // home
                        scrollAnimateVertical($this, -this.scrollHeight);
                        return false;
                    case 37: // left
                        scrollAnimateHorizontal($this, -scrollIncrement);
                        return false;
                    case 38: // up
                        scrollAnimateVertical($this, -scrollIncrement);
                        return false;
                    case 39: // right
                        scrollAnimateHorizontal($this, scrollIncrement);
                        return false;
                    case 40: // down
                        scrollAnimateVertical($this, scrollIncrement);
                        return false;
                }

                return true;
            }
        },

        dragHandler = function() {
            var pane = this,
                settings = $(pane).data('enscroll').settings,
                dragging = true,
                deltaX = 0,
                deltaY = 0,
                paneTop = $(pane).offset().top,
                paneBottom = paneTop + $(pane).outerHeight(),
                paneLeft = $(pane).offset().left,
                paneRight = paneLeft + $(pane).outerWidth(),
                dragMove = function(event) {
                    var x = event.pageX,
                        y = event.pageY;

                    deltaX = x < paneLeft ? x - paneLeft :
                        x > paneRight ? x - paneRight :
                        0;

                    deltaY = y < paneTop ? y - paneTop :
                        y > paneBottom ? y - paneBottom :
                        0;
                },

                dragPoll = function() {
                    if (settings.horizontalScrolling && deltaX) {
                        scrollHorizontal(pane, parseInt(deltaX / 4, 10));
                    }
                    if (settings.verticalScrolling && deltaY) {
                        scrollVertical(pane, parseInt(deltaY / 4, 10));
                    }
                    if (dragging) {
                        reqAnimFrame(dragPoll);
                    }
                },

                dragEnd = function() {
                    dragging = false;
                    $(doc)
                        .off('mousemove.enscroll.pane')
                        .off('mouseup.enscroll.pane');
                };

            reqAnimFrame(dragPoll);

            $(doc).on({
                'mousemove.enscroll.pane': dragMove,
                'mouseup.enscroll.pane': dragEnd
            });
        },

        touchStart = function(event) {
            var touchX, touchY, touchAxis, touchX0, touchY0, touchStarted, touchDelta,
                pane = this,
                touchMove = function(event) {
                    touchX = event.touches[0].clientX;
                    touchY = event.touches[0].clientY;

                    if (!touchAxis) {
                        touchAxis = touchY === touchY0 && touchX === touchX0 ? undefined :
                            Math.abs(touchY0 - touchY) > Math.abs(touchX0 - touchX) ? 'y' :
                            'x';
                    }

                    preventDefault(event);
                },

                touchPoll = function() {
                    if (!touchStarted) {
                        return;
                    }

                    if (touchAxis === 'y') {
                        scrollVertical(pane, touchY0 - touchY);
                        touchDelta = touchY0 - touchY;
                        touchY0 = touchY;
                    } else if (touchAxis === 'x') {
                        scrollHorizontal(pane, touchX0 - touchX);
                        touchDelta = touchX0 - touchX;
                        touchX0 = touchX;
                    }

                    reqAnimFrame(touchPoll);
                },

                touchEnd = function() {
                    var t = 0,
                        d = Math.abs(touchDelta * 1.5);

                    this.removeEventListener('touchmove', touchMove, false);
                    this.removeEventListener('touchend', touchEnd, false);
                    touchStarted = false;

                    reqAnimFrame(function touchFinish() {
                        var dx;

                        if (t === d || touchStarted) {
                            return;
                        }

                        dx = easeOutExpo(touchDelta, d, t);

                        if (!isNaN(dx) && dx !== 0) {
                            t += 1;
                            if (touchAxis === 'y') {
                                scrollVertical(pane, dx);
                            } else {
                                scrollHorizontal(pane, dx);
                            }

                            reqAnimFrame(touchFinish);
                        }
                    });
                };

            if (event.touches.length === 1) {
                touchX0 = event.touches[0].clientX;
                touchY0 = event.touches[0].clientY;
                touchStarted = true;
                this.addEventListener('touchmove', touchMove, false);
                this.addEventListener('touchend', touchEnd, false);
                reqAnimFrame(touchPoll);
            }
        },

        api = {
            reposition: function() {
                return this.each(function() {
                    var $this = $(this),
                        data = $this.data('enscroll'),
                        positionElem = function(elem, x, y) {
                            elem.style.left = x + 'px';
                            elem.style.top = y + 'px';
                        },
                        corner, trackWrapper, offset;

                    if (data) {
                        offset = $this.position();
                        corner = data.corner;
                        if (data.settings.verticalScrolling) {
                            trackWrapper = data.verticalTrackWrapper;
                            positionElem(trackWrapper, (data.settings.verticalScrollerSide === 'right' ? offset.left + $this.outerWidth() - $(trackWrapper).width() - getComputedValue(this, 'border-right-width') : offset.left + getComputedValue(this, 'border-left-width')),
                                offset.top + getComputedValue(this, 'border-top-width'));
                        }

                        if (data.settings.horizontalScrolling) {
                            trackWrapper = data.horizontalTrackWrapper;
                            positionElem(trackWrapper,
                                offset.left + getComputedValue(this, 'border-left-width'),
                                offset.top + $this.outerHeight() - $(trackWrapper).height() - getComputedValue(this, 'border-bottom-width'));
                        }

                        if (corner) {
                            positionElem(corner,
                                offset.left + $this.outerWidth() - $(corner).outerWidth() - getComputedValue(this, 'border-right-width'),
                                offset.top + $this.outerHeight() - $(corner).outerHeight() - getComputedValue(this, 'border-bottom-width'));
                        }
                    }
                });
            },

            resize: function() {
                return this.each(function() {
                    var $this = $(this),
                        data = $this.data('enscroll'),
                        settings, paneHeight, paneWidth,
                        trackWrapper, pct, track, trackWidth, trackHeight,
                        $scrollUpBtn, $scrollDownBtn, $scrollLeftBtn, $scrollRightBtn,
                        handle, handleWidth, handleHeight, prybar;

                    if (!data) {
                        return true;
                    }

                    settings = data.settings;

                    if ($this.is(':visible')) {
                        if (settings.verticalScrolling) {
                            trackWrapper = data.verticalTrackWrapper;
                            paneHeight = $this.innerHeight();
                            pct = paneHeight / this.scrollHeight || 0;
                            track = $(trackWrapper).find('.enscroll-track')[0];
                            $scrollUpBtn = $(trackWrapper).find('.' + settings.scrollUpButtonClass);
                            $scrollDownBtn = $(trackWrapper).find('.' + settings.scrollDownButtonClass);

                            trackHeight = settings.horizontalScrolling ?
                                paneHeight - $(data.horizontalTrackWrapper).find('.enscroll-track').outerHeight() :
                                paneHeight;
                            trackHeight -= $(track).outerHeight() - $(track).height() + $scrollUpBtn.outerHeight() + $scrollDownBtn.outerHeight();

                            handle = track.firstChild;
                            handleHeight = Math.max(pct * trackHeight,
                                settings.minScrollbarLength);
                            handleHeight -= $(handle).outerHeight() - $(handle).height();

                            // hide the track first -- this causes less reflows and
                            // fixes an IE8 bug that prevents background images
                            // from being redrawn
                            trackWrapper.style.display = 'none';
                            track.style.height = trackHeight + 'px';
                            handle.style.height = handleHeight + 'px';
                            if (pct < 1) {
                                pct = $this.scrollTop() / (this.scrollHeight - $this.height()) || 0;
                                handle.style.top = (pct * (trackHeight - handleHeight)) + 'px';
                                trackWrapper.style.display = 'block';
                            }
                        }

                        if (settings.horizontalScrolling) {
                            trackWrapper = data.horizontalTrackWrapper;
                            paneWidth = $this.innerWidth();
                            pct = paneWidth / this.scrollWidth;
                            track = $(trackWrapper).find('.enscroll-track')[0];
                            $scrollLeftBtn = $(trackWrapper).find('.' + settings.scrollLeftButtonClass);
                            $scrollRightBtn = $(trackWrapper).find('.' + settings.scrollRightButtonClass);

                            trackWidth = settings.verticalScrolling ?
                                paneWidth - $(data.verticalTrackWrapper).find('.enscroll-track').outerWidth() :
                                paneWidth;
                            trackWidth -= $(track).outerWidth() - $(track).width() + $scrollLeftBtn.outerWidth() + $scrollRightBtn.outerWidth();

                            handle = track.firstChild;
                            handleWidth = Math.max(pct * trackWidth,
                                settings.minScrollbarLength);
                            handleWidth -= $(handle).outerWidth() - $(handle).width();

                            // see comment above
                            trackWrapper.style.display = 'none';
                            track.style.width = trackWidth + 'px';
                            handle.style.width = handleWidth + 'px';
                            if (pct < 1) {
                                pct = $this.scrollLeft() / (this.scrollWidth - $this.width());
                                handle.style.left = (pct * (trackWidth - handleWidth)) + 'px';
                                trackWrapper.style.display = 'block';
                            }

                            if (data._prybar) {
                                prybar = data._prybar;
                                this.removeChild(prybar);
                                if (settings.verticalScrolling) {
                                    prybar.style.width = (this.scrollWidth + $(data.verticalTrackWrapper).find('.enscroll-track').outerWidth()) + 'px';
                                    this.appendChild(prybar);
                                }
                            }
                        }
                        if (data.corner) {
                            data.corner.style.display = data.verticalTrackWrapper && data.horizontalTrackWrapper && $(data.verticalTrackWrapper).is(':visible') && $(data.horizontalTrackWrapper).is(':visible') ? '' : 'none';
                        }
                    } else {
                        if (settings.verticalScrolling) {
                            data.verticalTrackWrapper.style.display = 'none';
                        }
                        if (settings.horizontalScrolling) {
                            data.horizontalTrackWrapper.style.display = 'none';
                        }
                        if (data.corner) {
                            data.corner.style.display = 'none';
                        }
                    }

                });
            },

            startPolling: function() {
                return this.each(function() {
                    var data = $(this).data('enscroll'),
                        pane = this,
                        $pane = $(pane),
                        paneWidth = -1,
                        paneHeight = -1,
                        paneScrollWidth = -1,
                        paneScrollHeight = -1,
                        paneOffset,

                        paneChangeListener = function() {
                            if (data.settings.pollChanges) {
                                var sw = pane.scrollWidth,
                                    sh = pane.scrollHeight,
                                    pw = $pane.width(),
                                    ph = $pane.height(),
                                    offset = $pane.offset();

                                if (data.settings.verticalScrolling &&
                                    (ph !== paneHeight || sh !== paneScrollHeight) ||
                                    data.settings.horizontalScrolling &&
                                    (pw !== paneWidth || sw !== paneScrollWidth)) {
                                    paneScrollWidth = sw;
                                    paneScrollHeight = sh;

                                    api.resize.call($pane);
                                }

                                if (paneOffset.left !== offset.left ||
                                    paneOffset.top !== offset.top ||
                                    pw !== paneWidth ||
                                    ph !== paneHeight) {

                                    paneOffset = offset;
                                    paneWidth = pw;
                                    paneHeight = ph;

                                    api.reposition.call($pane);
                                }

                                setTimeout(paneChangeListener, 350);
                            }
                        };

                    if (data) {
                        data.settings.pollChanges = true;
                        paneScrollHeight = pane.scrollHeight;
                        paneScrollWidth = pane.scrollWidth;
                        paneOffset = $pane.offset();
                        paneChangeListener();
                    }
                });
            },

            stopPolling: function() {
                return this.each(function() {
                    var data = $(this).data('enscroll');
                    if (data) {
                        data.settings.pollChanges = false;
                    }
                });
            },

            destroy: function() {
                return this.each(function() {
                    var $this = $(this),
                        data = $this.data('enscroll'),
                        trackWrapper, mouseScrollHandler;
                    if (data) {

                        api.stopPolling.call($this);

                        mouseScrollHandler = data._mouseScrollHandler;

                        if (data.settings.verticalScrolling) {
                            trackWrapper = data.verticalTrackWrapper;

                            $(trackWrapper).remove();
                            trackWrapper = null;
                        }

                        if (data.settings.horizontalScrolling) {
                            trackWrapper = data.horizontalTrackWrapper;

                            $(trackWrapper).remove();
                            trackWrapper = null;
                        }

                        // clear the fade timer to prevent an error being thrown
                        // when the plugin object is destroyed while the fading
                        // scrollbar is visible - shoutout to gpurves
                        if (data._fadeTimer) {
                            clearTimeout(data._fadeTimer);
                        }

                        if (data.corner) {
                            $(data.corner).remove();
                        }

                        if (data._prybar && data._prybar.parentNode && data._prybar.parentNode === this) {
                            $(data._prybar).remove();
                        }

                        this.setAttribute('style', data._style || '');

                        if (!data._hadTabIndex) {
                            $this.removeAttr('tabindex');
                        }

                        $this
                            .off('scroll.enscroll.pane')
                            .off('keydown.enscroll.pane')
                            .off('mouseenter.enscroll.pane')
                            .off('mousedown.enscroll.pane')
                            .data('enscroll', null);

                        if (this.removeEventListener) {
                            this.removeEventListener('wheel', mouseScrollHandler, false);
                            this.removeEventListener('mousewheel', mouseScrollHandler, false);
                            this.removeEventListener('touchstart', touchStart, false);
                        } else if (this.detachEvent) {
                            this.detachEvent('onmousewheel', mouseScrollHandler);
                        }

                        $(win).off('resize.enscroll.window');
                    }
                });
            }
        };


    $.fn.enscroll = function(opts) {

        var settings;
        // handle API method calls
        if (api[opts]) {
            return api[opts].call(this);
        }
        // otherwise, initialize the enscroll element

        // use default settings, and overwrite defaults with options passed in
        settings = $.extend({}, defaultSettings, opts);

        return this.each(function() {

            // don't apply this plugin when both scrolling settings are false
            if (!settings.verticalScrolling && !settings.horizontalScrolling) {
                return;
            }

            var $this = $(this),
                pane = this,
                oldStyle = $this.attr('style'),
                hadTabIndex = true,
                horizontalTrackWrapper, verticalTrackWrapper,
                horizontalTrack, verticalTrack,
                horizontalHandle, verticalHandle,
                verticalUpButton, verticalDownButton,
                horizontalLeftButton, horizontalRightButton,
                trackHeight, trackWidth,
                corner, outline, tabindex,
                outlineWidth, prybar, paddingSide,
                trackWrapperCSS = {
                    'position': 'absolute',
                    'z-index': settings.zIndex,
                    'margin': 0,
                    'padding': 0
                },

                // closures to bind events to handlers
                mouseScrollHandler = function(event) {
                    mouseScroll.call(pane, event);
                },
                addHandleHTML = function(handle, html) {
                    if (typeof html === 'string') {
                        $(handle).html(html);
                    } else {
                        handle.appendChild(html);
                    }
                };

            // if we want vertical scrolling, create and initialize
            // the horizontal scrollbar and its components
            if (settings.verticalScrolling) {
                verticalTrackWrapper = doc.createElement('div');
                verticalTrack = doc.createElement('div');
                verticalHandle = doc.createElement('a');

                $(verticalTrack)
                    .css('position', 'relative')
                    .addClass('enscroll-track')
                    .addClass(settings.verticalTrackClass)
                    .appendTo(verticalTrackWrapper);

                if (settings.drawScrollButtons) {
                    verticalUpButton = doc.createElement('a');
                    verticalDownButton = doc.createElement('a');

                    $(verticalUpButton)
                        .css({
                            'display': 'block',
                            'text-decoration': 'none'
                        })
                        .attr('href', '')
                        .html('&nbsp;')
                        .addClass(settings.scrollUpButtonClass)
                        .on('click', function() {
                            scrollVertical(pane, -settings.scrollIncrement);
                            return false;
                        })
                        .insertBefore(verticalTrack);

                    $(verticalDownButton)
                        .css({
                            'display': 'block',
                            'text-decoration': 'none'
                        })
                        .attr('href', '')
                        .html('&nbsp;')
                        .on('click', function() {
                            scrollVertical(pane, settings.scrollIncrement);
                            return false;
                        })
                        .addClass(settings.scrollDownButtonClass)
                        .appendTo(verticalTrackWrapper);
                }

                if (settings.clickTrackToScroll) {
                    $(verticalTrack).on('click', function(event) {
                        if (event.target === this) {
                            scrollAnimateVertical($this,
                                event.pageY > $(verticalHandle).offset().top ? $this.height() :
                                -$this.height());
                        }
                    });
                }

                $(verticalHandle)
                    .css({
                        'position': 'absolute',
                        'z-index': 1
                    })
                    .attr('href', '')
                    .addClass(settings.verticalHandleClass)
                    .mousedown({
                        pane: this
                    }, startVerticalDrag)
                    .click(function() {
                        return false;
                    })
                    .appendTo(verticalTrack);

                addHandleHTML(verticalHandle, settings.verticalHandleHTML);

                $(verticalTrackWrapper)
                    .css(trackWrapperCSS)
                    .insertAfter(this);

                if (settings.showOnHover) {
                    $(verticalTrackWrapper)
                        .css('opacity', 0)
                        .on('mouseover.enscroll.vertical', function() {
                            showScrollbars.call(pane, false);
                        })
                        .on('mouseout.enscroll.vertical', function() {
                            showScrollbars.call(pane);
                        });
                }

                trackWidth = $(verticalTrack).outerWidth();

                // move the content in the pane over to make room for
                // the vertical scrollbar
                if (settings.addPaddingToPane) {
                    if (settings.verticalScrollerSide === 'right') {
                        paddingSide = {
                            'padding-right': (getComputedValue(this, 'padding-right') + trackWidth) + 'px'
                        };
                    } else {
                        paddingSide = {
                            'padding-left': (getComputedValue(this, 'padding-left') + trackWidth) + 'px'
                        };
                    }

                    $this.css($.extend({
                        'width': ($this.width() - trackWidth) + 'px'
                    }, paddingSide));
                }

                try {

                    outlineWidth = parseInt($this.css('outline-width'), 10);

                    if ((outlineWidth === 0 || isNaN(outlineWidth)) &&
                        $this.css('outline-style') === 'none') {
                        $this.css('outline', 'none');
                    }
                } catch (ex) {
                    $this.css('outline', 'none');
                }
            }

            // if we want horizontal scrolling, create the elements for and
            // initialize the horizontal track and handle
            if (settings.horizontalScrolling) {
                horizontalTrackWrapper = doc.createElement('div');
                horizontalTrack = doc.createElement('div');
                horizontalHandle = doc.createElement('a');

                $(horizontalTrack)
                    .css({
                        'position': 'relative',
                        'z-index': 1
                    })
                    .addClass('enscroll-track')
                    .addClass(settings.horizontalTrackClass)
                    .appendTo(horizontalTrackWrapper);

                if (settings.drawScrollButtons) {
                    horizontalLeftButton = doc.createElement('a');
                    horizontalRightButton = doc.createElement('a');

                    $(horizontalLeftButton)
                        .css('display', 'block')
                        .attr('href', '')
                        .on('click', function() {
                            scrollHorizontal(pane, -settings.scrollIncrement);
                            return false;
                        })
                        .addClass(settings.scrollLeftButtonClass)
                        .insertBefore(horizontalTrack);

                    $(horizontalRightButton)
                        .css('display', 'block')
                        .attr('href', '')
                        .on('click', function() {
                            scrollHorizontal(pane, settings.scrollIncrement);
                            return false;
                        })
                        .addClass(settings.scrollRightButtonClass)
                        .appendTo(horizontalTrackWrapper);
                }

                if (settings.clickTrackToScroll) {
                    $(horizontalTrack).on('click', function(event) {
                        if (event.target === this) {
                            scrollAnimateHorizontal($this,
                                event.pageX > $(horizontalHandle).offset().left ? $this.width() :
                                -$this.width());
                        }
                    });
                }

                $(horizontalHandle)
                    .css({
                        'position': 'absolute',
                        'z-index': 1
                    })
                    .attr('href', '')
                    .addClass(settings.horizontalHandleClass)
                    .click(function() {
                        return false;
                    })
                    .mousedown({
                        pane: this
                    }, startHorizontalDrag)
                    .appendTo(horizontalTrack);

                addHandleHTML(horizontalHandle, settings.horizontalHandleHTML);

                $(horizontalTrackWrapper)
                    .css(trackWrapperCSS)
                    .insertAfter(this);

                if (settings.showOnHover) {
                    $(horizontalTrackWrapper)
                        .css('opacity', 0)
                        .on('mouseover.enscroll.horizontal', function() {
                            showScrollbars.call(pane, false);
                        })
                        .on('mouseout.enscroll.horizontal', function() {
                            showScrollbars.call(pane);
                        });
                }

                trackHeight = $(horizontalTrack).outerHeight();

                if (settings.addPaddingToPane) {
                    $this.css({
                        'height': ($this.height() - trackHeight) + 'px',
                        'padding-bottom': (parseInt($this.css('padding-bottom'), 10) + trackHeight) + 'px'
                    });
                }

                // we need to add an element to the pane in order to
                // stretch to the scrollWidth of the pane so the content
                // scrolls horizontally beyond the vertical scrollbar
                if (settings.verticalScrolling) {
                    prybar = document.createElement('div');
                    $(prybar)
                        .css({
                            'width': '1px',
                            'height': '1px',
                            'visibility': 'hidden',
                            'padding': 0,
                            'margin': '-1px'
                        })
                        .appendTo(this);
                }
            }

            if (settings.verticalScrolling && settings.horizontalScrolling && settings.drawCorner) {
                corner = doc.createElement('div');
                $(corner)
                    .addClass(settings.cornerClass)
                    .css(trackWrapperCSS)
                    .insertAfter(this);
            }

            // add a tabindex attribute to the pane if it doesn't already have one
            // if the element does not have a tabindex in IE6, undefined is returned,
            // all other browsers return an empty string
            tabindex = $this.attr('tabindex');
            if (!tabindex) {
                $this.attr('tabindex', 0);
                hadTabIndex = false;
            }

            // if the outline style is not specified in IE6/7/8, null is returned
            // all other browsers return an empty string
            try {
                outline = $this.css('outline');
                if (!outline || outline.length < 1) {
                    $this.css('outline', 'none');
                }
            } catch (ex) {
                $this.css('outline', 'none');
            }

            // register an handler that listens for the pane to scroll, and
            // sync the scrollbars' positions
            $this
                .on({
                    'scroll.enscroll.pane': function(event) {
                        paneScrolled.call(this, event);
                    },
                    'keydown.enscroll.pane': keyHandler,
                    'mousedown.enscroll.pane': dragHandler
                })
                .css('overflow', 'hidden')
                // store the data we need for handling events and destruction
                .data('enscroll', {
                    settings: settings,
                    horizontalTrackWrapper: horizontalTrackWrapper,
                    verticalTrackWrapper: verticalTrackWrapper,
                    corner: corner,
                    _prybar: prybar,
                    _mouseScrollHandler: mouseScrollHandler,
                    _hadTabIndex: hadTabIndex,
                    _style: oldStyle,
                    _scrollingX: false,
                    _scrollingY: false,
                    _startX: 0,
                    _startY: 0,
                    _endX: 0,
                    _endY: 0,
                    _duration: parseInt(settings.easingDuration / 16.66666, 10),
                    _scrollHeightNoPadding: testScrollHeight(this.nodeName)
                });

            // reposition the scrollbars if the window is resized
            $(win).on('resize.enscroll.window', function() {
                api.reposition.call($this);
            });

            // if showOnHover is set, attach the hover listeners
            if (settings.showOnHover) {
                $this.on('mouseenter.enscroll.pane', function() {
                    showScrollbars.call(this);
                });
            }

            // listen for mouse wheel and touch events and scroll appropriately
            if (this.addEventListener) {
                if ('onwheel' in this || 'WheelEvent' in win &&
                    navigator.userAgent.toLowerCase().indexOf('msie') >= 0) {
                    this.addEventListener('wheel', mouseScrollHandler, false);
                } else if ('onmousewheel' in this) {
                    this.addEventListener('mousewheel', mouseScrollHandler, false);
                }

                this.addEventListener('touchstart', touchStart, false);
            } else if (this.attachEvent) {
                // oldie love
                this.attachEvent('onmousewheel', mouseScrollHandler);
            }

            // start polling for changes in dimension and position
            if (settings.pollChanges) {
                api.startPolling.call($this);
            }

            api.resize.call($this);
            api.reposition.call($this);

        });

    };

}(jQuery, window, document));
define("enscroll", ["jquery"], function() {});


/*
 * ScrollToFixed
 * https://github.com/bigspotteddog/ScrollToFixed
 * 
 * Copyright (c) 2011 Joseph Cava-Lynch
 * MIT license
 */
(function($) {
    $.isScrollToFixed = function(el) {
        return !!$(el).data('ScrollToFixed');
    };

    $.ScrollToFixed = function(el, options) {
        // To avoid scope issues, use 'base' instead of 'this' to reference this
        // class from internal events and functions.
        var base = this;

        // Access to jQuery and DOM versions of element.
        base.$el = $(el);
        base.el = el;

        // Add a reverse reference to the DOM object.
        base.$el.data('ScrollToFixed', base);

        // A flag so we know if the scroll has been reset.
        var isReset = false;

        // The element that was given to us to fix if scrolled above the top of
        // the page.
        var target = base.$el;

        var position;
        var originalPosition;
        var originalOffsetTop;
        var originalZIndex;

        // The offset top of the element when resetScroll was called. This is
        // used to determine if we have scrolled past the top of the element.
        var offsetTop = 0;

        // The offset left of the element when resetScroll was called. This is
        // used to move the element left or right relative to the horizontal
        // scroll.
        var offsetLeft = 0;
        var originalOffsetLeft = -1;

        // This last offset used to move the element horizontally. This is used
        // to determine if we need to move the element because we would not want
        // to do that for no reason.
        var lastOffsetLeft = -1;

        // This is the element used to fill the void left by the target element
        // when it goes fixed; otherwise, everything below it moves up the page.
        var spacer = null;

        var spacerClass;

        var className;

        // Capture the original offsets for the target element. This needs to be
        // called whenever the page size changes or when the page is first
        // scrolled. For some reason, calling this before the page is first
        // scrolled causes the element to become fixed too late.
        function resetScroll() {
            // Set the element to it original positioning.
            target.trigger('preUnfixed.ScrollToFixed');
            setUnfixed();
            target.trigger('unfixed.ScrollToFixed');

            // Reset the last offset used to determine if the page has moved
            // horizontally.
            lastOffsetLeft = -1;

            // Capture the offset top of the target element.
            offsetTop = target.offset().top;

            // Capture the offset left of the target element.
            offsetLeft = target.offset().left;

            // If the offsets option is on, alter the left offset.
            if (base.options.offsets) {
                offsetLeft += (target.offset().left - target.position().left);
            }

            if (originalOffsetLeft == -1) {
                originalOffsetLeft = offsetLeft;
            }

            position = target.css('position');

            // Set that this has been called at least once.
            isReset = true;

            if (base.options.bottom != -1) {
                target.trigger('preFixed.ScrollToFixed');
                setFixed();
                target.trigger('fixed.ScrollToFixed');
            }
        }

        function getLimit() {
            var limit = base.options.limit;
            if (!limit) return 0;

            if (typeof(limit) === 'function') {
                return limit.apply(target);
            }
            return limit;
        }

        // Returns whether the target element is fixed or not.
        function isFixed() {
            return position === 'fixed';
        }

        // Returns whether the target element is absolute or not.
        function isAbsolute() {
            return position === 'absolute';
        }

        function isUnfixed() {
            return !(isFixed() || isAbsolute());
        }

        // Sets the target element to fixed. Also, sets the spacer to fill the
        // void left by the target element.
        function setFixed() {
            // Only fix the target element and the spacer if we need to.
            if (!isFixed()) {
                // Set the spacer to fill the height and width of the target
                // element, then display it.
                spacer.css({
                    'display': target.css('display'),
                    'width': target.outerWidth(true),
                    'height': target.outerHeight(true),
                    'float': target.css('float')
                });

                // Set the target element to fixed and set its width so it does
                // not fill the rest of the page horizontally. Also, set its top
                // to the margin top specified in the options.

                cssOptions = {
                    'z-index': base.options.zIndex,
                    'position': 'fixed',
                    'top': base.options.bottom == -1 ? getMarginTop() : '',
                    'bottom': base.options.bottom == -1 ? '' : base.options.bottom,
                    'margin-left': '0px'
                }
                if (!base.options.dontSetWidth) {
                    cssOptions['width'] = target.css('width');
                };

                target.css(cssOptions);

                target.addClass(base.options.baseClassName);

                if (base.options.className) {
                    target.addClass(base.options.className);
                }

                position = 'fixed';
            }
        }

        function setAbsolute() {

            var top = getLimit();
            var left = offsetLeft;

            if (base.options.removeOffsets) {
                left = '';
                top = top - offsetTop;
            }

            cssOptions = {
                'position': 'absolute',
                'top': top,
                'left': 0,
                'margin-left': '0',
                'bottom': ''
            }
            if (!base.options.dontSetWidth) {
                cssOptions['width'] = target.css('width');
            };

            target.css(cssOptions);

            position = 'absolute';
        }

        // Sets the target element back to unfixed. Also, hides the spacer.
        function setUnfixed() {
            // Only unfix the target element and the spacer if we need to.
            if (!isUnfixed()) {
                lastOffsetLeft = -1;

                // Hide the spacer now that the target element will fill the
                // space.
                spacer.css('display', 'none');

                // Remove the style attributes that were added to the target.
                // This will reverse the target back to the its original style.
                target.css({
                    'z-index': originalZIndex,
                    'width': '',
                    'position': originalPosition,
                    'left': '',
                    'top': originalOffsetTop,
                    'margin-left': ''
                });

                target.removeClass('scroll-to-fixed-fixed');

                if (base.options.className) {
                    target.removeClass(base.options.className);
                }

                position = null;
            }
        }

        // Moves the target element left or right relative to the horizontal
        // scroll position.
        function setLeft(x) {
            // Only if the scroll is not what it was last time we did this.
            if (x != lastOffsetLeft) {
                // Move the target element horizontally relative to its original
                // horizontal position.
                target.css('left', offsetLeft - x);

                // Hold the last horizontal position set.
                lastOffsetLeft = x;
            }
        }

        function getMarginTop() {
            var marginTop = base.options.marginTop;
            if (!marginTop) return 0;

            if (typeof(marginTop) === 'function') {
                return marginTop.apply(target);
            }
            return marginTop;
        }

        // Checks to see if we need to do something based on new scroll position
        // of the page.
        function checkScroll() {
            if (!$.isScrollToFixed(target)) return;
            var wasReset = isReset;

            // If resetScroll has not yet been called, call it. This only
            // happens once.
            if (!isReset) {
                resetScroll();
            } else if (isUnfixed()) {
                // if the offset has changed since the last scroll,
                // we need to get it again.

                // Capture the offset top of the target element.
                offsetTop = target.offset().top;

                // Capture the offset left of the target element.
                offsetLeft = target.offset().left;
            }

            // Grab the current horizontal scroll position.
            var x = $(window).scrollLeft();

            // Grab the current vertical scroll position.
            var y = $(window).scrollTop();

            // Get the limit, if there is one.
            var limit = getLimit();

            // If the vertical scroll position, plus the optional margin, would
            // put the target element at the specified limit, set the target
            // element to absolute.
            if (base.options.minWidth && $(window).width() < base.options.minWidth) {
                if (!isUnfixed() || !wasReset) {
                    postPosition();
                    target.trigger('preUnfixed.ScrollToFixed');
                    setUnfixed();
                    target.trigger('unfixed.ScrollToFixed');
                }
            } else if (base.options.maxWidth && $(window).width() > base.options.maxWidth) {
                if (!isUnfixed() || !wasReset) {
                    postPosition();
                    target.trigger('preUnfixed.ScrollToFixed');
                    setUnfixed();
                    target.trigger('unfixed.ScrollToFixed');
                }
            } else if (base.options.bottom == -1) {
                // If the vertical scroll position, plus the optional margin, would
                // put the target element at the specified limit, set the target
                // element to absolute.
                if (limit > 0 && y >= limit - getMarginTop()) {
                    if (!isAbsolute() || !wasReset) {
                        postPosition();
                        target.trigger('preAbsolute.ScrollToFixed');
                        setAbsolute();
                        target.trigger('unfixed.ScrollToFixed');
                    }
                    // If the vertical scroll position, plus the optional margin, would
                    // put the target element above the top of the page, set the target
                    // element to fixed.
                } else if (y >= offsetTop - getMarginTop()) {
                    if (!isFixed() || !wasReset) {
                        postPosition();
                        target.trigger('preFixed.ScrollToFixed');

                        // Set the target element to fixed.
                        setFixed();

                        // Reset the last offset left because we just went fixed.
                        lastOffsetLeft = -1;

                        target.trigger('fixed.ScrollToFixed');
                    }
                    // If the page has been scrolled horizontally as well, move the
                    // target element accordingly.
                    setLeft(x);
                } else {
                    // Set the target element to unfixed, placing it where it was
                    // before.
                    if (!isUnfixed() || !wasReset) {
                        postPosition();
                        target.trigger('preUnfixed.ScrollToFixed');
                        setUnfixed();
                        target.trigger('unfixed.ScrollToFixed');
                    }
                }
            } else {
                if (limit > 0) {
                    if (y + $(window).height() - target.outerHeight(true) >= limit - (getMarginTop() || -getBottom())) {
                        if (isFixed()) {
                            postPosition();
                            target.trigger('preUnfixed.ScrollToFixed');

                            if (originalPosition === 'absolute') {
                                setAbsolute();
                            } else {
                                setUnfixed();
                            }

                            target.trigger('unfixed.ScrollToFixed');
                        }
                    } else {
                        if (!isFixed()) {
                            postPosition();
                            target.trigger('preFixed.ScrollToFixed');
                            setFixed();
                        }
                        setLeft(x);
                        target.trigger('fixed.ScrollToFixed');
                    }
                } else {
                    setLeft(x);
                }
            }
        }

        function getBottom() {
            if (!base.options.bottom) return 0;
            return base.options.bottom;
        }

        function postPosition() {
            var position = target.css('position');

            if (position == 'absolute') {
                target.trigger('postAbsolute.ScrollToFixed');
            } else if (position == 'fixed') {
                target.trigger('postFixed.ScrollToFixed');
            } else {
                target.trigger('postUnfixed.ScrollToFixed');
            }
        }

        var windowResize = function(event) {
            // Check if the element is visible before updating it's position, which
            // improves behavior with responsive designs where this element is hidden.
            if (target.is(':visible')) {
                isReset = false;
                checkScroll();
            }
        }

        var windowScroll = function(event) {
            (!!window.requestAnimationFrame) ? requestAnimationFrame(checkScroll): checkScroll();
        }

        // From: http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED
        var isPositionFixedSupported = function() {
            var container = document.body;

            if (document.createElement && container && container.appendChild && container.removeChild) {
                var el = document.createElement('div');

                if (!el.getBoundingClientRect) return null;

                el.innerHTML = 'x';
                el.style.cssText = 'position:fixed;top:100px;';
                container.appendChild(el);

                var originalHeight = container.style.height,
                    originalScrollTop = container.scrollTop;

                container.style.height = '3000px';
                container.scrollTop = 500;

                var elementTop = el.getBoundingClientRect().top;
                container.style.height = originalHeight;

                var isSupported = (elementTop === 100);
                container.removeChild(el);
                container.scrollTop = originalScrollTop;

                return isSupported;
            }

            return null;
        }

        var preventDefault = function(e) {
            e = e || window.event;
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        // Initializes this plugin. Captures the options passed in, turns this
        // off for devices that do not support fixed position, adds the spacer,
        // and binds to the window scroll and resize events.
        base.init = function() {
            // Capture the options for this plugin.
            base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);

            originalZIndex = target.css('z-index')

            // Turn off this functionality for devices that do not support it.
            // if (!(base.options && base.options.dontCheckForPositionFixedSupport)) {
            //     var fixedSupported = isPositionFixedSupported();
            //     if (!fixedSupported) return;
            // }

            // Put the target element on top of everything that could be below
            // it. This reduces flicker when the target element is transitioning
            // to fixed.
            base.$el.css('z-index', base.options.zIndex);

            // Create a spacer element to fill the void left by the target
            // element when it goes fixed.
            spacer = $('<div />');

            position = target.css('position');
            originalPosition = target.css('position');

            originalOffsetTop = target.css('top');

            // Place the spacer right after the target element.
            if (isUnfixed()) base.$el.after(spacer);

            // Reset the target element offsets when the window is resized, then
            // check to see if we need to fix or unfix the target element.
            $(window).bind('resize.ScrollToFixed', windowResize);

            // When the window scrolls, check to see if we need to fix or unfix
            // the target element.
            $(window).bind('scroll.ScrollToFixed', windowScroll);

            // For touch devices, call checkScroll directlly rather than
            // rAF wrapped windowScroll to animate the element
            if ('ontouchmove' in window) {
                $(window).bind('touchmove.ScrollToFixed', function(event) {
                    if ($(event.target).parents('.tabs-col')) {
                        return;
                    } else {
                        checkScroll();
                    }
                });
            }

            if (base.options.preFixed) {
                target.bind('preFixed.ScrollToFixed', base.options.preFixed);
            }
            if (base.options.postFixed) {
                target.bind('postFixed.ScrollToFixed', base.options.postFixed);
            }
            if (base.options.preUnfixed) {
                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);
            }
            if (base.options.postUnfixed) {
                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);
            }
            if (base.options.preAbsolute) {
                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);
            }
            if (base.options.postAbsolute) {
                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);
            }
            if (base.options.fixed) {
                target.bind('fixed.ScrollToFixed', base.options.fixed);
            }
            if (base.options.unfixed) {
                target.bind('unfixed.ScrollToFixed', base.options.unfixed);
            }

            if (base.options.spacerClass) {
                spacer.addClass(base.options.spacerClass);
            }

            target.bind('resize.ScrollToFixed', function() {
                spacer.height(target.height());
            });

            target.bind('scroll.ScrollToFixed', function() {
                target.trigger('preUnfixed.ScrollToFixed');
                setUnfixed();
                target.trigger('unfixed.ScrollToFixed');
                checkScroll();
            });

            target.bind('detach.ScrollToFixed', function(ev) {
                preventDefault(ev);

                target.trigger('preUnfixed.ScrollToFixed');
                setUnfixed();
                target.trigger('unfixed.ScrollToFixed');

                $(window).unbind('resize.ScrollToFixed', windowResize);
                $(window).unbind('scroll.ScrollToFixed', windowScroll);

                target.unbind('.ScrollToFixed');

                //remove spacer from dom
                spacer.remove();

                base.$el.removeData('ScrollToFixed');
            });

            // Reset everything.
            windowResize();
        };

        // Initialize the plugin.
        base.init();
    };

    // Sets the option defaults.
    $.ScrollToFixed.defaultOptions = {
        marginTop: 0,
        limit: 0,
        bottom: -1,
        zIndex: 1000,
        baseClassName: 'scroll-to-fixed-fixed'
    };

    // Returns enhanced elements that will fix to the top of the page when the
    // page is scrolled.
    $.fn.scrollToFixed = function(options) {
        return this.each(function() {
            (new $.ScrollToFixed(this, options));
        });
    };
})(jQuery);

(function($) {

    $.fn.autoGrowInput = function(o) {

        o = $.extend({
            maxWidth: 1000,
            minWidth: 0,
            comfortZone: 70
        }, o);

        this.filter('input:text').each(function() {

            var minWidth = o.minWidth || $(this).width(),
                val = '',
                input = $(this),
                testSubject = $('<tester/>').css({
                    position: 'absolute',
                    top: -9999,
                    left: -9999,
                    width: 'auto',
                    fontSize: input.css('fontSize'),
                    fontFamily: input.css('fontFamily'),
                    fontWeight: input.css('fontWeight'),
                    letterSpacing: input.css('letterSpacing'),
                    whiteSpace: 'nowrap'
                }),
                check = function() {

                    if (val === (val = input.val())) {
                        return;
                    }

                    // Enter new content into testSubject
                    var escaped = val.replace(/&/g, '&amp;').replace(/\s/g, '&nbsp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    testSubject.html(escaped);

                    // Calculate new width + whether to change
                    var testerWidth = testSubject.width(),
                        newWidth = (testerWidth + o.comfortZone) >= minWidth ? testerWidth + o.comfortZone : minWidth,
                        currentWidth = input.width(),
                        isValidWidthChange = (newWidth < currentWidth && newWidth >= minWidth) || (newWidth > minWidth && newWidth < o.maxWidth);

                    // Animate width
                    if (isValidWidthChange) {
                        input.width(newWidth);
                    }

                };

            testSubject.insertAfter(input);

            $(this).bind('keyup keydown blur update', check);

        });

        return this;

    };

})(jQuery);


define("vendor/scrolltofixed", function() {});

(function($) {

    $.fn.autoGrowInput = function(o) {

        o = $.extend({
            maxWidth: 1000,
            minWidth: 0,
            comfortZone: 0
        }, o);

        this.filter('input:text').each(function() {

            var minWidth = o.minWidth || $(this).width(),
                val = '',
                input = $(this),
                testSubject = $('<tester/>').css({
                    position: 'absolute',
                    top: -9999,
                    left: -9999,
                    width: 'auto',
                    fontSize: input.css('fontSize'),
                    fontFamily: input.css('fontFamily'),
                    fontWeight: input.css('fontWeight'),
                    letterSpacing: input.css('letterSpacing'),
                    whiteSpace: 'nowrap'
                }),
                check = function() {

                    if (val === (val = input.val())) {
                        return;
                    }

                    // Enter new content into testSubject
                    var escaped = val.replace(/&/g, '&amp;').replace(/\s/g, '&nbsp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                    testSubject.html(escaped);

                    // Calculate new width + whether to change
                    var testerWidth = testSubject.width(),
                        newWidth = (testerWidth + o.comfortZone) >= minWidth ? testerWidth + o.comfortZone : minWidth,
                        currentWidth = input.width(),
                        isValidWidthChange = (newWidth < currentWidth && newWidth >= minWidth) || (newWidth > minWidth && newWidth < o.maxWidth);

                    // Animate width
                    if (isValidWidthChange) {
                        input.width(newWidth);
                    }

                };

            testSubject.insertAfter(input);

            $(this).bind('keyup keydown blur update', check);

        });

        return this;

    };

})(jQuery);


define("vendor/autogrow", function() {});

/* globals $, document, tuiConfig, define, TUIUtil */
define('search-panel/search-panel-v3', [
    'base',
    'jquery',
    './search-autosuggest-v3',
    './search-who-v3',
    './search-when-nordics',
    './search-where-v3',
    './search-where-to-v3',
    './search-tabs',
    '../emotional-header/emotional-header',
    'enscroll',
    'handlebarsHelpers',
    'helpers/dockable',
    'jqueryCookie',
    'vendor/scrolltofixed',
    'vendor/autogrow'
], function(base, $, SearchAutoSuggest, SearchWho, SearchWhen, SearchWhere, SearchWhereTo, SearchTabs, EmotionalHeader, Enscroll, HandlebarsHelper, Dockable, scrolltofixed) {
    function SearchPanel(ele, opts) {
        if (!ele || !ele.length) {
            return false;
        }
        this.ele = ele;
        this.opts = $.extend({}, {
            tabClasses: [
                'package',
                'flight',
                'hotel'
            ],
            emotionalHeader: $('#emotional-header'),
            searchNowBtn: $('#searchNowBtn'),
            responseURL: tuiConfig.search.responseURL
        }, opts);

        this.init();
    }
    // get search panel form
    var that, form = $('.search-panel form'),
        isSafari = TUIUtil.isSafariBrowser(),
        searchPanelContainer = $('#new-search-panel-container'),
        isResultPage,
        targetedPanel,
        resultsContainer = $('#results'),
        panelDelay = 350,
        searchAutoSuggestResult = $('#searchResultFlyoutRedesign');

    var methods = {
        init: function() {
            that = this;
            isResultPage = $('body').hasClass('results');
            removeDisabled();
            that.errorValidations = [];
            that.movePanelWrappers();
            that.fromSubmit = false;
            that.targetedPanel = '';
            that.bindPanels();
            that.resizeEvent();
            that.bindFormSubmit();
            // bind tab events
            makeStickyButton(); // Sticky button not required

            checkAndCreateVersion3Cookie();

            // if formvalues or flight only json is present on page extend formvalues cookie with this json
            if (window.formValuesJSON || window.flightOnlyValuesJSON) {

                bifurcateFormCookie(that.getCookie('SEARCH_TYPE'));

            }
            // bind sub modules
            this.searchAutoSuggest = new SearchAutoSuggest($('#searchPanel-field-search'), {
                controller: this
            });
            this.searchWho = new SearchWho($('#searchWho'), {
                controller: this
            });
            this.searchWhen = new SearchWhen($('#searchWhen'), {
                input: this.ele.find('a#when'),
                controller: this,
                durationSelector: '#search-when-duration'
            }).init();

            this.searchWhere = new SearchWhere($('#searchWhere'), {
                controller: this
            });

            this.searchWhereTo = new SearchWhereTo($('#searchWhereTo'), {
                controller: this
            });

            this.searchTabs = new SearchTabs($('#search-panel-tabs'), {
                controller: this
            });
            if (this.opts.emotionalHeader.length) {
                this.emotionalHeader = new EmotionalHeader(this.opts.emotionalHeader);
            }

            // if ($.cookie('formvalues')) {
            // 	that.setFormValues($.parseJSON($.cookie('formvalues')));
            // }
            // else {
            // 	that.setFormValues('default');
            // }

            // if ($.cookie('PARTY_COOKIE')) {
            // 	that.setPartyFromCookie($.parseJSON($.cookie('PARTY_COOKIE')));
            // }
            // else {
            // 	that.setPartyFromCookie(null);
            // }

            // bind mobile trigger
            this.ele.on('click', 'a.search-panel-trigger', function(e) {
                e.stopPropagation();
                that.ele.toggleClass('open');
                if (that.ele.is('.open')) {

                    that.searchAutoSuggest.wrapper
                        .trigger('click')
                        .addClass('focus');
                    that.searchAutoSuggest.wrapperHeight = that.searchAutoSuggest.wrapper.height();
                    if (resultsContainer.length) {
                        resultsContainer.addClass('search-open');
                    }
                } else if (resultsContainer.length) {
                    resultsContainer.removeClass('search-open');
                }

            });

            this.changeDateAction();
            resetSearchEvent();

            $.subscribe('windowResized', $.proxy(that.changeDropdownPos, that)); // breakpointchange is changed to windowResized

            // set background image
            TUIUtil.setBackgroundImage();
            if (TUIUtil.isStartPageSearchPanel()) {
                $('body').addClass('start-page-search');
            }
            $.subscribe('windowResized', $.proxy(TUIUtil.setBackgroundImage, that));
            // that.getCachedSeachedValues();


            // add support of Array.indexOf in unsupported browsers
            this.addSupportForArrayIndexOf();

            // bind mobile search init button
            bindFieldIconClickEvent();
            this.bindMobileSearchInit();
            $('body').on('keydown', function(e) {
                if (e.keyCode === 27) {
                    if (searchAutoSuggestResult.hasClass('open')) {
                        searchAutoSuggestResult.removeClass('open').hide();
                    } else {
                        that.closePanel();
                    }
                }
            });
            that.windowScrollEvent();
            this.ele.on('click', '.redirect-link', function(e) {
                window.location.href = this.href;
                return false;
            });

            this.fields = $('[data-panel]');
        },
        windowScrollEvent: function() {
            $(window).on('scroll', function(e) {
                clearTimeout($.data(this, 'scrollTimer'));
                $.data(this, 'scrollTimer', setTimeout(function() {
                    if (!that.panels.hasClass('open') && TUIUtil.getCurrentBreakPoint() !== 'xs') {
                        var currentTime = new Date().getTime();
                        if (currentTime - that.lastClosingTime > 1000) {
                            searchPanelContainer.css('position', 'absolute');
                        }
                    }
                }, 250));

            });
        },
        /**
         * Move the panels outside the fields
         * in case of non mobile view
         * TODO do it on resize as well or vice versa
         * @return {[type]} [description]
         */
        movePanelWrappers: function() {
            if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                var panels = that.ele.find('.panel-wrapper');
                that.ele.find('#desktop-panel-wrapper').append(panels);
            }
        },
        getCookie: function(cookieName) {
            return $.cookie(cookieName);
        },
        validateForm: function(target, serviceURL, formPostData) {
            that.opts.searchNowBtn.addClass('loader-green');
            var newService = false;
            if($('#searchNowBtn').data('getresultservice')){
                service = $('#searchNowBtn').data('getresultservice');
                newService = true;
            } else{
                service = serviceURL + '&searchInitiator=' + formPostData.searchInitiator;
            }
            TUIUtil.genericAjaxRequest({
                url: service,
                dataType: 'json',
                cache: false,
                type: 'post',
                contentType: 'application/json',
                data: JSON.stringify(formPostData)
            }).done(function(sdata) {
                that.opts.searchNowBtn.removeClass('loader-green');
                if(newService){
                    that.paintResults(sdata);
                }
                else if (sdata.resultsFound) {
                    that.getResults(sdata.encodedUrl);
                } else {
                    that.updateSubmitPanel(target, sdata);
                    $.publish('openSearchPanel');
                }
            });
        },
        getResults: function(url) {
            var queryparams = url.substring(url.indexOf('?'));
            var service = $('#searchNowBtn').data('resultservice') + queryparams;
            that.opts.searchNowBtn.addClass('loader-green');
            TUIUtil.genericAjaxRequest({
                url: service,
                dataType: 'json',
                cache: false,
                type: 'get',
                contentType: 'application/json'
            }).done(function(json) {
                that.opts.searchNowBtn.removeClass('loader-green');
                that.paintResults(json);
            });
        },
        paintResults: function(data) {
            window.hotelData = data;
            $.publish('packagesUpdate');
        },
        updateSubmitPanel: function(target, data) {
            that.opts.searchNowBtn.attr('disabled', 'disabled');
            target.find('.message-header').html(data.noRecordsMessageTitle);
            var alternateDateLI = target.find('.alternate-date'),
                alternateDurationLI = target.find('.alternate-duration');
            alternateDateLI.addClass('hidden');
            alternateDurationLI.addClass('hidden');
            if (data.alternateDate) {
                var formattedDate = TUIUtil.dateDayConverter(data.alternateDate);
                alternateDateLI.removeClass('hidden').find('a').attr('href', data.alternateDateURL).text(formattedDate);
            }
            if (data.alternateDuration) {
                alternateDurationLI.removeClass('hidden').find('a').attr('href', data.alternateDurationURL).find('span.duration-number').text(data.alternateDuration);
            }
        },
        isFlyoutOpen: function() {
            var retVal = false;
            if (that.$openPanel.attr('id') === 'searchResultFlyoutRedesign') {
                that.$openPanel = $('#searchDestinationRedesign');
            }
            if (that.$openPanel && that.$openPanel.hasClass('open')) {
                retVal = true;
            }
            return retVal;
        },
        setDefaultLabel: function() {
            var targetElem = $('#when');
            if (!$.cookie('formvalues')) {
                targetElem.val('');
            }
        },
        bindFormSubmit: function() {
            $('.search-panel form').on('keypress', function(e) {

                if (e.keyCode === 13 && $(e.target).attr('id') !== 'searchNowBtn') { // Blocking the ENTER key as we need to select a dropdown value on Enter
                    return false;
                }
            });
        },
        lastOpenTime: new Date().getTime(),
        bindPanels: function() {
            var destinationPanel = this.ele.find('.destination-flyout');

            this.panels = this.ele.find('div.dropdown-panel');
            if (TUIUtil.getCurrentBreakPoint() === 'xs') { // adding the all destination panel for mobile
                this.panels = this.panels.add(destinationPanel);
            }

            this.panelOpen = false;
            this.$openPanel = $([]);
            this.panelTriggers = this.ele.find('[data-panel]');
            this.panelArrow = this.ele.find('div.panel-arrow');

            this.ele.on('click', '.icon-calendar, .icon-plane, .icon-person', function(e) {
                $(this).closest('.icon-wrapper').siblings('input').focus(); // .trigger('focusin').trigger('click');
            });

            var openPanelCallback = function(e, eType, target) {
                if (e.type === 'click') {
                    e.stopPropagation();
                }
                if (that.lastOpenTime) {
                    var currentTime = new Date();
                    currentTime = currentTime.getTime();
                    var diff = currentTime - that.lastOpenTime;
                    if (diff < 300) {
                        $(document).trigger('click');
                        return false;
                    } else {
                        that.lastOpenTime = currentTime;
                    }
                }

                that.ele.removeAttr('css');

                that.openPanel(target);

            };

            this.ele.on('click', '[data-panel]', function(e) {
                e.preventDefault();
                var target = e.currentTarget,
                    eType = e.type;
                that.targetedPanel = $(target);
                TUIUtil.printLog('Inside Panel Open Event : +' + e.type + ' triggered by :' + e.target);

                openPanelCallback(e, eType, target);
            });

            // close on done button click
            this.ele.on('click', 'a.btn-done, a.icon-close', function(e) {
                e.preventDefault();
                if (that.$openPanel.attr('id') === 'searchWhen') {
                    that.searchWhen.setFieldValue();
                }
                that.closePanel();
                if (that.$openPanel.attr('id') === 'searchResultFlyout') {
                    $(document).trigger('click');
                }
            });

            this.ele.on('keydown', '[data-panel]', function(e) {
                if (e.keyCode === 40) {
                    var destinationPanel = $('#searchDestinationRedesign'),
                        countryContainer = destinationPanel.find('.country-container'),
                        firstCountry = countryContainer.find('li:first');
                    if ($(e.currentTarget).attr('id') === 'field-destination-picker' && destinationPanel.hasClass('open')) {
                        firstCountry.find('.country-name').addClass('active').focus();
                    }
                }
            });
        },

        scrollWindowTillHeader: function(target, fromAutosuggest) {
            var currentTarget, position;
            if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
                return true;
            }
            if (fromAutosuggest) {
                currentTarget = target;
            } else {
                currentTarget = $(target).parent().find('.field-label-container');

            }
            position = currentTarget.offset().top;
            $(window).scrollTop(position);

        },
        checkIfAutosuggestionOpen: function() {
            $('#searchResultFlyoutRedesign').removeClass('open').hide();
        },
        bindGlobalClosePanel: function() {
            $(document).on('click.closePanel', function(e) {
                var $target = $(e.target);

                that.checkIfAutosuggestionOpen();

                // return if the target is one of the opening triggers
                if ($target.is(that.panelTriggers) && that.isAutoSuggestFocusAndOpen()) {
                    return;
                } else {
                    if ($target.attr('id') !== 'searchPanel-field-search-redesign' && !$target.parents('#searchDestinationRedesign').hasClass('open')) {
                        that.searchAutoSuggest.showHideMobilePickerField(true);
                    }
                }

                // check if the target is a child of or the openpanel and close if not
                var isMobileDestination = that.$openPanel.is('#searchDestinationRedesign') && $target.is($('a.mobile-destinations , a.mobile-destinations i'));
                if (!that.$openPanel.has($target).length && !that.$openPanel.is($target) && !isMobileDestination) {
                    // catch for calender next prev
                    if (that.$openPanel.is('#searchWhen')) {
                        var handler = $target.parent().attr('data-handler') || '';
                        if (handler.match(/next|prev/)) {
                            return;
                        }
                    }
                    if ($target.closest('#searchDestinationRedesign').length === 0) {
                        that.closePanel($target);
                    } else {
                        if (that.searchAutoSuggest.searchInput.val().length === 0 && that.searchAutoSuggest.searchInput.is(':focus')) {
                            $('.destination-flyout').hide();
                            $('#searchResultFlyoutRedesign').show();
                        }
                    }
                }

                if ($('.ALL_DESTINATIONS.open').length === 0) {
                    $('#searchDestinationRedesign').removeClass('ALL_DESTINATIONS');
                }
            });
        },
        identifyScrollablePanel: function(panelName, flyoutPanel) {
            var panel;
            switch (panelName) {
                case 'when':
                case 'field-duration':
                case 'field-flexibility':
                    {
                        panel = flyoutPanel.find('.scrollable-panel');
                        break;
                    }
                case 'where':
                case 'airport-to':
                    {
                        panel = flyoutPanel.find('.airports-flyout');
                        break;
                    }
                case 'who':
                    {
                        panel = flyoutPanel.find('.who-panel').find('.scrollable-panel');
                        break;
                    }
                case 'destination':
                    {
                        panel = flyoutPanel.find('.destination-panel');
                        break;
                    }
                case 'searchNowBtn':
                    {
                        panel = flyoutPanel.find('.search-btn-panel');
                        break;
                    }
            }
            return panel;
        },
        openPanel: function(field, ele) {
            that.opts.searchNowBtn.removeAttr('disabled');
            $(document).off('click.closePanel');

            var panelName = field.getAttribute('data-panel'),
                panelFlyout = this.panels.filter('[data-panel-name=' + panelName + ']'),
                $ele = ele || this.panelTriggers.filter('[data-panel=' + panelName + ']:visible'),
                panelFlyoutCss = {},
                serviceURL = $(field).data('service'),
                panelInFlyout = that.panels.find('.panel');
            this.bindGlobalClosePanel();

            that.closePanel(null, true); //can be rmeoved

            if (!searchPanelContainer.find('#field-destination-picker').is(':visible')) {
                that.searchAutoSuggest.showHideMobilePickerField(true);
            }

            panelFlyout.removeAttr('style'); //can be rmeoved
            panelInFlyout.removeAttr('style'); //can be rmeoved
            panelFlyoutCss = positionPanel(panelFlyout, panelFlyoutCss);
            panelFlyoutCss.top = panelFlyoutCss.top - 18;
            // panelFlyout.css(panelFlyoutCss);
            showEmptyPanel(that, panelFlyout, $ele, panelName, panelFlyoutCss);
        },

        triggerAjaxForPanel: function(field, panelFlyout, panelName) {
            var serviceURL = field.data('service');
            field.addClass('loading');
            panelFlyout.find('.panel').addClass('flyout-loading');
            if (serviceURL) {
                var dd;
                if (field.attr('id') === 'airport') { // Allowing ajax call for every click hence removed this check && !that.searchWhere.userAction
                    // use deferred to delay the panel
                    dd = that.searchWhere.getAirportList(panelFlyout);
                    dd.done(function(log) {
                        that.ajaxFinished(field, panelName, panelFlyout);
                    });
                }
                if (field.attr('id') === 'airport-to') { // Allowing ajax call for every click hence removed this check && !that.searchWhere.userAction
                    // use deferred to delay the panel
                    dd = that.searchWhereTo.getAirportList(panelFlyout);
                    dd.done(function(log) {
                        that.ajaxFinished(field, panelName, panelFlyout);
                    });
                }
                if (field.attr('id') === 'when') { // Allowing ajax call for every click hence removed this check && !that.searchWhere.userAction
                    if (that.searchWhen.whenErrorValidations.length === 0 && that.errorValidations.length && !$('.change-date-partysize').length) { // if no error in calendar, party size error & not max seat available error open party size panel

                        $('#panelWrapper input').removeClass('loading');
                        setTimeout(function() {
                            $('#who').trigger('click').focus();
                        }, panelDelay); // delay as the trigger to focus is called first
                        return;

                    } else if (that.searchWhen.whenErrorValidations.length === 0 && $('.change-date-partysize').length) { // clear date & clean uptooltips if party size exceed/max seat available error & open calendar with dates reset
                        that.searchWho.cleanupTooltips('.tui-tooltip-inline');
                        that.searchWhen.cleanup(panelFlyout);
                        that.searchWhen.resetDates();

                        // Defer use to display the result
                        dd = that.searchWhen.getCalendarData(panelFlyout, serviceURL);
                        dd.done(function(log) {
                            that.ajaxFinished(field, panelName, panelFlyout);
                        });
                    } else { // open calendar
                        // Defer use to display the result
                        dd = that.searchWhen.getCalendarData(panelFlyout, serviceURL);
                        dd.done(function(log) {
                            that.ajaxFinished(field, panelName, panelFlyout);
                        });
                    }
                }
                if (field.attr('id') === 'field-duration') {
                    // Defer use to display the result
                    if (serviceURL) {
                        dd = that.searchWhen.refreshDurations(panelFlyout, serviceURL);
                        dd.done(function(log) {
                            that.ajaxFinished(field, panelName, panelFlyout);
                        });
                    } else {
                        that.ajaxFinished(field, panelName, panelFlyout);
                    }
                }
                if (field.attr('id') === 'who') {
                    // Defer use to display the result
                    if (serviceURL) {
                        dd = that.searchWho.getPartySizeAvailability(panelFlyout, serviceURL);
                        dd.done(function(log) {
                            that.ajaxFinished(field, panelName, panelFlyout);
                        });
                    } else {
                        that.ajaxFinished(field, panelName, panelFlyout);
                    }
                }
                if (field.attr('id') === 'searchNowBtn') { // Allowing ajax call for every click hence removed this check && !_tt.searchWhere.userAction
                    // use deferred to delay the panel
                    field.removeClass('loading');
                    that.submit(false, panelFlyout, serviceURL);
                    $.unsubscribe('openSearchPanel');
                    $.subscribe('openSearchPanel', function() {
                        that.ajaxFinished(field, panelName, panelFlyout);
                    });
                }
            } else {
                // close other panels
                that.ajaxFinished(field, panelName, panelFlyout);
            }
        },
        ajaxFinished: function(field, panelName, flyout) {
            that.postRenderCallback(panelName, flyout);
            if (panelName !== 'destination') {
                flyout.find('.panel').removeClass('flyout-loading');
                $(field).removeClass('loading');
            }
        },
        isAutoSuggestFocusAndOpen: function() {
            return (that.searchAutoSuggest.searchInput.is(':focus') && that.searchAutoSuggest.searchResultFlyout.is(':visible'));
        },
        lastClosingTime: 0,
        /**
         * Close other panels except the one in focus
         * @param  {[type]} inputField [description]
         * @return {[type]}            [description]
         */
        closePanel: function(inputField, fromClearAll) {
            var panelsToBeClosed = that.panels;
            var anyOpenedPanel = false;
            if (that.panels.hasClass('open')) {
                anyOpenedPanel = true;
            }
            var hideArrow = true;
            if (that.isAutoSuggestFocusAndOpen() && that.searchAutoSuggest.searchInput.val().length === 0 && !fromClearAll) {
                hideArrow = false;
                var $objAutoSuggestWrapper = $('#searchDestinationRedesign.dropdown-panel.search-destination.destination.open');
                panelsToBeClosed = that.panels.not(that.searchAutoSuggest.searchResultFlyout, $objAutoSuggestWrapper);
                panelsToBeClosed = that.panels.not($objAutoSuggestWrapper);
            } else {
                var obj = getInactiveOpenPanels(inputField, hideArrow);
                panelsToBeClosed = obj.panelsToHide;
                hideArrow = obj.hideArrow;
            }
            panelsToBeClosed.removeClass('open');
            panelsToBeClosed.hide();
            if (hideArrow) {
                that.panelArrow.hide();
            }
            that.panelOpen = false;
            if (!that.searchAutoSuggest.searchResultFlyout.hasClass('open') && that.searchAutoSuggest.isFlyoutOpen) {
                that.searchAutoSuggest.isFlyoutOpen = true;
            } else {
                that.searchAutoSuggest.isFlyoutOpen = false;
            } /**/
            if (fromClearAll) {
                panelsToBeClosed.hide();
            }
            $('.holiday-tooltip').remove();
            if (!$('#searchWho').hasClass('open')) {
                $(document).find('.tui-tooltip.searchwho').hide();
            }
            var resultSortDD = $('#cb-sort-results');
            if (anyOpenedPanel && resultSortDD.is(':focus')) {
                setTimeout(function() {
                    resultSortDD.blur();
                }, 100);
            }
            that.lastClosingTime = new Date().getTime();
            if (TUIUtil.getCurrentBreakPoint() === 'xs' && !$('#searchDestinationRedesign').hasClass('open')) {
                that.searchAutoSuggest.showHideMobilePickerField(true);
            }
            // if (anyOpenedPanel && searchPanelContainer.length && TUIUtil.getCurrentBreakPoint() !== 'xs' ) {
            // searchPanelContainer.css('position', 'absolute'); // will be handled via windowscrollEvent
            // }
        },
        postRenderCallback: function(panelName, flyoutPanel) {
            flyoutPanel.find('.panel').css('height', 'auto');
            switch (panelName) {
                case 'when':
                    {
                        if ($('.empty-calendar-messgae').length === 0) {
                            this.searchWhen.whenErrorValidations = [];
                            var $calendarOddMonth = $('.owl-wrapper .owl-item:odd');
                            $calendarOddMonth.addClass('shadowDivider');
                        } else {
                            that.panelArrow.css('visibility', 'visible');
                            $('[data-panel-name=when]').css('visibility', 'visible');
                        }
                        if (that.fromSubmit && that.searchWhen.whenErrorValidations.length === 0) {
                            that.searchWhen.whenErrorValidations = [];
                            that.fromSubmit = false;
                            that.submit();
                        }
                        if ($('.ui-datepicker-calendar .date-range-selected').length === 0) {
                            that.searchWhen.setFieldValue('');
                            that.searchWhen.data.userSelectedDate = false;
                        }
                        break;
                    }
                case 'where':
                    {
                        break;
                    }
                case 'airport-to':
                    {
                        break;
                    }
                case 'who':
                    {
                        flyoutPanel.find('.scrollable-panel').removeClass('hidden');
                        that.searchWho.triggerChange();
                        if (that.errorValidations.length !== 0) {
                            that.panelArrow.css('visibility', 'visible');
                            $('[data-panel-name=who]').css('visibility', 'visible');
                        } else if (that.fromSubmit && that.errorValidations.length === 0) {
                            that.submit();
                            that.fromSubmit = false;
                        }
                        break;
                    }
                case 'destination':
                    {
                        this.searchAutoSuggest.openPanel();
                        break;
                    }
                case 'field-duration':
                    {
                        break;
                    }
                case 'searchNowBtn':
                    {
                        flyoutPanel.addClass('open').show();
                        break;
                    }
            }
        },
        resetForm: function() {
            this.searchWhen.resetCalendar(true);
            this.searchWhere.resetAirports();
            this.searchWhereTo.resetAirports();
            this.searchWho.resetParty();
            this.searchAutoSuggest.clearAllTags();
            removeFormValuesCookie();
        },
        getFormValues: function(specialType) {
            var searchType = $('#search-panel-tabs').find('button.active').data('tabname') || 'package',
                when = this.searchWhen.getFormValues(),
                who = this.searchWho.getFormValues(specialType),
                search = this.searchAutoSuggest.getFormValues(specialType),
                where = this.searchWhere.getFormValues(specialType),
                whereTo = this.searchWhereTo.getFormValues(specialType);
            return $.extend(true, {}, {
                'searchType': searchType
            }, who, when, search, where, whereTo);
        },
        setFormValues: function(data, isSetToDefault) {

            var $airportInput;

            if (!isSetToDefault) { // if cookie exist with json data for previous search
                if (data.searchValues && data.searchValues.length) { // update search destination field
                    that.addTagFromCookie = true;
                    $.each(data.searchValues, function(i, item) {
                        var tokens = item.split('|'),
                            countryCode = (tokens[4]) ? tokens[4] : '';
                        that.searchAutoSuggest.addTag(tokens[0], tokens[1], tokens[2], tokens[3], countryCode);
                    });
                    that.addTagFromCookie = false;

                }
                if (data.selectedAirports) { // update arrival airport
                    this.searchWhere.selectedAirports = data.selectedAirports;
                    this.searchWhere.formData.selectedAirports = data.selectedAirports;
                    this.searchWhere.formData.airportText = data.airportText;
                    this.searchWhere.updateInputText(data.airportText);
                }
                if (data.selectedAirportsTo) { // update destination airport
                    this.searchWhereTo.selectedAirportsTo = data.selectedAirportsTo;
                    this.searchWhereTo.formData.selectedAirportsTo = data.selectedAirportsTo;
                    this.searchWhereTo.formData.airportTextTo = data.airportTextTo;
                    this.searchWhereTo.updateInputText(data.airportTextTo);
                }

                if (data.from || data.duration || data.flexible) { // update calandar, flexibility and duration field data
                    var firstDate = Date.parse(TUIUtil.dateConverter(data.from)),
                        todayDate = new Date().setHours(0, 0, 0, 0);
                    if (firstDate >= todayDate) {
                        this.searchWhen.updateDataFromCookie({
                            from: data.from,
                            duration: data.duration,
                            flexible: data.flexible,
                            durationId: data.durationId,
                            durationText: data.durationText
                        });
                    }

                }

            } else { // if no cookie exist then set all the values to default state i.e. make them empty
                that.setFormValuesToDefault(data);
            }
            this.searchWhen.setUserDate(this.searchWhen.isUserDate());
        },
        setFormValuesToDefault: function(data) {
            var $airportInput;
            if (data.searchValues && data.searchValues.length) {
                $.each(data.searchValues, function(i, item) {
                    that.searchAutoSuggest.removeTag(null, null, item.code, item.hierarchy);
                });
            }

            if (data.selectedAirports) {

                $airportInput = $('#airport');
                $airportInput.html('<span class="placeholder-text">' + $airportInput.data('placeholder') + '</span>');
                this.searchWhere.selectedAirports = [];
                this.searchWhere.formData.selectedAirports = [];
                this.searchWhere.formData.airportText = '';
                this.searchWhere.updateInputText('');

            }

            if (data.selectedAirportsTo) {

                $airportInput = $('#airport-to');
                $airportInput.html('<span class="placeholder-text">' + $airportInput.data('placeholder') + '</span>');
                this.searchWhereTo.selectedAirportsTo = [];
                this.searchWhereTo.formData.selectedAirportsTo = [];
                this.searchWhereTo.formData.airportTextTo = '';
                this.searchWhereTo.updateInputText('');

            }

            if (data.from || data.duration || data.flexible) {
                var $dateInput = $('#when'),
                    $durationInput = $('#field-duration'),
                    $flexiblilityInput = $('#field-flexibility');
                $dateInput.html('<span class="placeholder-text">' + $dateInput.data('placeholder') + '</span>');
                $durationInput.html('<span class="placeholder-text">' + $durationInput.data('placeholder') + '</span>');
                $flexiblilityInput.html('<span class="placeholder-text">' + $flexiblilityInput.data('placeholder') + '</span>');
                this.searchWhen.updateDataFromCookie({}, true);
                data.userSelectedDate = false;

            }
        },
        setPartyFromCookie: function(data) {
            if (data && data.rooms && data.rooms.length === 0) {
                delete data.rooms;
            }
            if (data && data.rooms) {
                this.searchWho.formData.rooms = data.rooms;
                this.searchWho.paintRooms(data);
                this.searchWho.setFieldValue(true);
            } else {
                var $who = $('#who');
                $who.val($who.attr('placeholder'));
                if (TUIUtil.isMordernIE) {
                    $who.val('');
                } else {
                    $who.val($who.attr('placeholder'));
                }
                this.searchWho.resetParty();
            }
        },
        switchView: function(e) {
            e.preventDefault();
            var tabName = e.target.getAttribute('data-tabName') || '',
                $ele = $(e.target);

            // add class to wrapper
            this.ele
                .removeClass(this.opts.tabClasses.join(' '))
                .addClass(tabName);
            // set tab state
            $ele
                .parent()
                .siblings()
                .find('a.active')
                .removeClass('active')
                .end()
                .end()
                .end()
                .addClass('active');
        },
        resetDates: function() {
            this.searchWhen.resetDates();
        },
        sendData: function() {
            /*
				ajax call to the server passing in all known input values
				returns int results
			*/
            return; // DISABLING FOR CURRENT RELEASE

        },
        updateDisplay: function(data) {
            // DEMO
            data.results = Math.round(Math.random() * 10000);
            // DEMO end
            // update btn value;
            var text = '',
                btn = this.opts.searchNowBtn,
                n = data.results;
            if (n <= -1 || n > 9999) {
                text = btn.attr('data-default-label');
            } else {
                text = n + ' ' + btn.attr('data-results-label');
            }
            // btn.val(text);

            // DEMO for emotionalHeader swapImg
            var emotionalHeaderImg = 'assets/img/emotional-header' + (n > 5000 ? '-alt' : '') + '.jpg';
            // $.publish('emotionalHeader.swapImg', emotionalHeaderImg);

            // send disabled dates to calendar
            this.searchWhen.processDateArrays(data.disabledDates, 'disabledDates');
        },
        submit: function(validated, target, serviceURL, responseData) {
            // method called on clicking search now / submiting form
            if (that.searchWhen.whenErrorValidations.length) { // if there is error in calendar
                that.fromSubmit = true;
                setTimeout(function() {
                    $('#when').trigger('click').focus();
                }, panelDelay); // delay as the trigger to focus is called first
                return;
            }
            // return;
            else if (that.errorValidations.length) { // if error in party size
                that.fromSubmit = true;
                setTimeout(function() {
                    $(that.errorValidations[0].panelId).trigger('click').focus();
                }, panelDelay); // delay as the trigger to focus is called first
                return;
            }

            var curFormValues = [];
            $('#search-panel input[type="text"]').each(function() {
                if ($.trim($(this).val()) !== '') {
                    curFormValues.push($.trim($(this).val()));
                }
            });

            var formvalues = this.getFormValues('submit');
            var postJSON = setupFormPOSTData(formvalues);
            if (validated) {
                window.location.href = responseData.encodedUrl;
            } else {
                that.validateForm(target, serviceURL, postJSON);
            }
        },

        getFormAction: function(argument) {
            var searchType = $('#search-panel-tabs').find('button.active').data('tabname') || 'package',
                action = form.attr('action');
            if (searchType === 'flight') {
                action = form.data('actionflight');
            } else if (searchType === 'package') {
                action = form.data('actionpackage');
            }

            return action;
        },

        bindMobileSearchInit: function() {
            $('#mobile-search-initializer').on('click', function() {
                $('#search-panel').show();
                $('#mobile-search-initializer').hide();
            });
            $('a.icon-close-panel').on('click', function() {
                $('#search-panel').hide();
                $('#mobile-search-initializer').show();
            });
        },

        currentSize: $(document).width(),

        resizeEvent: function() {
            var $d = $(document);
            $(window).on('resize', function() {
                var size = $d.width();

                if (that.currentSize !== size) {
                    that.currentSize = size;
                    makeStickyButton();

                    $.publish('windowResized', that.changeDropdownPos);
                }
            });
        },
        /**
         * Scoll top only called from tall panels like destination and  destination airport
         * @return {[type]} [description]
         */
        scrollTillSearchPanel: function() {
            $('body,html').animate({
                scrollTop: that.ele.offset().top
            }, function() {
                that.closePanel();
            });
        },
        changeDateAction: function(destination) {
            $('.alternate-link').on('click', function(evt) {
                evt.preventDefault();
                evt.stopPropagation();

                that.searchWho.cleanupTooltips('.tui-tooltip-inline');

                var $t = $(this),
                    alternatePanelName = $t.parents('.validation-err-msg').data('targetpanel');
                if (alternatePanelName === 'both') {
                    alternatePanelName = 'where';
                    that.searchWhen.resetDates();
                }
                if (alternatePanelName === 'when') {
                    that.searchWhen.resetDates();
                }
                var currentItem = $t.data('name');
                that.searchAutoSuggest.addTag(destination.matchedDestination.name, destination.matchedDestination.type, destination.matchedDestination.code, destination.matchedDestination.heirarchy, destination.matchedDestination.countryCode);
                $('#searchPanel-field-search').val('').blur();
                // that.searchAutoSuggest.wrapper.removeClass('focus').addClass('lossFocus'); // DEV-17638
                $('[data-panel="' + alternatePanelName + '"]').trigger('click').focus();
            });
        },
        resetPanelContent: function(flyoutPanel, panelName) {
            switch (panelName) {
                case 'when':
                    {
                        flyoutPanel.find('#search-when-datepicker').empty();
                        break;
                    }
                case 'field-duration':
                    {
                        flyoutPanel.find('#duration-list').empty();
                        break;
                    }
                case 'field-flexibility':
                    {
                        break;
                    }
                case 'where':
                    {
                        flyoutPanel.find('.airport-list-wrapper').empty();
                        break;
                    }
                case 'airport-to':
                    {
                        flyoutPanel.find('.airport-list-wrapper').empty();
                        break;
                    }
                case 'who':
                    {
                        flyoutPanel.find('.scrollable-panel').addClass('hidden');
                        break;
                    }
                case 'destination':
                    {
                        flyoutPanel.find('.country-container').empty();
                        break;
                    }
                case 'searchNowBtn':
                    {
                        break;
                    }
            }
        },
        panelCleanup: function(flyoutPanel, panelName) {
            that.resetPanelContent(flyoutPanel, panelName);
            that.fields.removeClass('loading');
            flyoutPanel.find('.panel').removeClass('flyout-loading');
            flyoutPanel.find('.panel').removeAttr('style');
        },
        // START:- set panel position and cursor position on window resize
        changeDropdownPos: function() {
            // if this function only closes the open panel please use:
            // this.closePanel();
            // this will maintain the panel states and avoid any panel issues at run time

            that.$openPanel.removeClass('open');
            that.closePanel(null, true);
            if (TUIUtil.getCurrentBreakPoint() === 'xs' && !form.find('#searchDestinationRedesign').hasClass('open')) {
                that.searchAutoSuggest.showHideMobilePickerField(true);
            }
        },
        addSupportForArrayIndexOf: function() {
            if (!Array.prototype.indexOf) {
                Array.prototype.indexOf = function(searchElement, fromIndex) {
                    var k;

                    // 1. Let O be the result of calling ToObject passing
                    //    the this value as the argument.
                    if (this === null) {
                        throw new TypeError('"this" is null or not defined');
                    }

                    var O = Object(this);

                    // 2. Let lenValue be the result of calling the Get
                    //    internal method of O with the argument "length".
                    // 3. Let len be ToUint32(lenValue).
                    var len = O.length > 0 ? O.length : 0;

                    // 4. If len is 0, return -1.
                    if (len === 0) {
                        return -1;
                    }

                    // 5. If argument fromIndex was passed let n be
                    //    ToInteger(fromIndex); else let n be 0.
                    var n = +fromIndex || 0;

                    if (Math.abs(n) === Infinity) {
                        n = 0;
                    }

                    // 6. If n >= len, return -1.
                    if (n >= len) {
                        return -1;
                    }

                    // 7. If n >= 0, then Let k be n.
                    // 8. Else, n<0, Let k be len - abs(n).
                    //    If k is less than 0, then let k be 0.
                    k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);

                    // 9. Repeat, while k < len
                    while (k < len) {
                        // var kValue;
                        // a. Let Pk be ToString(k).
                        //   This is implicit for LHS operands of the in operator
                        // b. Let kPresent be the result of calling the
                        //    HasProperty internal method of O with argument Pk.
                        //   This step can be combined with c
                        // c. If kPresent is true, then
                        //    i.  Let elementK be the result of calling the Get
                        //        internal method of O with the argument ToString(k).
                        //   ii.  Let same be the result of applying the
                        //        Strict Equality Comparison Algorithm to
                        //        searchElement and elementK.
                        //  iii.  If same is true, return k.
                        if (k in O && O[k] === searchElement) {
                            return k;
                        }
                        k++;
                    }
                    return -1;
                };
            }
        }
    };
    var scrollPageToSearch = function(slideCallback) {
        if (TUIUtil.getCurrentBreakPoint() !== 'xs') {
            var top = that.ele.offset().top;
            if (searchPanelContainer.length) {
                searchPanelContainer.css('position', 'relative');
                top = searchPanelContainer.offset().top;
            }
            $(window).scrollTop(top);
            setTimeout(function() {
                slideCallback();
            }, 400);
        }
    };
    /**
     * Open the panel only if focus is on same input
     * @param  {[type]} searchPanelInst [description]
     * @param  {[type]} flyoutPanel     [description]
     * @param  {[type]} field      [description]
     * @return {[type]}                 [description]
     */
    var showEmptyPanel = function(searchPanelInst, flyoutPanel, field, panelName, targetCss) {

        that.closePanel(); // one last time closing any already opened panel
        that.panelCleanup(flyoutPanel, panelName);

        TUIUtil.printLog('Inside showEmptyPanel panel :' + panelName + ' and focus:' + field.is(':focus'));

        if (!that.fromSubmit) { // if not coming from form submit
            flyoutPanel.css('visibility', 'visible');
        } else {
            if (that.fromSubmit && (panelName === 'who' || panelName === 'when')) {
                flyoutPanel.css('visibility', 'hidden');
            } else {
                flyoutPanel.css('visibility', 'visible');
            }
        }

        flyoutPanel.parents('form').find('[data-panel-name]').hide();

        var slideCallback = function() {
            if (panelName !== 'searchNowBtn') {
                flyoutPanel.slideDown(300, function() {
                    that.panels
                        .not(flyoutPanel)
                        .filter('.open')
                        .removeClass('open');
                    flyoutPanel.addClass('open').show(); // TODO duplicate
                    that.triggerAjaxForPanel(field, flyoutPanel, panelName);
                    that.$openPanel = flyoutPanel;
                });
            } else {
                that.panels
                    .not(flyoutPanel)
                    .filter('.open')
                    .removeClass('open');

                that.triggerAjaxForPanel(field, flyoutPanel, panelName);
                that.$openPanel = flyoutPanel;
            }

        };
        if (TUIUtil.getCurrentBreakPoint() === 'xs') {
            slideCallback();
        } else {
            scrollPageToSearch(slideCallback);
        }
        if (flyoutPanel.find('.enscroll-track').length >= 1) {
            return;
        } else {
            var scrollablePanel = that.identifyScrollablePanel(panelName, flyoutPanel);
            scrollablePanel.removeAttr('style');
        }
    };

    /**
     * Form Values to be sent in url query parameters
     * removing unwanted params only searchdata should be sent.
     *
     * @param  {[type]} formvalues [description]
     * @return {[type]}            [description]
     */
    var setupFormPOSTData = function(formvalues) {
        var searchInitiator = '';
        if (formvalues.availableDuration) {
            delete formvalues.availableDuration;
        }
        if (formvalues.flexibleText) {
            delete formvalues.flexibleText;
        }
        if (typeof formvalues.holidaysStatesList !== 'undefined') {
            delete formvalues.holidaysStatesList;
        }
        if (typeof formvalues.offerEndDate !== 'undefined') {
            delete formvalues.offerEndDate;
        }
        if (typeof formvalues.travelMessage !== 'undefined') {
            delete formvalues.travelMessage;
        }
        if (formvalues.availableMonths) {
            delete formvalues.availableMonths;
        }

        if (formvalues.holidaysStatesList) {
            delete formvalues.holidaysStatesList;
        }
        if (formvalues.userSelectedDate !== 'undefined') {
            delete formvalues.userSelectedDate;
        }
        if (formvalues.userSelectedDestination) {
            delete formvalues.userSelectedDestination;
        }
        if (formvalues.userSelectedDestination) {
            delete formvalues.userSelectedDestination;
        }
        if ($('body').hasClass('start-page') || $('body').hasClass('search-page') || $('body').hasClass('editable-search')) {
            searchInitiator = 'search';
        } else {
            searchInitiator = 'destination';
        }
        trimSearchValues(formvalues);
        var postJSON = $.extend({}, formvalues, {
            searchInitiator: searchInitiator,
            viewEdit: $('#viewEdit').val(),
            browserURL: window.location.origin
        });
        window.formValuesJSON = postJSON;
        return postJSON;
    };

    var positionPanel = function(panel, targetCss) {
        $('.dropdown-panel .panel').css('height', '');
        var panelHeight = $('.dropdown-panel').height(),
            searchPanelHeight = $('#search-panel').height(),
            adjustedHeight = $(window).height() - $('#search-panel').height(),
            isSTickyinBottom = $('.sticky-panel').css('bottom') === '0px' ? true : false;

        var searchTop = that.ele.offset().top - $(window).scrollTop();

        if (that.ele.hasClass('fixed') || (searchTop < (parseInt($(window).height() / 2, 10)))) {
            targetCss.top = searchPanelHeight + 20;
        } else {
            targetCss.top = -panelHeight + 18;
        }

        isSTickyinBottom && $('.dropdown-panel .panel').height(adjustedHeight - 20);


        return targetCss;
    };

    var trimSearchValues = function(formvalues) {
        if (formvalues.searchValues) {
            $.each(formvalues.searchValues, function(i, item) {
                if (i > 0) {
                    delete item.name;
                }
                delete item.hierarchy;
                if (item.countryCode) {
                    delete item.countryCode;
                }
            });
        }
    };
    var getInactiveOpenPanels = function(inputField, hideArrow) {
        var focusInput = inputField || that.ele.find('input[data-panel]:focus'),
            retObj = {
                panelsToHide: that.panels,
                hideArrow: hideArrow
            };
        if (focusInput.length) {
            var id = focusInput.attr('id');
            var flyoutId = null;
            switch (id) {
                case 'airport':
                    {
                        flyoutId = 'searchWhere';
                        break;
                    }
                case 'airport-to':
                    {
                        flyoutId = 'searchWhereTo';
                        break;
                    }
                case 'when':
                    {
                        flyoutId = 'searchWhen';
                        break;
                    }
                case 'who':
                    {
                        flyoutId = 'searchWho';
                        break;
                    }
            }

            if (flyoutId) {
                retObj.panelsToHide = that.panels.not($('#' + flyoutId));
                retObj.hideArrow = false;
            }
        }
        return retObj;
    };
    var isSearchPage = $('body').hasClass('search-core-page'); // Search or Result page

    var istabletOrDesktop = function() {
        if (TUIUtil.getCurrentBreakPoint() === 'lg' || TUIUtil.getCurrentBreakPoint() === 'md' || TUIUtil.getCurrentBreakPoint() === 'sm') {
            return true;
        } else {
            return false;
        }
    };
    var makeStickyButton = function() {
        var stickyMobile = $('.sticky-mobile'),
            searchButton = $('#searchNowBtn');
        if (stickyMobile.length && TUIUtil.getCurrentBreakPoint() === 'xs' && isResultPage) {
            return;
        } else if ((searchButton.length) && !istabletOrDesktop() && !stickyMobile.length && searchButton.is(':visible')) {
            searchButton.wrap('<div class="sticky-mobile"></div>');
            $('.sticky-mobile').scrollToFixed({
                bottom: 0,
                left: 0,
                limit: $('.sticky-mobile').offset().top - 70
            });
            $('.sticky-mobile').next('div').remove();
        } else if ((stickyMobile.length) && istabletOrDesktop()) {
            stickyMobile.next('div').remove();
            searchButton.unwrap();
        }
    };

    /**
     * Break the formvalues cookie into two parts
     * Persistent Cookie  - Party Size
     * Session Cookie - Rest all
     * @return {[type]} [description]
     */
    var bifurcateFormCookie = function(searchType) {
        var availableJSON;
        if (searchType === 'flight') { // flight only cookie json
            availableJSON = (typeof flightOnlyValuesJSON !== 'undefined') ? flightOnlyValuesJSON : undefined;
        } else { // package only cookie json
            availableJSON = (typeof formValuesJSON !== 'undefined') ? formValuesJSON : undefined;
        }

        if (typeof(availableJSON) === 'undefined') {
            return true;
        }
        var tempJSON = $.extend({}, availableJSON);
        var sessionCookieJSON = {};
        var persistentCookieJSON = {};

        persistentCookieJSON.rooms = tempJSON.rooms || [];

        delete tempJSON.rooms;

        $.extend(sessionCookieJSON, tempJSON);
        if (searchType === 'flight') {
            $.cookie('flightvalues', JSON.stringify(sessionCookieJSON), {
                expires: 1,
                path: '/'
            });
            $.cookie('FLIGHT_PARTY_COOKIE', JSON.stringify(persistentCookieJSON), { // separate party cookie for flight
                expires: 30,
                path: '/'
            });
        } else {
            $.cookie('formvalues', JSON.stringify(sessionCookieJSON), {
                expires: 1,
                path: '/'
            });
            $.cookie('PARTY_COOKIE', JSON.stringify(persistentCookieJSON), {
                expires: 30,
                path: '/'
            });
        }



    };
    /**
     * Remove form values cookie
     * @return {[type]} [description]
     */
    var removeFormValuesCookie = function() {
        $.cookie('formvalues', JSON.stringify({}), {
            path: '/'
        });
        $.cookie('PARTY_COOKIE', JSON.stringify({}), {
            path: '/'
        });
    };

    /**
     * On Browser back.
     * @return {[type]} [description]
     */
    var removeDisabled = function() {
        form.find('input').removeAttr('disabled');
        form.find('select').removeAttr('disabled');
    };

    var resetSearchEvent = function() {
        form.on('click', '#clear-all-search', function(e) {
            that.resetForm();
            that.closePanel(null, true);
        });
    };

    var bindFieldIconClickEvent = function() {
        that.ele.on('click', '.field-label-container', function(e) {
            if ($(this).parents('.field-search').length) {
                $(this).next().next('[data-panel]').trigger('click').focus();
            } else {
                $(this).next('[data-panel]').trigger('click').focus();
            }

        });
    };
    /**
     * Temp code should be removed once backedn cleanup of v-3 depenedency is removed
     * @return {[type]} [description]
     */
    var checkAndCreateVersion3Cookie = function() {
        $.cookie('search-panel-version', 'version-3', {
            path: '/'
        });
    };

    $.extend(SearchPanel.prototype, methods);
    return SearchPanel;

});

/*!
 * jQuery UI Widget 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/widget', ["jquery"], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var widget_uuid = 0,
        widget_slice = Array.prototype.slice;

    $.cleanData = (function(orig) {
        return function(elems) {
            for (var i = 0, elem;
                (elem = elems[i]) != null; i++) {
                try {
                    $(elem).triggerHandler("remove");
                    // http://bugs.jquery.com/ticket/8235
                } catch (e) {}
            }
            orig(elems);
        };
    })($.cleanData);

    $.widget = function(name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype,
            // proxiedPrototype allows the provided prototype to remain unmodified
            // so that it can be used as a mixin for multiple widgets (#8876)
            proxiedPrototype = {},
            namespace = name.split(".")[0];

        name = name.split(".")[1];
        fullName = namespace + "-" + name;

        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }

        // create selector for plugin
        $.expr[":"][fullName.toLowerCase()] = function(elem) {
            return !!$.data(elem, fullName);
        };

        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function(options, element) {
            // allow instantiation without "new" keyword
            if (!this._createWidget) {
                return new constructor(options, element);
            }

            // allow instantiation without initializing for simple inheritance
            // must use "new" keyword (the code above always passes args)
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        // extend with the existing constructor to carry over any static properties
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            // copy the object used to create the prototype in case we need to
            // redefine the widget later
            _proto: $.extend({}, prototype),
            // track widgets that inherit from this widget in case this widget is
            // redefined after a widget inherits from it
            _childConstructors: []
        });

        basePrototype = new base();
        // we need to make the options hash a property directly on the new instance
        // otherwise we'll modify the options hash on the prototype that we're
        // inheriting from
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function(prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = (function() {
                var _super = function() {
                        return base.prototype[prop].apply(this, arguments);
                    },
                    _superApply = function(args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function() {
                    var __super = this._super,
                        __superApply = this._superApply,
                        returnValue;

                    this._super = _super;
                    this._superApply = _superApply;

                    returnValue = value.apply(this, arguments);

                    this._super = __super;
                    this._superApply = __superApply;

                    return returnValue;
                };
            })();
        });
        constructor.prototype = $.widget.extend(basePrototype, {
            // TODO: remove support for widgetEventPrefix
            // always use the name + a colon as the prefix, e.g., draggable:start
            // don't prefix for widgets that aren't DOM-based
            widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
        }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });

        // If this widget is being redefined then we need to find all widgets that
        // are inheriting from it and redefine all of them so that they inherit from
        // the new version of this widget. We're essentially trying to replace one
        // level in the prototype chain.
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function(i, child) {
                var childPrototype = child.prototype;

                // redefine the child widget using the same prototype that was
                // originally used, but inherit from the new version of the base
                $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
            });
            // remove the list of existing child constructors from the old constructor
            // so the old child constructors can be garbage collected
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }

        $.widget.bridge(name, constructor);

        return constructor;
    };

    $.widget.extend = function(target) {
        var input = widget_slice.call(arguments, 1),
            inputIndex = 0,
            inputLength = input.length,
            key,
            value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    // Clone objects
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ?
                            $.widget.extend({}, target[key], value) :
                            // Don't extend strings, arrays, etc. with objects
                            $.widget.extend({}, value);
                        // Copy everything else by reference
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };

    $.widget.bridge = function(name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function(options) {
            var isMethodCall = typeof options === "string",
                args = widget_slice.call(arguments, 1),
                returnValue = this;

            // allow multiple hashes to be passed on init
            options = !isMethodCall && args.length ?
                $.widget.extend.apply(null, [options].concat(args)) :
                options;

            if (isMethodCall) {
                this.each(function() {
                    var methodValue,
                        instance = $.data(this, fullName);
                    if (options === "instance") {
                        returnValue = instance;
                        return false;
                    }
                    if (!instance) {
                        return $.error("cannot call methods on " + name + " prior to initialization; " +
                            "attempted to call method '" + options + "'");
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
                        return $.error("no such method '" + options + "' for " + name + " widget instance");
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ?
                            returnValue.pushStack(methodValue.get()) :
                            methodValue;
                        return false;
                    }
                });
            } else {
                this.each(function() {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }

            return returnValue;
        };
    };

    $.Widget = function( /* options, element */ ) {};
    $.Widget._childConstructors = [];

    $.Widget.prototype = {
        widgetName: "widget",
        widgetEventPrefix: "",
        defaultElement: "<div>",
        options: {
            disabled: false,

            // callbacks
            create: null
        },
        _createWidget: function(options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widget_uuid++;
            this.eventNamespace = "." + this.widgetName + this.uuid;
            this.options = $.widget.extend({},
                this.options,
                this._getCreateOptions(),
                options);

            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();

            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function(event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ?
                    // element within the document
                    element.ownerDocument :
                    // element is window or document
                    element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }

            this._create();
            this._trigger("create", null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,

        destroy: function() {
            this._destroy();
            // we can probably remove the unbind calls in 2.0
            // all event bindings should go through this._on()
            this.element
                .unbind(this.eventNamespace)
                .removeData(this.widgetFullName)
                // support: jquery <1.6.3
                // http://bugs.jquery.com/ticket/9413
                .removeData($.camelCase(this.widgetFullName));
            this.widget()
                .unbind(this.eventNamespace)
                .removeAttr("aria-disabled")
                .removeClass(
                    this.widgetFullName + "-disabled " +
                    "ui-state-disabled");

            // clean up events and states
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
        },
        _destroy: $.noop,

        widget: function() {
            return this.element;
        },

        option: function(key, value) {
            var options = key,
                parts,
                curOption,
                i;

            if (arguments.length === 0) {
                // don't return a reference to the internal hash
                return $.widget.extend({}, this.options);
            }

            if (typeof key === "string") {
                // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
                options = {};
                parts = key.split(".");
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }

            this._setOptions(options);

            return this;
        },
        _setOptions: function(options) {
            var key;

            for (key in options) {
                this._setOption(key, options[key]);
            }

            return this;
        },
        _setOption: function(key, value) {
            this.options[key] = value;

            if (key === "disabled") {
                this.widget()
                    .toggleClass(this.widgetFullName + "-disabled", !!value);

                // If the widget is becoming disabled, then nothing is interactive
                if (value) {
                    this.hoverable.removeClass("ui-state-hover");
                    this.focusable.removeClass("ui-state-focus");
                }
            }

            return this;
        },

        enable: function() {
            return this._setOptions({
                disabled: false
            });
        },
        disable: function() {
            return this._setOptions({
                disabled: true
            });
        },

        _on: function(suppressDisabledCheck, element, handlers) {
            var delegateElement,
                instance = this;

            // no suppressDisabledCheck flag, shuffle arguments
            if (typeof suppressDisabledCheck !== "boolean") {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }

            // no element argument, shuffle and use this.element
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }

            $.each(handlers, function(event, handler) {
                function handlerProxy() {
                    // allow widgets to customize the disabled handling
                    // - disabled as an array instead of boolean
                    // - disabled class as method for disabling individual parts
                    if (!suppressDisabledCheck &&
                        (instance.options.disabled === true ||
                            $(this).hasClass("ui-state-disabled"))) {
                        return;
                    }
                    return (typeof handler === "string" ? instance[handler] : handler)
                        .apply(instance, arguments);
                }

                // copy the guid so direct unbinding works
                if (typeof handler !== "string") {
                    handlerProxy.guid = handler.guid =
                        handler.guid || handlerProxy.guid || $.guid++;
                }

                var match = event.match(/^([\w:-]*)\s*(.*)$/),
                    eventName = match[1] + instance.eventNamespace,
                    selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },

        _off: function(element, eventName) {
            eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
        },

        _delay: function(handler, delay) {
            function handlerProxy() {
                return (typeof handler === "string" ? instance[handler] : handler)
                    .apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },

        _hoverable: function(element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function(event) {
                    $(event.currentTarget).addClass("ui-state-hover");
                },
                mouseleave: function(event) {
                    $(event.currentTarget).removeClass("ui-state-hover");
                }
            });
        },

        _focusable: function(element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function(event) {
                    $(event.currentTarget).addClass("ui-state-focus");
                },
                focusout: function(event) {
                    $(event.currentTarget).removeClass("ui-state-focus");
                }
            });
        },

        _trigger: function(type, event, data) {
            var prop, orig,
                callback = this.options[type];

            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ?
                type :
                this.widgetEventPrefix + type).toLowerCase();
            // the original event may come from any element
            // so we need to reset the target on the new event
            event.target = this.element[0];

            // copy original event properties over to the new event
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }

            this.element.trigger(event, data);
            return !($.isFunction(callback) &&
                callback.apply(this.element[0], [event].concat(data)) === false ||
                event.isDefaultPrevented());
        }
    };

    $.each({
        show: "fadeIn",
        hide: "fadeOut"
    }, function(method, defaultEffect) {
        $.Widget.prototype["_" + method] = function(element, options, callback) {
            if (typeof options === "string") {
                options = {
                    effect: options
                };
            }
            var hasOptions,
                effectName = !options ?
                method :
                options === true || typeof options === "number" ?
                defaultEffect :
                options.effect || defaultEffect;
            options = options || {};
            if (typeof options === "number") {
                options = {
                    duration: options
                };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function(next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });

    return $.widget;

}));

/*!
 * jQuery UI Mouse 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/mouse', [
            "jquery",
            "./widget"
        ], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var mouseHandled = false;
    $(document).mouseup(function() {
        mouseHandled = false;
    });

    return $.widget("ui.mouse", {
        version: "1.11.0",
        options: {
            cancel: "input,textarea,button,select,option",
            distance: 1,
            delay: 0
        },
        _mouseInit: function() {
            var that = this;

            this.element
                .bind("mousedown." + this.widgetName, function(event) {
                    return that._mouseDown(event);
                })
                .bind("click." + this.widgetName, function(event) {
                    if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
                        $.removeData(event.target, that.widgetName + ".preventClickEvent");
                        event.stopImmediatePropagation();
                        return false;
                    }
                });

            this.started = false;
        },

        // TODO: make sure destroying one instance of mouse doesn't mess with
        // other instances of mouse
        _mouseDestroy: function() {
            this.element.unbind("." + this.widgetName);
            if (this._mouseMoveDelegate) {
                this.document
                    .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                    .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
            }
        },

        _mouseDown: function(event) {
            // don't let more than one widget handle mouseStart
            if (mouseHandled) {
                return;
            }

            // we may have missed mouseup (out of window)
            (this._mouseStarted && this._mouseUp(event));

            this._mouseDownEvent = event;

            var that = this,
                btnIsLeft = (event.which === 1),
                // event.target.nodeName works around a bug in IE 8 with
                // disabled inputs (#7620)
                elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
            if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
                return true;
            }

            this.mouseDelayMet = !this.options.delay;
            if (!this.mouseDelayMet) {
                this._mouseDelayTimer = setTimeout(function() {
                    that.mouseDelayMet = true;
                }, this.options.delay);
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted = (this._mouseStart(event) !== false);
                if (!this._mouseStarted) {
                    event.preventDefault();
                    return true;
                }
            }

            // Click event may never have fired (Gecko & Opera)
            if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
                $.removeData(event.target, this.widgetName + ".preventClickEvent");
            }

            // these delegates are required to keep context
            this._mouseMoveDelegate = function(event) {
                return that._mouseMove(event);
            };
            this._mouseUpDelegate = function(event) {
                return that._mouseUp(event);
            };

            this.document
                .bind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .bind("mouseup." + this.widgetName, this._mouseUpDelegate);

            event.preventDefault();

            mouseHandled = true;
            return true;
        },

        _mouseMove: function(event) {
            // IE mouseup check - mouseup happened when mouse was out of window
            if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
                return this._mouseUp(event);

                // Iframe mouseup check - mouseup occurred in another document
            } else if (!event.which) {
                return this._mouseUp(event);
            }

            if (this._mouseStarted) {
                this._mouseDrag(event);
                return event.preventDefault();
            }

            if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
                this._mouseStarted =
                    (this._mouseStart(this._mouseDownEvent, event) !== false);
                (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
            }

            return !this._mouseStarted;
        },

        _mouseUp: function(event) {
            this.document
                .unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
                .unbind("mouseup." + this.widgetName, this._mouseUpDelegate);

            if (this._mouseStarted) {
                this._mouseStarted = false;

                if (event.target === this._mouseDownEvent.target) {
                    $.data(event.target, this.widgetName + ".preventClickEvent", true);
                }

                this._mouseStop(event);
            }

            mouseHandled = false;
            return false;
        },

        _mouseDistanceMet: function(event) {
            return (Math.max(
                Math.abs(this._mouseDownEvent.pageX - event.pageX),
                Math.abs(this._mouseDownEvent.pageY - event.pageY)
            ) >= this.options.distance);
        },

        _mouseDelayMet: function( /* event */ ) {
            return this.mouseDelayMet;
        },

        // These are placeholder methods, to be overriden by extending plugin
        _mouseStart: function( /* event */ ) {},
        _mouseDrag: function( /* event */ ) {},
        _mouseStop: function( /* event */ ) {},
        _mouseCapture: function( /* event */ ) {
            return true;
        }
    });

}));

/*!
 * jQuery UI Slider 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 * @@@@@@@@@@@@@@@@@ SAPIENT CHANGE LOG @@@@@@@@@@@@@@@@@@@
 * 
 * _stop: method : minor change to pass additionalOpts , see the method
 * 
 * @@@@@@@@@@@@@@@@@ SAPIENT CHANGE LOG @@@@@@@@@@@@@@@@@@@
 */
(function(factory) {
    if (typeof define === "function" && define.amd) {

        // AMD. Register as an anonymous module.
        define('vendor/slider', [
            "jquery",
            "./core",
            "./mouse",
            "./widget"
        ], factory);
    } else {

        // Browser globals
        factory(jQuery);
    }
}(function($) {

    return $.widget("ui.slider", $.ui.mouse, {
        version: "1.11.0",
        widgetEventPrefix: "slide",

        options: {
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            value: 0,
            values: null,

            // callbacks
            change: null,
            slide: null,
            start: null,
            stop: null
        },

        // number of pages in a slider
        // (how many times can you page up/down to go through the whole range)
        numPages: 5,

        _create: function() {
            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();

            this.element
                .addClass("ui-slider" +
                    " ui-slider-" + this.orientation +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");

            this._refresh();
            this._setOption("disabled", this.options.disabled);

            this._animateOff = false;
        },

        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function() {
            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this.handle = this.handles.eq(0);

            this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },

        _createRange: function() {
            var options = this.options,
                classes = "";

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [options.values[0], options.values[0]];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>")
                        .appendTo(this.element);

                    classes = "ui-slider-range" +
                        // note: this isn't the most fittingly semantic framework class for this element,
                        // but worked best visually with a variety of themes
                        " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max")
                        // Handle range switching from true to min/max
                        .css({
                            "left": "",
                            "bottom": ""
                        });
                }

                this.range.addClass(classes +
                    ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _setupEvents: function() {
            this._off(this.handles);
            this._on(this.handles, this._handleEvents);
            this._hoverable(this.handles);
            this._focusable(this.handles);
        },

        _destroy: function() {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }

            this.element
                .removeClass("ui-slider" +
                    " ui-slider-horizontal" +
                    " ui-slider-vertical" +
                    " ui-widget" +
                    " ui-widget-content" +
                    " ui-corner-all");

            this._mouseDestroy();
        },

        _mouseCapture: function(event) {
            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) ||
                    (distance === thisDistance &&
                        (i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle
                .addClass("ui-state-active")
                .focus();

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top -
                    (closestHandle.height() / 2) -
                    (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) -
                    (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) +
                    (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function() {
            return true;
        },

        _mouseDrag: function(event) {
            var position = {
                    x: event.pageX,
                    y: event.pageY
                },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function(event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function() {
            this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function(position) {
            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },

        _slide: function(event, index, newVal) {
            var otherVal,
                newValues,
                allowed;

            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);

                if ((this.options.values.length === 2 && this.options.range === true) &&
                    ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))
                ) {
                    newVal = otherVal;
                }

                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },

        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
                uiHash.additionalOpts = this.options.additionalOpts;
            }

            this._trigger("stop", event, uiHash);
        },

        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;

                this._trigger("change", event, uiHash);
            }
        },

        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },

        values: function(index, newValue) {
            var vals,
                newValues,
                i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function(key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }

            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            if (key === "disabled") {
                this.element.toggleClass("ui-state-disabled", !!value);
            }

            this._super(key, value);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this.element
                        .removeClass("ui-slider-horizontal ui-slider-vertical")
                        .addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "min":
                case "max":
                    this._animateOff = true;
                    this._refreshValue();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function(index) {
            var val,
                vals,
                i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this.options.values && this.options.values.length) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) {
                alignValue += (valModStep > 0) ? step : (-step);
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _valueMin: function() {
            return this.options.min;
        },

        _valueMax: function() {
            return this.options.max;
        },

        _refreshValue: function() {
            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = (!this._animateOff) ? o.animate : false,
                _set = {};

            if (this.options.values && this.options.values.length) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: (valPercent) + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else {
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = (valueMax !== valueMin) ?
                    (value - valueMin) / (valueMax - valueMin) * 100 :
                    0;
                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({
                        width: (100 - valPercent) + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({
                        height: (100 - valPercent) + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
            }
        },

        _handleEvents: {
            keydown: function(event) {
                var allowed, curVal, newVal, step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            $(event.target).addClass("ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(
                            curVal + ((this._valueMax() - this._valueMin()) / this.numPages)
                        );
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(
                            curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            },
            keyup: function(event) {
                var index = $(event.target).data("ui-slider-handle-index");

                if (this._keySliding) {
                    this._keySliding = false;
                    this._stop(event, index);
                    this._change(event, index);
                    $(event.target).removeClass("ui-state-active");
                }
            }
        }
    });

}));

/* global define */
/* Abstract class to wrap jquery ui slider */

define('search-results/range-slider', ['jquery', 'vendor/slider'], function($) {
    function RangeSlider(ele, opts) {
        var that = this;
        that.ele = ele;
        that.opts = $.extend(true, {}, {
            slider: {
                slide: $.proxy(that.slide, that),
                prop: 1,
                change: $.proxy(that.change, that)
            }
        }, opts);
        // merge values [passed options, defaults, add via html data-rangeSettings]
        that.sliderSettings = $.extend(true, {}, $.parseJSON(that.ele.attr('data-rangeSettings') || '{}'), that.opts.slider);
        that.prefix = this.sliderSettings.prefix || '';
        that.valueDisplays = [];
        that.init();
        that.showDate();
    }

    var methods = {
        init: function() {
            var that = this;
            // init the jquery UI slider
            that.ele.slider(that.sliderSettings);
            that.addDomElements();
            // update start values;
            that.updateDisplay('', {
                values: that.ele.slider('option', 'values')
            });
        },
        addDomElements: function() {
            // add DOM elements for value display
            this.ele.find('.ui-slider-handle').each(function() {
                this.valueDisplays.push($(this).append('<span />').find('span'));
            });
        },

        slide: function(evt, ui) {
            this.updateDisplay(evt, ui);
        },
        updateDisplay: function(evt, ui) {
            if (!ui.values) {
                return;
            }

            // move any non generic code into a new instance or create a new class that inherits this
            var l = ui.values.length;
            for (var i = 0; i < l; i++) {
                this.valueDisplays[i].text(this.prefix + ui.values[i]);
            }
            if (ui.handle && $(ui.handle).closest('#flightDuration').length) {
                this.updateSelection(evt, ui);
            }

        },
        updateSelection: function(evt, ui) {
            if (!ui.values) {
                return;
            }
            var that = this,
                handleIndex,
                tdIndex, handleText, lastHandleText, firstHandleText,
                tds = $('.flight-options .ui-datepicker-calendar tbody td');
            if (ui.handle && $(ui.handle).closest('#flightDuration').length) {
                handleIndex = $('#flightDuration .ui-slider-handle').index($(ui.handle));
            } else {
                handleIndex = null;
            }
            if (handleIndex === 0) {
                tdIndex = parseInt($('#flightDuration .ui-slider-handle').eq(0).attr('data-index'), 10);
                handleText = parseInt($('#flightDuration .ui-slider-handle').eq(0).find('span').text(), 10);
                lastHandleText = parseInt($('#flightDuration .ui-slider-handle').eq(1).find('span').text(), 10);
                if (lastHandleText - handleText < 2) {
                    return;
                }
                if (tdIndex < handleText) {
                    tds.filter(':lt(' + (handleText) + ')').removeClass('date-range-selected');
                    $('#flightDuration .ui-slider-handle').eq(0).attr('data-index', handleText);
                }
                if (tdIndex > handleText) {
                    if (!tds.eq(handleText).hasClass('ui-datepicker-unselectable') || !tds.eq(handleText).hasClass('ui-state-disabled')) {
                        tds.eq(handleText).addClass('date-range-selected');
                    }
                    tds.filter(':lt(' + (lastHandleText - 1) + ')').filter(':gt(' + (handleText) + ')').each(function() {
                        if (!$(this).hasClass('ui-datepicker-unselectable') || !$(this).hasClass('ui-state-disabled')) {
                            $(this).addClass('date-range-selected');
                        }
                    });
                    $('#flightDuration .ui-slider-handle').eq(0).attr('data-index', handleText);

                }
                that.updateDuration(handleText, lastHandleText);
            }
            if (handleIndex === 1) {
                tdIndex = parseInt($('#flightDuration .ui-slider-handle').eq(1).attr('data-index'), 10);
                handleText = parseInt($('#flightDuration .ui-slider-handle').eq(1).find('span').text(), 10);
                firstHandleText = parseInt($('#flightDuration .ui-slider-handle').eq(0).find('span').text(), 10);
                if (handleText - firstHandleText < 2) {
                    return;
                }
                if (tdIndex < handleText) {
                    if (!tds.eq(handleText - 2).hasClass('ui-datepicker-unselectable') || !tds.eq(handleText - 2).hasClass('ui-state-disabled')) {
                        tds.eq(handleText - 2).addClass('date-range-selected');

                    }
                    tds.filter(':lt(' + (handleText - 2) + ')').filter(':gt(' + (firstHandleText) + ')').each(function() {
                        if (!$(this).hasClass('ui-datepicker-unselectable') || !$(this).hasClass('ui-state-disabled')) {
                            $(this).addClass('date-range-selected');
                        }
                    });
                    $('#flightDuration .ui-slider-handle').eq(1).attr('data-index', handleText);

                }
                if (tdIndex > handleText) {

                    tds.filter(':gt(' + (handleText - 2) + ')').removeClass('date-range-selected');
                    $('#flightDuration .ui-slider-handle').eq(1).attr('data-index', handleText);
                }
            }
        },

        updateDuration: function(firstHandleText, lastHandleText) {
            /*if(!ui.handle){
				return;
			}*/
            var monthsArr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                weekDaysArr = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                tds = $('.flight-options .ui-datepicker-calendar tbody td'),
                rangeStartYear = tds.eq(firstHandleText).data('year'),
                rangeStartMonth = tds.eq(firstHandleText).data('month'),
                rangeStartDate = parseInt(tds.eq(firstHandleText).find('a').text(), 10),
                rangeStartDay = tds.eq(firstHandleText).closest('tr').find('td').index(tds.eq(firstHandleText)),
                rangeEndYear = tds.eq(lastHandleText - 2).data('year'),
                rangeEndMonth = tds.eq(lastHandleText - 2).data('month'),
                rangeEndDate = parseInt(tds.eq(lastHandleText - 2).find('a').text(), 10),
                rangeEndDay = tds.eq(lastHandleText - 2).closest('tr').find('td').index(tds.eq(lastHandleText - 2));
            console.log('rangeStartYear:' + rangeStartYear + ',rangeStartMonth:' + rangeStartMonth + ',rangeStartDate:' + rangeStartDate + ',rangeStartDay:' + rangeStartDay);
            console.log('rangeEndYear:' + rangeEndYear + ',rangeEndMonth:' + rangeEndMonth + ',rangeEndDate:' + rangeEndDate + ',rangeEndDay:' + rangeEndDay);
            var durationText = weekDaysArr[rangeStartDay] + ' ' + rangeStartDate + ' ' + monthsArr[rangeStartMonth] + ' - ' + weekDaysArr[rangeEndDay] + ' ' + rangeEndDate + ' ' + monthsArr[rangeEndMonth];
            $('.time-date em').text(durationText);
            var dateShow = $('.time-date em').text();
            $('.header em').html(dateShow);
        },
        showDate: function() {
            var dateShow = $('.time-date em').text();
            $('.header em').html(dateShow);
        }

    };

    for (var key in methods) {
        RangeSlider.prototype[key] = methods[key];
    }

    return RangeSlider;
});

define('helpers/inherit', [], function() {
    'use strict';

    function inherit(class1, class2) {
        for (var key in class1.prototype) {
            if (!(key in class2.prototype)) {
                class2.prototype[key] = class1.prototype[key];
            }
        }
    }

    return inherit;
});
define('search-results/star-slider', ['jquery', 'helpers/inherit', './range-slider'], function($, inherit, RangeSlider) {
    function StarSlider(ele, opts) {
        opts = opts || {
            slider: {}
        };
        opts.slider.min = 1;
        opts.slider.max = 10;
        opts.slider.range = true;
        RangeSlider.apply(this, [ele, opts]);
    }

    var methods = {
        updateDisplay: function(evt, ui) {
            var l = ui.values.length,
                half = false,
                value,
                stars,
                icons;
            for (var i = 0; i < l; i++) {
                value = ui.values[i];
                half = value % 2 ? true : false;
                stars = Math.floor(value / 2);
                icons = this.valueDisplays[i].find('i');

                if (half) {
                    ++stars;
                }

                icons.show()
                    .slice(stars)
                    .hide()
                    .end()
                    .filter(':visible')
                    .last()[half ? 'addClass' : 'removeClass']('half');
            }
        },
        addDomElements: function() {
            var that = this,
                html = '<span class="rel"><span class="stars"><i /><i /><i /><i /><i /></span></span>';
            // add DOM elements for value display
            that.ele.find('.ui-slider-handle').each(function() {
                that.valueDisplays.push($(that).append(html).find('span').first());
            });
        }
    };

    for (var key in methods) {
        StarSlider.prototype[key] = methods[key];
    }

    inherit(RangeSlider, StarSlider);

    return StarSlider;
});

define('helpers/supports', [], function() {
    function supports(prop) {
        var div = document.createElement('div');
        return prop in div.style;
    }

    return supports;
});
define('common/responsive-carousel', [
        'jquery',
        'helpers/resize',
        'helpers/supports'
    ],
    function($, resize, supports) {
        function ResponsiveCarousel(ele, opts) {
            TUIUtil.printLog('Inside new ResponsiveCarousel()');
            this.ele = ele;
            this.opts = $.extend({}, {
                itemSelector: '.item',
                itemWrapper: '.mask > .row',
                pagingWrapper: 'ul.paging',
                currentBreakpoint: false,
                touchThreshold: 0.4,
                speed: 400,
                resizeItems: false
            }, opts);
            this.itemWidth = 0;
            this.index = 0;
            this.x = 0;
            this.y = 0;
            this.css3 = supports('webkitTransform');

            this.init();
        }

        var methods = {
            init: function() {
                var that = this;
                this.items = this.ele.find(this.opts.itemSelector);
                this.itemWrapper = this.ele.find(this.opts.itemWrapper);
                this.total = this.items.length;
                this.pagingWrapper = this.ele.find(this.opts.pagingWrapper);
                this.btnNext = this.ele.find('a.next');
                this.btnPrev = this.ele.find('a.prev');

                // bind events

                function _btnEvent(e) {
                    e.preventDefault();
                    if ($(e.target).is('disabled')) {
                        return false;
                    }
                    var dir = e.target.getAttribute('data-dir') || e.target.getAttribute('classname');
                    that[dir]();
                }

                this.ele
                    .on('click', 'a.next, a.prev', _btnEvent)
                    .on('click', 'ul.paging a', function(e) {
                        e.preventDefault();
                        that.goTo(parseInt(this.getAttribute('data-index'), 10));
                    });

                $.subscribe('breakpointchange', $.proxy(that.resize, that));

                this.layout();
                this.bindTouch();
            },
            bindTouch: function() {
                var that = this;
                if (this.screens <= 1) {
                    return;
                }
                this.itemWrapper[0].style.webkitTransform = 'translate3d(0px,0px,0px)';
                this.itemWrapper[0].ontouchstart = function(e) {
                    if (e.targetTouches.length !== 1 || e.touches.length !== 1) {
                        return false;
                    }
                    that.itemWrapper[0].style.webkitTransition = '';
                    that.startX = e.targetTouches[0].clientX;
                    that.cTouch = that.startX;
                    that.startY = e.targetTouches[0].clientY;
                    that.getPosition(that.itemWrapper[0].style.webkitTransform);
                };
                this.itemWrapper[0].ontouchmove = function(e) {
                    if (e.targetTouches.length !== 1) {
                        return false;
                    }
                    if (e.targetTouches.length !== 1 || e.touches.length !== 1) {
                        return false;
                    }
                    var leftDelta = e.targetTouches[0].clientX - that.startX;
                    if (Math.abs(leftDelta) > 5) {
                        e.preventDefault();
                    }

                    var newX = parseInt(that.x + leftDelta, 10);
                    this.style.webkitTransform = 'translate3d(' + newX + 'px,0,0)';
                    that.cTouch = e.targetTouches[0].clientX;
                };
                this.itemWrapper[0].ontouchend = function(e) {
                    var difX = that.startX - that.cTouch,
                        limit = that.ele.width() * that.opts.touchThreshold;
                    e.preventDefault();
                    if (e.targetTouches.length > 0 || e.touches.length > 0) {
                        return false;
                    }
                    if (difX > limit) {
                        that.next();
                    } else if (difX < -limit) {
                        that.prev();
                    } else {
                        that.goTo(that.index);
                    }
                };
            },
            getPosition: function(transform) {
                var v = transform.replace(/[a-z]/g, '').replace('3(', '').replace(')', '').split(',') || [0, 0, 0];
                this.x = parseInt(v[0], 10);
                this.y = parseInt(v[1], 10);
            },
            /**
             * Using layouting via setTimeout to reduce the perforamnce issues
             * as parallel loading will help when the number of ResponsiveCarousel is huge
             *
             * @param  {[type]} thisContext [description]
             * @return {[type]}             [description]
             */
            doLayoutOnResize: function(thisContext) {
                setTimeout(function() {
                    thisContext.layout()
                        .done(function() {
                            // TODO: get correct index when screens have changed
                            thisContext.getIndex(thisContext.index);
                            thisContext.preMove();
                        });
                }, 50);
            },
            resize: function() {
                var that = this;
                that.opts.currentBreakpoint = arguments[1];
                that.doLayoutOnResize(that);
            },
            layout: function() {
                var that = this,
                    width,
                    deferred = $.Deferred();

                // reset widths [for changing breakpoints and reclaculating columns]
                that.items.add(that.itemWrapper).width('');

                if (this.opts.resizeItems) { // used if the itemWidth isn't set via CSS
                    this.items.width(this.ele.width()).css({
                        'float': 'left'
                    });
                }
                if (this.opts.itemsPerScreen && this.opts.itemsPerScreen === 1) {
                    this.items.width(this.ele.width()).css({
                        margin: '0 auto'
                    });
                }
                width = this.items.outerWidth(true);
                this.totalWidth = Math.ceil(width * this.total);
                this.itemWrapper.width(this.totalWidth);

                // calc total screens
                (function(t) {
                    var w = that.ele.width(),
                        overallWidth = (w + (parseInt(that.items.css('paddingLeft'), 10)) * 2);
                    var diff = overallWidth - width;
                    if (diff < 5 && diff > -5) { // Discarding the delta of + - 5 pixels
                        overallWidth = width;
                    }
                    var s = that.total / Math.floor(overallWidth / width);

                    that.screens = isFinite(s) ? s : 1;
                    that.itemWidth = width;
                    that.itemsPerScreen = Math.floor(overallWidth / width);
                    // CHANGE : by Lalit, to simplify the carsouel items per screen using a different parameter
                    // As the that.screens in case of mobile always becomes infinity due to width mismatch by 1 px
                    if (that.opts.itemsPerScreen) {
                        that.screens = that.items.length;
                        that.itemsPerScreen = that.opts.itemsPerScreen;
                    }
                })(this);

                this.buildPaging();
                return deferred.resolve().promise();
            },
            buildPaging: function() {
                var html = [],
                    i = 1;
                for (i; i <= this.screens; i++) {
                    html.push('<li><a href="#" data-index="' + (i - 1) + '"><span>' + i + '</span></a></li>');
                }
                this.pagingWrapper.html(html.join(''));
                this.setActive();
            },
            preMove: function() {
                var moveAmount = this.itemsPerScreen * this.itemWidth * this.index,
                    that = this;

                this[this.css3 ? 'animateWebkit' : 'animate'](moveAmount).done(function() {
                    that.animateEnd();
                });
            },
            animate: function(moveAmount) {
                var deferred = $.Deferred();
                this.itemWrapper.animate({
                    left: -moveAmount
                }, this.opts.speed, function() {
                    deferred.resolve();
                });
                return deferred.promise();
            },
            animateWebkit: function(moveAmount) {
                var deferred = $.Deferred();

                function _end() {
                    this.style.webkitTransition = '';
                    deferred.resolve();
                }

                this.itemWrapper.one('webkitTransitionEnd', _end);

                this.itemWrapper[0].style.webkitTransition = '-webkit-transform ' + this.opts.speed + 'ms ease';
                this.itemWrapper[0].style.webkitTransform = 'translate3d(-' + moveAmount + 'px,0,0)';

                return deferred.promise();
            },
            animateEnd: function() {
                this.setActive();
            },
            goTo: function(n) {
                // if( this.index === n ){ return n; }
                this.index = this.getIndex(n);
                this.preMove();
            },
            next: function() {
                $(document).trigger('responsiveCarouselNext', [$(this.items[this.index]), this.index]);
                this.getIndex(++this.index);
                this.preMove();
            },
            prev: function() {
                $(document).trigger('responsiveCarouselPrevious', [$(this.items[this.index]), this.index]);
                this.getIndex(--this.index);
                this.preMove();
            },
            getIndex: function(n) {
                var i = this.index;
                if (n < 0) {
                    i = 0;
                } else if (i >= this.screens) {
                    i = this.screens - 1;
                } else {
                    i = n;
                }
                this.index = i;
                return this.index;
            },
            setActive: function() {
                this.pagingWrapper.find('li')
                    .filter('.active')
                    .removeClass('active')
                    .end()
                    .eq(this.index).addClass('active');

                this.setBtnStates();
            },
            setBtnStates: function() {
                var total = this.total - 1;

                this.btnPrev[this.index > 0 ? 'removeClass' : 'addClass']('disabled');
                this.btnNext[this.index === total ? 'addClass' : 'removeClass']('disabled');
            }
        };

        for (var key in methods) {
            ResponsiveCarousel.prototype[key] = methods[key];
        }

        $.fn.responsiveCarousel = function(opts) {
            return this.each(function() {
                var $t = $(this);
                $t.data({
                    responsiveCarousel: new ResponsiveCarousel($t, opts)
                });
            });
        };

        return ResponsiveCarousel;
    });
/*
 * jQuery Mobile Framework v1.2.0
 * http://jquerymobile.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

(function(root, doc, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define('jquerymobile', ["jquery"], function($) {
            factory($, root, doc);
            return $.mobile;
        });
    } else {
        // Browser globals
        factory(root.jQuery, root, doc);
    }
}(this, document, function(jQuery, window, document, undefined) {
    (function($, undefined) {
        var support = {
            touch: "ontouchend" in document
        };

        $.mobile = $.mobile || {};
        $.mobile.support = $.mobile.support || {};
        $.extend($.support, support);
        $.extend($.mobile.support, support);
    }(jQuery));


    // This plugin is an experiment for abstracting away the touch and mouse
    // events so that developers don't have to worry about which method of input
    // the device their document is loaded on supports.
    //
    // The idea here is to allow the developer to register listeners for the
    // basic mouse events, such as mousedown, mousemove, mouseup, and click,
    // and the plugin will take care of registering the correct listeners
    // behind the scenes to invoke the listener at the fastest possible time
    // for that device, while still retaining the order of event firing in
    // the traditional mouse environment, should multiple handlers be registered
    // on the same element for different events.
    //
    // The current version exposes the following virtual events to jQuery bind methods:
    // "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

    (function($, window, document, undefined) {

        var dataPropertyName = "virtualMouseBindings",
            touchTargetPropertyName = "virtualTouchID",
            virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "),
            touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "),
            mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [],
            mouseEventProps = $.event.props.concat(mouseHookProps),
            activeDocHandlers = {},
            resetTimerID = 0,
            startX = 0,
            startY = 0,
            didScroll = false,
            clickBlockList = [],
            blockMouseTriggers = false,
            blockTouchTriggers = false,
            eventCaptureSupported = "addEventListener" in document,
            $document = $(document),
            nextTouchID = 1,
            lastTouchID = 0,
            threshold;

        $.vmouse = {
            moveDistanceThreshold: 10,
            clickDistanceThreshold: 10,
            resetTimerDuration: 1500
        };

        function getNativeEvent(event) {

            while (event && typeof event.originalEvent !== "undefined") {
                event = event.originalEvent;
            }
            return event;
        }

        function createVirtualEvent(event, eventType) {

            var t = event.type,
                oe, props, ne, prop, ct, touch, i, j, len;

            event = $.Event(event);
            event.type = eventType;

            oe = event.originalEvent;
            props = $.event.props;

            // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
            // https://github.com/jquery/jquery-mobile/issues/3280
            if (t.search(/^(mouse|click)/) > -1) {
                props = mouseEventProps;
            }

            // copy original event properties over to the new event
            // this would happen if we could call $.event.fix instead of $.Event
            // but we don't have a way to force an event to be fixed multiple times
            if (oe) {
                for (i = props.length, prop; i;) {
                    prop = props[--i];
                    event[prop] = oe[prop];
                }
            }

            // make sure that if the mouse and click virtual events are generated
            // without a .which one is defined
            if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
                event.which = 1;
            }

            if (t.search(/^touch/) !== -1) {
                ne = getNativeEvent(oe);
                t = ne.touches;
                ct = ne.changedTouches;
                touch = (t && t.length) ? t[0] : ((ct && ct.length) ? ct[0] : undefined);

                if (touch) {
                    for (j = 0, len = touchEventProps.length; j < len; j++) {
                        prop = touchEventProps[j];
                        event[prop] = touch[prop];
                    }
                }
            }

            return event;
        }

        function getVirtualBindingFlags(element) {

            var flags = {},
                b, k;

            while (element) {

                b = $.data(element, dataPropertyName);

                for (k in b) {
                    if (b[k]) {
                        flags[k] = flags.hasVirtualBinding = true;
                    }
                }
                element = element.parentNode;
            }
            return flags;
        }

        function getClosestElementWithVirtualBinding(element, eventType) {
            var b;
            while (element) {

                b = $.data(element, dataPropertyName);

                if (b && (!eventType || b[eventType])) {
                    return element;
                }
                element = element.parentNode;
            }
            return null;
        }

        function enableTouchBindings() {
            blockTouchTriggers = false;
        }

        function disableTouchBindings() {
            blockTouchTriggers = true;
        }

        function enableMouseBindings() {
            lastTouchID = 0;
            clickBlockList.length = 0;
            blockMouseTriggers = false;

            // When mouse bindings are enabled, our
            // touch bindings are disabled.
            disableTouchBindings();
        }

        function disableMouseBindings() {
            // When mouse bindings are disabled, our
            // touch bindings are enabled.
            enableTouchBindings();
        }

        function startResetTimer() {
            clearResetTimer();
            resetTimerID = setTimeout(function() {
                resetTimerID = 0;
                enableMouseBindings();
            }, $.vmouse.resetTimerDuration);
        }

        function clearResetTimer() {
            if (resetTimerID) {
                clearTimeout(resetTimerID);
                resetTimerID = 0;
            }
        }

        function triggerVirtualEvent(eventType, event, flags) {
            var ve;

            if ((flags && flags[eventType]) ||
                (!flags && getClosestElementWithVirtualBinding(event.target, eventType))) {

                ve = createVirtualEvent(event, eventType);

                $(event.target).trigger(ve);
            }

            return ve;
        }

        function mouseEventCallback(event) {
            var touchID = $.data(event.target, touchTargetPropertyName);

            if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
                var ve = triggerVirtualEvent("v" + event.type, event);
                if (ve) {
                    if (ve.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                    if (ve.isPropagationStopped()) {
                        event.stopPropagation();
                    }
                    if (ve.isImmediatePropagationStopped()) {
                        event.stopImmediatePropagation();
                    }
                }
            }
        }

        function handleTouchStart(event) {

            var touches = getNativeEvent(event).touches,
                target, flags;

            if (touches && touches.length === 1) {

                target = event.target;
                flags = getVirtualBindingFlags(target);

                if (flags.hasVirtualBinding) {

                    lastTouchID = nextTouchID++;
                    $.data(target, touchTargetPropertyName, lastTouchID);

                    clearResetTimer();

                    disableMouseBindings();
                    didScroll = false;

                    var t = getNativeEvent(event).touches[0];
                    startX = t.pageX;
                    startY = t.pageY;

                    triggerVirtualEvent("vmouseover", event, flags);
                    triggerVirtualEvent("vmousedown", event, flags);
                }
            }
        }

        function handleScroll(event) {
            if (blockTouchTriggers) {
                return;
            }

            if (!didScroll) {
                triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
            }

            didScroll = true;
            startResetTimer();
        }

        function handleTouchMove(event) {
            if (blockTouchTriggers) {
                return;
            }

            var t = getNativeEvent(event).touches[0],
                didCancel = didScroll,
                moveThreshold = $.vmouse.moveDistanceThreshold,
                flags = getVirtualBindingFlags(event.target);

            didScroll = didScroll ||
                (Math.abs(t.pageX - startX) > moveThreshold ||
                    Math.abs(t.pageY - startY) > moveThreshold);


            if (didScroll && !didCancel) {
                triggerVirtualEvent("vmousecancel", event, flags);
            }

            triggerVirtualEvent("vmousemove", event, flags);
            startResetTimer();
        }

        function handleTouchEnd(event) {
            if (blockTouchTriggers) {
                return;
            }

            disableTouchBindings();

            var flags = getVirtualBindingFlags(event.target),
                t;
            triggerVirtualEvent("vmouseup", event, flags);

            if (!didScroll) {
                var ve = triggerVirtualEvent("vclick", event, flags);
                if (ve && ve.isDefaultPrevented()) {
                    // The target of the mouse events that follow the touchend
                    // event don't necessarily match the target used during the
                    // touch. This means we need to rely on coordinates for blocking
                    // any click that is generated.
                    t = getNativeEvent(event).changedTouches[0];
                    clickBlockList.push({
                        touchID: lastTouchID,
                        x: t.clientX,
                        y: t.clientY
                    });

                    // Prevent any mouse events that follow from triggering
                    // virtual event notifications.
                    blockMouseTriggers = true;
                }
            }
            triggerVirtualEvent("vmouseout", event, flags);
            didScroll = false;

            startResetTimer();
        }

        function hasVirtualBindings(ele) {
            var bindings = $.data(ele, dataPropertyName),
                k;

            if (bindings) {
                for (k in bindings) {
                    if (bindings[k]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function dummyMouseHandler() {}

        function getSpecialEventObject(eventType) {
            var realType = eventType.substr(1);

            return {
                setup: function(data, namespace) {
                    // If this is the first virtual mouse binding for this element,
                    // add a bindings object to its data.

                    if (!hasVirtualBindings(this)) {
                        $.data(this, dataPropertyName, {});
                    }

                    // If setup is called, we know it is the first binding for this
                    // eventType, so initialize the count for the eventType to zero.
                    var bindings = $.data(this, dataPropertyName);
                    bindings[eventType] = true;

                    // If this is the first virtual mouse event for this type,
                    // register a global handler on the document.

                    activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

                    if (activeDocHandlers[eventType] === 1) {
                        $document.bind(realType, mouseEventCallback);
                    }

                    // Some browsers, like Opera Mini, won't dispatch mouse/click events
                    // for elements unless they actually have handlers registered on them.
                    // To get around this, we register dummy handlers on the elements.

                    $(this).bind(realType, dummyMouseHandler);

                    // For now, if event capture is not supported, we rely on mouse handlers.
                    if (eventCaptureSupported) {
                        // If this is the first virtual mouse binding for the document,
                        // register our touchstart handler on the document.

                        activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;

                        if (activeDocHandlers["touchstart"] === 1) {
                            $document.bind("touchstart", handleTouchStart)
                                .bind("touchend", handleTouchEnd)

                            // On touch platforms, touching the screen and then dragging your finger
                            // causes the window content to scroll after some distance threshold is
                            // exceeded. On these platforms, a scroll prevents a click event from being
                            // dispatched, and on some platforms, even the touchend is suppressed. To
                            // mimic the suppression of the click event, we need to watch for a scroll
                            // event. Unfortunately, some platforms like iOS don't dispatch scroll
                            // events until *AFTER* the user lifts their finger (touchend). This means
                            // we need to watch both scroll and touchmove events to figure out whether
                            // or not a scroll happenens before the touchend event is fired.

                            .bind("touchmove", handleTouchMove)
                                .bind("scroll", handleScroll);
                        }
                    }
                },

                teardown: function(data, namespace) {
                    // If this is the last virtual binding for this eventType,
                    // remove its global handler from the document.

                    --activeDocHandlers[eventType];

                    if (!activeDocHandlers[eventType]) {
                        $document.unbind(realType, mouseEventCallback);
                    }

                    if (eventCaptureSupported) {
                        // If this is the last virtual mouse binding in existence,
                        // remove our document touchstart listener.

                        --activeDocHandlers["touchstart"];

                        if (!activeDocHandlers["touchstart"]) {
                            $document.unbind("touchstart", handleTouchStart)
                                .unbind("touchmove", handleTouchMove)
                                .unbind("touchend", handleTouchEnd)
                                .unbind("scroll", handleScroll);
                        }
                    }

                    var $this = $(this),
                        bindings = $.data(this, dataPropertyName);

                    // teardown may be called when an element was
                    // removed from the DOM. If this is the case,
                    // jQuery core may have already stripped the element
                    // of any data bindings so we need to check it before
                    // using it.
                    if (bindings) {
                        bindings[eventType] = false;
                    }

                    // Unregister the dummy event handler.

                    $this.unbind(realType, dummyMouseHandler);

                    // If this is the last virtual mouse binding on the
                    // element, remove the binding data from the element.

                    if (!hasVirtualBindings(this)) {
                        $this.removeData(dataPropertyName);
                    }
                }
            };
        }

        // Expose our custom events to the jQuery bind/unbind mechanism.

        for (var i = 0; i < virtualEventNames.length; i++) {
            $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
        }

        // Add a capture click handler to block clicks.
        // Note that we require event capture support for this so if the device
        // doesn't support it, we punt for now and rely solely on mouse events.
        if (eventCaptureSupported) {
            document.addEventListener("click", function(e) {
                var cnt = clickBlockList.length,
                    target = e.target,
                    x, y, ele, i, o, touchID;

                if (cnt) {
                    x = e.clientX;
                    y = e.clientY;
                    threshold = $.vmouse.clickDistanceThreshold;

                    // The idea here is to run through the clickBlockList to see if
                    // the current click event is in the proximity of one of our
                    // vclick events that had preventDefault() called on it. If we find
                    // one, then we block the click.
                    //
                    // Why do we have to rely on proximity?
                    //
                    // Because the target of the touch event that triggered the vclick
                    // can be different from the target of the click event synthesized
                    // by the browser. The target of a mouse/click event that is syntehsized
                    // from a touch event seems to be implementation specific. For example,
                    // some browsers will fire mouse/click events for a link that is near
                    // a touch event, even though the target of the touchstart/touchend event
                    // says the user touched outside the link. Also, it seems that with most
                    // browsers, the target of the mouse/click event is not calculated until the
                    // time it is dispatched, so if you replace an element that you touched
                    // with another element, the target of the mouse/click will be the new
                    // element underneath that point.
                    //
                    // Aside from proximity, we also check to see if the target and any
                    // of its ancestors were the ones that blocked a click. This is necessary
                    // because of the strange mouse/click target calculation done in the
                    // Android 2.1 browser, where if you click on an element, and there is a
                    // mouse/click handler on one of its ancestors, the target will be the
                    // innermost child of the touched element, even if that child is no where
                    // near the point of touch.

                    ele = target;

                    while (ele) {
                        for (i = 0; i < cnt; i++) {
                            o = clickBlockList[i];
                            touchID = 0;

                            if ((ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold) ||
                                $.data(ele, touchTargetPropertyName) === o.touchID) {
                                // XXX: We may want to consider removing matches from the block list
                                //      instead of waiting for the reset timer to fire.
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                        }
                        ele = ele.parentNode;
                    }
                }
            }, true);
        }
    })(jQuery, window, document);


    (function($, window, undefined) {
        // add new event shortcuts
        $.each(("touchstart touchmove touchend " +
            "tap taphold " +
            "swipe swipeleft swiperight " +
            "scrollstart scrollstop").split(" "), function(i, name) {

            $.fn[name] = function(fn) {
                return fn ? this.bind(name, fn) : this.trigger(name);
            };

            // jQuery < 1.8
            if ($.attrFn) {
                $.attrFn[name] = true;
            }
        });

        var supportTouch = $.mobile.support.touch,
            scrollEvent = "touchmove scroll",
            touchStartEvent = supportTouch ? "touchstart" : "mousedown",
            touchStopEvent = supportTouch ? "touchend" : "mouseup",
            touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

        function triggerCustomEvent(obj, eventType, event) {
            var originalType = event.type;
            event.type = eventType;
            $.event.handle.call(obj, event);
            event.type = originalType;
        }

        // also handles scrollstop
        $.event.special.scrollstart = {

            enabled: true,

            setup: function() {

                var thisObject = this,
                    $this = $(thisObject),
                    scrolling,
                    timer;

                function trigger(event, state) {
                    scrolling = state;
                    triggerCustomEvent(thisObject, scrolling ? "scrollstart" : "scrollstop", event);
                }

                // iPhone triggers scroll after a small delay; use touchmove instead
                $this.bind(scrollEvent, function(event) {

                    if (!$.event.special.scrollstart.enabled) {
                        return;
                    }

                    if (!scrolling) {
                        trigger(event, true);
                    }

                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        trigger(event, false);
                    }, 50);
                });
            }
        };

        // also handles taphold
        $.event.special.tap = {
            tapholdThreshold: 750,

            setup: function() {
                var thisObject = this,
                    $this = $(thisObject);

                $this.bind("vmousedown", function(event) {

                    if (event.which && event.which !== 1) {
                        return false;
                    }

                    var origTarget = event.target,
                        origEvent = event.originalEvent,
                        timer;

                    function clearTapTimer() {
                        clearTimeout(timer);
                    }

                    function clearTapHandlers() {
                        clearTapTimer();

                        $this.unbind("vclick", clickHandler)
                            .unbind("vmouseup", clearTapTimer);
                        $(document).unbind("vmousecancel", clearTapHandlers);
                    }

                    function clickHandler(event) {
                        clearTapHandlers();

                        // ONLY trigger a 'tap' event if the start target is
                        // the same as the stop target.
                        if (origTarget === event.target) {
                            triggerCustomEvent(thisObject, "tap", event);
                        }
                    }

                    $this.bind("vmouseup", clearTapTimer)
                        .bind("vclick", clickHandler);
                    $(document).bind("vmousecancel", clearTapHandlers);

                    timer = setTimeout(function() {
                        triggerCustomEvent(thisObject, "taphold", $.Event("taphold", {
                            target: origTarget
                        }));
                    }, $.event.special.tap.tapholdThreshold);
                });
            }
        };

        // also handles swipeleft, swiperight
        $.event.special.swipe = {
            scrollSupressionThreshold: 30, // More than this horizontal displacement, and we will suppress scrolling.

            durationThreshold: 1000, // More time than this, and it isn't a swipe.

            horizontalDistanceThreshold: 30, // Swipe horizontal displacement must be more than this.

            verticalDistanceThreshold: 75, // Swipe vertical displacement must be less than this.

            setup: function() {
                var thisObject = this,
                    $this = $(thisObject);

                $this.bind(touchStartEvent, function(event) {
                    var data = event.originalEvent.touches ?
                        event.originalEvent.touches[0] : event,
                        start = {
                            time: (new Date()).getTime(),
                            coords: [data.pageX, data.pageY],
                            origin: $(event.target)
                        },
                        stop;

                    function moveHandler(event) {

                        if (!start) {
                            return;
                        }

                        var data = event.originalEvent.touches ?
                            event.originalEvent.touches[0] : event;

                        stop = {
                            time: (new Date()).getTime(),
                            coords: [data.pageX, data.pageY]
                        };

                        // prevent scrolling
                        if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.scrollSupressionThreshold) {
                            event.preventDefault();
                        }
                    }

                    $this.bind(touchMoveEvent, moveHandler)
                        .one(touchStopEvent, function(event) {
                            $this.unbind(touchMoveEvent, moveHandler);

                            if (start && stop) {
                                if (stop.time - start.time < $.event.special.swipe.durationThreshold &&
                                    Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.horizontalDistanceThreshold &&
                                    Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.swipe.verticalDistanceThreshold) {

                                    start.origin.trigger("swipe")
                                        .trigger(start.coords[0] > stop.coords[0] ? "swipeleft" : "swiperight");
                                }
                            }
                            start = stop = undefined;
                        });
                });
            }
        };
        $.each({
            scrollstop: "scrollstart",
            taphold: "tap",
            swipeleft: "swipe",
            swiperight: "swipe"
        }, function(event, sourceEvent) {

            $.event.special[event] = {
                setup: function() {
                    $(this).bind(sourceEvent, $.noop);
                }
            };
        });

    })(jQuery, this);

}));

/* global document */
define('search-results/results-v3', [
    'base',
    './range-slider',
    './star-slider',
    'common/responsive-carousel',
    'search-panel/search-panel-v3',
    'common/tabs',
    'jquerymobile'
], function(base, RangeSlider, StarSlider, ResponsiveCarousel, SearchPanel, Tabs, jquerymobile) {

    function Results(ele, opts) {
        this.ele = ele;
        this.opts = $.extend({}, {
            searchPanel: false
        }, opts);
        this.carousels = [];
        this.init();
    }

    var methods = {
        init: function() {
            this.searchPanel = this.opts.searchPanel || new SearchPanel($('#searchPanel'));
        }
    };

    for (var key in methods) {
        Results.prototype[key] = methods[key];
    }

    return Results;
});

var epifind = epifind || {};
epifind.nordics = epifind.nordics || {};
epifind.nordics.texts = epifind.nordics.texts || (function() {
    var gradeLetter = '',
        countryTitle = '',
        destinationTitle = '',
        hotelTitle = '',
        excursionTitle = '',
        contentTitle = '',
        hostName = 'www.fritidsresor.se';

    return {
        gradeLetter: gradeLetter,
        countryTitle: countryTitle,
        destinationTitle: destinationTitle,
        hotelTitle: hotelTitle,
        excursionTitle: excursionTitle,
        contentTitle: contentTitle,
        hostName: hostName
    };
})();

(function() {
    epifind.nordics.texts.gradeLetter = $('.finder-app').data('grade-letter');
    epifind.nordics.texts.countryTitle = $('.finder-app').data('country-title');
    epifind.nordics.texts.destinationTitle = $('.finder-app').data('destination-title');
    epifind.nordics.texts.hotelTitle = $('.finder-app').data('hotel-title');
    epifind.nordics.texts.excursionTitle = $('.finder-app').data('excursion-title');
    epifind.nordics.texts.contentTitle = $('.finder-app').data('content-title');
    if ($('.finder-app').data('host-name')) {
        epifind.nordics.texts.hostName = $('.finder-app').data('host-name');
    } else {
        epifind.nordics.texts.hostName = location.host;
    }
})();

epifind.nordics.app = (function() {
    var sectionTitleTemplate = '<h2 class="section-title">{sectionTitle}</h2>',
        itemTemplate = '<a class="finder-item clearfix" href="{href}">' +
        '{imgTemplate}' +
        '<h3 class="h5 item-title">{itemTitle}</h3>' +
        '<p class="item-text">{itemText}</p>' +
        '</a>',
        imgTemplate = '<img src="{imgSrc}" class="object" />',
        serviceUrl = 'http://' + epifind.nordics.texts.hostName + '/Pages/EpiserverFind.aspx?callback=?&entry={searchText}&pageNumber=1&pageSize=2&suggest=true&type={type}',
        $finderApp = $('.finder-app'),
        $finderSections = $finderApp.find('.finder-section'),
        countryRequest = null,
        destinationRequest = null,
        hotelRequest = null,
        exursionRequest = null,
        contentRequest = null,
        types = {
            country: 'country',
            destination: 'destination',
            hotel: 'hotel',
            excursion: 'excursion',
            content: 'content'
        },
        currentSearchedText = '';

    var logToConsole = function(logText) {
        try {
            console.log(logText);
        } catch (ex) {}
    };

    var pushToDataLayer = function() {
        try {
            var searchText = getSearchText(),
                hasDataLayer = (typeof(dataLayer) !== 'undefined') ? true : false;
            if (hasDataLayer) {
                dataLayer.push({
                    'eventCategory': 'Finder',
                    'eventAction': 'Search',
                    'eventLabel': searchText,
                    'event': 'finderTrackEvent'
                });
            }
            logToConsole('dataLayer: ' + hasDataLayer.toString() + '\neventCategory: Finder\neventAction: Search\neventLabel: ' + searchText);
        } catch (ex) {}
    };

    var getSearchText = function() {
        return $.trim($finderApp.find('.finder-text:first').val()).replace(/'/, '""').replace(/"/, '""');
    };

    var getServiceUrl = function(type) {
        var searchText = getSearchText();
        return serviceUrl.replace(/{searchText}/, searchText).replace(/{type}/, type);
    };

    var getCleanText = function(html) {
        return (html) ? html.replace(/<\/?([a-z][a-z0-9]*)\b[^>]*>/gi, '') : '';
    };

    var getSectionTitle = function(type) {
        if (type === types.country) {
            return epifind.nordics.texts.countryTitle;
        } else if (type === types.destination) {
            return epifind.nordics.texts.destinationTitle;
        } else if (type === types.hotel) {
            return epifind.nordics.texts.hotelTitle;
        } else if (type === types.excursion) {
            return epifind.nordics.texts.excursionTitle;
        } else if (type === types.content) {
            return epifind.nordics.texts.contentTitle;
        }
    };

    var getItemFromTemplate = function(href, imgSrc, itemTitle, itemText) {
        var imgElem = (imgSrc !== '') ? imgTemplate.replace(/{imgSrc}/, imgSrc) : '';
        return itemTemplate
            .replace(/{href}/, href)
            .replace(/{imgTemplate}/, imgElem)
            .replace(/{itemTitle}/, itemTitle)
            .replace(/{itemText}/, getCleanText(itemText));
    };

    var getHotelGrade = function(grade) {
        var gradeText = ' ',
            gradeLow = Math.floor(grade.replace(/,/gi, '.')),
            gradeHigh = Math.ceil(grade.replace(/,/gi, '.'));
        for (var i = 0; i < gradeLow; i++) {
            gradeText += epifind.nordics.texts.gradeLetter;
        }
        if (gradeHigh > gradeLow) {
            gradeText += '+';
        }
        return gradeText;
    };

    var getResultHref = function(type, list, index) {
        if (type === types.content) {
            return list[index].SearchHitUrl;
        }
        return list[index].page;
    };

    var getResultImgSrc = function(type, list, index) {
        if (type === types.content) {
            return '';
        }
        return (list[index].media) ? list[index].media.icon_picture : '';
    };

    var getResultItemTitle = function(type, list, index) {
        if (type === types.hotel) {
            return list[index].name + getHotelGrade(list[index].grade);
        } else if (type === types.excursion) {
            return list[index].usp;
        } else if (type === types.content) {
            return list[index].SearchTitle;
        }
        return list[index].name;
    };

    var getResultItemText = function(type, list, index) {
        if (type === types.hotel) {
            return list[index].info.usp;
        } else if (type === types.excursion) {
            return list[index].intro;
        } else if (type === types.content) {
            return list[index].Content;
        }
        return list[index].text;
    };

    var transformResult = function(type, list) {
        var sectionTitleHtml = sectionTitleTemplate.replace(/{sectionTitle}/, getSectionTitle(type)),
            sectionItemHtml = '';
        for (var index = 0; index < list.length; index++) {
            var href = getResultHref(type, list, index),
                imgSrc = getResultImgSrc(type, list, index),
                itemTitle = getResultItemTitle(type, list, index),
                itemText = getResultItemText(type, list, index);
            sectionItemHtml += getItemFromTemplate(href, imgSrc, itemTitle, itemText);
            if (index >= 1) {
                break;
            }
        }
        if (sectionItemHtml !== '') {
            $finderApp.find('#result-' + type).addClass('has-result').html(sectionTitleHtml + sectionItemHtml);
        }
        $finderApp.removeClass('finding');
    };

    var getJSONP = function(req, type) {
        req = $.ajax({
            dataType: 'json',
            url: getServiceUrl(type),
            beforeSend: function() {
                if (req !== null) {
                    req.abort();
                }
            },
            success: function(data) {
                req = null;
                var list = (function() {
                    if (data.country) {
                        return data.country;
                    } else if (data.destination) {
                        return data.destination;
                    } else if (data.hotel) {
                        return data.hotel;
                    } else if (data.excursion) {
                        return data.excursion;
                    } else if (data.faq) {
                        return data.faq;
                    }
                })();
                transformResult(type, list);
            }
        });
    };

    var makeSearch = function() {
        getJSONP(countryRequest, types.country);
        getJSONP(destinationRequest, types.destination);
        getJSONP(hotelRequest, types.hotel);
        getJSONP(exursionRequest, types.excursion);
        getJSONP(contentRequest, types.content);
        currentSearchedText = getSearchText();
        pushToDataLayer();
    };

    var initFindState = function() {
        $finderApp.addClass('finding');
        $finderSections.removeClass('has-result').html('');
    };

    var init = function() {
        $finderApp.find('.finder-text:first').val('');
        var promise = null;
        $finderApp.delegate('.finder-text:first', 'keyup', function() {
            if ((currentSearchedText !== getSearchText()) && (getSearchText() !== '')) {
                initFindState();
                clearTimeout(promise);
                promise = setTimeout(function() {
                    promise = null;
                    makeSearch();
                }, 500);
            }
        });

        $finderApp.on('click', function(event) {
            event.stopPropagation();
        });

        $finderApp.find('.icon-close').on('click', function() {
            $finderApp.parent().removeClass('open');
        });
    };

    return {
        init: init
    };
})();
epifind.nordics.app.init();

define("../nordics/epifind.nordics", function() {});

var tui = tui || {};
tui.commonUX = tui.commonUX || {};
if (!tui.commonUX.topnavigation) {
    tui.commonUX.topnavigation = (function() {
        'use strict';

        var init = function() {
            var $topNavigation = $('.top-navigation');

            $topNavigation.find('.icon-search').on('click', function() {
                if ($topNavigation.find('.menu-label').is(':visible') && $topNavigation.find('.main-navigation').is(':visible')) {
                    $topNavigation.find('#menu-button').trigger('click');
                }

                $(this).parents('.finder-container:first').toggleClass('open');
                $(this).next().find('.finder-text:first').trigger('focus');

                return false;
            });

            $('.dark-fade-top').on('click', function() {
                $('.top-navigation .finder-container:first').removeClass('open');
            });
        };

        return {
            init: init
        };
    })();

    tui.commonUX.topnavigation.init();
};
define("tui.topnavigation", function() {});

/*
 * Lazy Load - jQuery plugin for lazy loading images
 *
 * Copyright (c) 2007-2012 Mika Tuupola
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 *   http://www.appelsiini.net/projects/lazyload
 *
 * Version:  1.7.2
 *
 */
(function($, window) {

    $window = $(window);

    $.fn.lazyload = function(options) {
        var elements = this;
        var settings = {
            threshold: 0,
            failure_limit: 0,
            event: "scroll",
            effect: "show",
            container: window,
            data_attribute: "original",
            skip_invisible: true,
            appear: null,
            load: null,
            onerror: null,
            retry_after: 2000
        };

        function update() {
            var counter = 0;

            elements.each(function() {
                var $this = $(this);
                if (settings.skip_invisible && !$this.is(":visible")) {
                    return;
                }
                if ($.abovethetop(this, settings) ||
                    $.leftofbegin(this, settings)) {
                    /* Nothing. */
                } else if (!$.belowthefold(this, settings) &&
                    !$.rightoffold(this, settings)) {
                    $this.trigger("appear");
                } else {
                    if (++counter > settings.failure_limit) {
                        return false;
                    }
                }
            });

        }

        if (options) {
            /* Maintain BC for a couple of versions. */
            if (undefined !== options.failurelimit) {
                options.failure_limit = options.failurelimit;
                delete options.failurelimit;
            }
            if (undefined !== options.effectspeed) {
                options.effect_speed = options.effectspeed;
                delete options.effectspeed;
            }

            $.extend(settings, options);
        }

        /* Cache container as jQuery as object. */
        $container = (settings.container === undefined ||
            settings.container === window) ? $window : $(settings.container);

        /* Fire one scroll event per scroll. Not one scroll event per image. */
        if (0 === settings.event.indexOf("scroll")) {
            $container.bind(settings.event, function(event) {
                return update();
            });
        }

        this.each(function() {
            var self = this;
            var $self = $(self);

            self.loaded = false;

            /* When appear is triggered load original image. */
            $self.one("appear", function() {
                if (!this.loaded) {
                    if (settings.appear) {
                        var elements_left = elements.length;
                        settings.appear.call(self, elements_left, settings);
                    }
                    $("<img />")
                        .bind("load", function() {
                            $self
                                .hide()
                                .attr("src", $self.data(settings.data_attribute))[settings.effect](settings.effect_speed);
                            self.loaded = true;

                            /* Remove image from array so it is not looped next time. */
                            var temp = $.grep(elements, function(element) {
                                return !element.loaded;
                            });
                            elements = $(temp);

                            if (settings.load) {
                                var elements_left = elements.length;
                                settings.load.call(self, elements_left, settings);
                            }
                        })
                        .error(function() { //SAPIENT Change , adding onerror callback
                            //alert('error');
                            setTimeout(function() {
                                $self.error(function() {
                                    setTimeout(function() {
                                        if (settings.onerror != null) {
                                            settings.onerror($self, settings);
                                        }
                                    }, settings.retry_after);
                                });
                                if (settings.onerror != null) {
                                    settings.onerror($self, settings);
                                }
                            }, settings.retry_after);
                        })
                        .attr("src", $self.data(settings.data_attribute));

                }
            });

            /* When wanted event is triggered load original image */
            /* by triggering appear.                              */
            if (0 !== settings.event.indexOf("scroll")) {
                $self.bind(settings.event, function(event) {
                    if (!self.loaded) {
                        $self.trigger("appear");
                    }
                });
            }
        });

        /* Check if something appears when window is resized. */
        $window.bind("resize", function(event) {
            update();
        });

        /* Force initial check if images should appear. */
        update();

        return this;
    };

    /* Convenience methods in jQuery namespace.           */
    /* Use as  $.belowthefold(element, {threshold : 100, container : window}) */

    $.belowthefold = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.height() + $window.scrollTop();
        } else {
            fold = $container.offset().top + $container.height();
        }

        return fold <= $(element).offset().top - settings.threshold;
    };

    $.rightoffold = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.width() + $window.scrollLeft();
        } else {
            fold = $container.offset().left + $container.width();
        }

        return fold <= $(element).offset().left - settings.threshold;
    };

    $.abovethetop = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.scrollTop();
        } else {
            fold = $container.offset().top;
        }

        return fold >= $(element).offset().top + settings.threshold + $(element).height();
    };

    $.leftofbegin = function(element, settings) {
        var fold;

        if (settings.container === undefined || settings.container === window) {
            fold = $window.scrollLeft();
        } else {
            fold = $container.offset().left;
        }

        return fold >= $(element).offset().left + settings.threshold + $(element).width();
    };

    $.inviewport = function(element, settings) {
        return !$.rightofscreen(element, settings) && !$.leftofscreen(element, settings) &&
            !$.belowthefold(element, settings) && !$.abovethetop(element, settings);
    };

    /* Custom selectors for your convenience.   */
    /* Use as $("img:below-the-fold").something() */

    $.extend($.expr[':'], {
        "below-the-fold": function(a) {
            return $.belowthefold(a, {
                threshold: 0,
                container: window
            });
        },
        "above-the-top": function(a) {
            return !$.belowthefold(a, {
                threshold: 0,
                container: window
            });
        },
        "right-of-screen": function(a) {
            return $.rightoffold(a, {
                threshold: 0,
                container: window
            });
        },
        "left-of-screen": function(a) {
            return !$.rightoffold(a, {
                threshold: 0,
                container: window
            });
        },
        "in-viewport": function(a) {
            return !$.inviewport(a, {
                threshold: 0,
                container: window
            });
        },
        /* Maintain BC for couple of versions. */
        "above-the-fold": function(a) {
            return !$.belowthefold(a, {
                threshold: 0,
                container: window
            });
        },
        "right-of-fold": function(a) {
            return $.rightoffold(a, {
                threshold: 0,
                container: window
            });
        },
        "left-of-fold": function(a) {
            return !$.rightoffold(a, {
                threshold: 0,
                container: window
            });
        }
    });

})(jQuery, window);

define("lazyLoad", ["jquery"], function() {});

/*jslint vars: true, white: true, nomen: true, sloppy: true, evil: true, forin: true */

/*!
 * tui.tweaks.js
 * This file contains code for modules on home & landing pages.
 *
 * @project   TUI WebCOE
 * @date      2014-01-14
 * @licensor  TUI
 * @site      Fritidsresor
 *
 */

//  define([
//      'lazyLoad'
//  ], function(){


window.tui = (function(tui, window, document, $, undefined) {

    'use strict';

    var me = tui.tweaks = tui.tweaks || {},

        // myScroll,
        snapWidth,


        //  private methods
        customSelect,
        resetSelectBoxes,
        setFilter;

    var imageSelector = '.excursion-card-image';
    var pictureWrapperSelector = '.destinationcard-picture';
    var fallBackImgElem = $('[data-fallbackhotelimage]');
    var fallBackImgUrl = '';
    if (fallBackImgElem.length) {
        fallBackImgUrl = fallBackImgElem.data('fallbackhotelimage');
    }


    /**
     * init
     */
    me.init = function() {
        //  retrieve assets path
        me.myScroll = [];

        if (!($('html').hasClass('ie8') || $('html').hasClass('ie9'))) {
            $(window).one('resize', me.initSwipe);
            $(window).one('resize', setFilter);
        }
        $(document).on('pageshow', resetSelectBoxes);
        customSelect();
        setFilter();
        // me.lazyLoadPicture();
        me.initSwipe($('body'));

    };



    /**
     * detect if the requesting device is mobile device
     */
    me.detectmob = function() {
        var windowWidth = $(window).width(),
            windowHeight = $(window).height();
        if (windowWidth < 768) {
            return true;
        } else {
            return false;
        }
    };

    /**
     * detect if the requesting device is tablet device
     */
    me.detecttab = function() {
        var windowWidth = $(window).width(),
            windowHeight = $(window).height();
        if (windowWidth >= 768 && windowWidth <= 1023) {
            return true;
        } else {
            return false;
        }
    };

    /**
     * detect if the requesting device is tablet device for hotel cards
     */
    me.detecttabHotel = function() {
        var windowWidth = $(window).width(),
            windowHeight = $(window).height();
        if (windowWidth >= 768 && windowWidth <= 1024) {
            return true;
        } else {
            return false;
        }
    };



    /**
     * slot c swipe functionality
     */
    me.initSwipe = function($swipeContainer) {
        $(window).unbind('resize', me.initSwipe);
        var $container = $swipeContainer && $swipeContainer.type !== 'resize' ? $swipeContainer : $('body');
        if ($('.hotelcardTab-section:visible').length > 1) {
            $container.find('.hotelcardTab-section:gt(0)').hide(); //  Hide hotel card tabs before initswipe
        }
        $container.find('.carousel-holder:visible').each(function() {
            var $carouselItem = $(this).find('.carousel-scroll'),
                curID = $(this).attr('id'),
                $carouselListItem = $carouselItem.find('>ul>li'),
                $carouselListFigureFirst = $carouselListItem.eq(0),
                viewportWidth = $(this).width(),
                itemWidth = $carouselListItem.width(),
                itemMargin = parseInt($carouselListFigureFirst.css('margin-right'), 10),
                paddingWidth = $carouselListFigureFirst.parents('.blue-panel').length ? parseInt($carouselListFigureFirst.parents('.blue-panel').css('padding-right'), 10) : 15;
            snapWidth = Math.floor((viewportWidth / itemWidth)) * (itemWidth + itemMargin);

            if (snapWidth < 1) {
                snapWidth = itemWidth + itemMargin;
            }

            // alert($carouselListFigureFirst.width());
            if (tui.tweaks.detectmob() || (tui.tweaks.detecttab() && $(this).parents('.destination-list').length <= 0) && (tui.tweaks.detecttab() && $(this).parents('.hotelcards-wrapper').length)) { // not for slot b in tablet
                $carouselItem.width($carouselListItem.length * ($carouselListFigureFirst.width() + parseInt($carouselListFigureFirst.css('margin-right'), 10)));
            } else {
                $carouselItem.width('');

            }
            if ($(this).parents('.experience-module').length > 0) {
                $carouselItem.width((Math.ceil($carouselListItem.length / 2) * ($carouselListFigureFirst.width() + parseInt($carouselListFigureFirst.css('margin-right'), 10))));
                // if(!tui.tweaks.detectmob()){
                // snapWidth = Math.floor((viewportWidth/itemWidth))*(itemWidth+itemMargin);
                // }
            }
            if (tui.tweaks.detectmob() && $(this).parents('.destination-list').length > 0) { //  added to generate dynamic height for slot b in mobile
                me.setEqualHeights($carouselListItem);

            }
            // $('.carousel-scroll > ul').width($carouselListItem.length*($carouselListFigureFirst.width()+parseInt($carouselListFigureFirst.css('margin-right')))-parseInt($carouselListFigureFirst.parents('.blue-panel').css('padding-right'))+1);

            if (IScroll && $carouselListItem.length > 1) {
                if (me.myScroll[curID]) {
                    me.myScroll[curID].destroy();
                }
                me.myScroll[curID] = new IScroll('#' + curID, {
                    scrollX: true,
                    scrollY: false,
                    scrollbars: false,
                    eventPassthrough: 'vertical',
                    momentum: false,
                    snap: true,
                    snapThreshold: 0,
                    keyBindings: false,
                    bounce: true,
                    mouseWheel: false,
                    snapStepX: snapWidth
                });
                if ($(this).hasClass('has-navigation')) {
                    var navHTML,
                        numberOfIndicators = Math.ceil($carouselItem.width() / snapWidth);
                    if (numberOfIndicators > 1) {
                        navHTML = '<div class="bs-carousel-navigation">' +
                            '<span class="prev" ></span>' +
                            '<ul class="bs-carousel-indicators">' +
                            '<li class="bs-carousel-indicator bs-carousel-active"><span></span></li>';
                        for (var i = 0; i < numberOfIndicators - 1; i++) {
                            navHTML = navHTML + '<li class="bs-carousel-indicator bs-carousel-inactive"><span></span></li>';

                        }
                        navHTML = navHTML + '</ul>' +
                            '<span class="next"></span>' +
                            '</div>';
                        $(this).find('.bs-carousel-navigation').remove().end().append(navHTML);
                        me.myScroll[curID].on('scrollEnd', function() {

                            $('#' + curID + ' .bs-carousel-indicator.bs-carousel-active').removeClass('bs-carousel-active').addClass('bs-carousel-inactive');
                            $('#' + curID + ' .bs-carousel-indicator').eq(this.currentPage.pageX).removeClass('bs-carousel-inactive').addClass('bs-carousel-active');
                        });
                        $('#' + curID + ' .prev').off('click').on('click', function() {

                            tui.tweaks.myScroll[curID].prev(); // goToPage(tui.tweaks.myScroll[curID].currentPage.pageX-1,0);

                        });
                        $('#' + curID + ' .next').off('click').on('click', function() {

                            tui.tweaks.myScroll[curID].next(); // goToPage(tui.tweaks.myScroll[curID].currentPage.pageX+1,0);

                        });
                    }
                }



            }
            /*else {
                     me.myScroll = new iScroll('wrapper');
                 }*/

        });
        $('.carousel-holder .bs-carousel-indicator').off('click').on('click', function() {
            var curCarousel = $(this).closest('.carousel-holder'),
                newIndex = curCarousel.find('.bs-carousel-indicator').index($(this)),
                carouselID = curCarousel.attr('id');
            me.myScroll[carouselID].goToPage(newIndex, 0);

        });
        if (!($('html').hasClass('ie8') || $('html').hasClass('ie9'))) {
            $(window).one('resize', me.initSwipe);
        }


    };


    me.lazyLoadPicture = function(breakPoint, $curParent, accepIndexes) {
        if (typeof breakPoint === 'undefined') {
            return;
        }
        var $parent = ($curParent && $curParent.length) ? $curParent : $('body');
        $parent.find('img.lazyload-img').each(function(indx) {

            if (accepIndexes && indx >= accepIndexes) {
                return;
            }

            var _that = $(this);
            //  if(!tuiConfig){
            //  	tuiConfig = {};
            //  }
            //  if(!tuiConfig.resizer){
            //  	return;
            //  }
            var screenBreakPoint = breakPoint;
            // if(_that.data('large')){
            var dataXSmall = _that.data('x-small') ? _that.data('x-small') : '',
                dataSmall = _that.data('small') ? _that.data('small') : '',
                dataMedium = _that.data('medium') ? _that.data('medium') : '',
                dataLarge = _that.data('large') ? _that.data('large') : '';
            if (screenBreakPoint === 'xs') {
                _that.data('original', dataXSmall || _that.data('original'));
                // if(_that.attr('src')==''){_that.attr('src',dataSmall);}
            } else if (screenBreakPoint === 'sm') {
                _that.data('original', dataSmall || _that.data('original'));
                // if(_that.attr('src')==''){_that.attr('src',dataSmall);}
            } else if (screenBreakPoint === 'md') {
                _that.data('original', dataMedium || _that.data('original'));
                // if(_that.attr('src')==''){_that.attr('src',dataSmall);}
            } else {
                _that.data('original', dataLarge || _that.data('original'));
                // if(_that.attr('src')==''){_that.attr('src',dataSmall);}
            }


            _that.lazyload({
                threshold: 1000,
                event: 'delayedLoad',
                effect: 'fadeIn',
                onerror: checkStatus,
                // container : _that.closest('.dest-content'),
                retry_after: 100
            });
            // }
        });

        function checkStatus(element, ele_length, settings) {
            if ($(element).is('img') && fallBackImgUrl) {
                $(element).attr('src', fallBackImgUrl);
            } else {
                $(element).hide().closest('figure').addClass('no-image');
            }

        }

        if ($parent === $('body')) {
            $(window).bind('load', function() {
                var timeout = setTimeout(function() {
                    $('img.lazyload-img').trigger('delayedLoad');
                }, 2000);
            });
        } else {
            var timeout = setTimeout(function() {
                $parent.find('img.lazyload-img').trigger('delayedLoad');
            }, 200);
        }
    };

    customSelect = function() {
        // resetSelectBoxes();
        $('.custom-select span').off().on('click', function(ev) {
            var curElem = $(this),
                targetUl = curElem.next('ul');

            if (targetUl.is(':visible')) {
                targetUl.hide();
            } else {
                $('.custom-select > span + ul').hide();
                targetUl.show();
            }

            ev.stopPropagation();
        });
        $('.custom-select ul').delegate('a', 'click', function(e) {
            e.preventDefault();
            if (!($(this).hasClass('selected'))) {
                var curElem = $(this);
                curElem.parents('.custom-select').find('span').eq(0).html(curElem.html());
                curElem.parents('.custom-select').find('ul').hide();
            }
        });
        if ($('.custom-select').length) {
            $(document).on('click', function() {
                $('.custom-select ul').hide();
            });
        }
    };

    /* reset select boxes on page load/browser back-forward button click to keep content & selected tabs in sync */
    resetSelectBoxes = function() {
        $('select').prop('selectedIndex', 0);
    };

    me.setEqualHeights = function($elements) {
        var heightArr = [],
            maxHeight;
        $elements.each(function() {
            heightArr.push($(this).height());
        });
        maxHeight = Math.max.apply(null, heightArr);
        $elements.height(maxHeight);
    };

    setFilter = function() {
        $(window).unbind('resize', setFilter);
        if (me.detectmob()) {
            $('a.filter-by').removeClass('close-filter').addClass('open-filter').parent().css({
                'height': '50px',
                'overflow': 'hidden'
            });
        } else {
            $('a.filter-by').parent().css({
                'height': 'auto',
                'overflow': 'visible'
            });
        }

        $('a.filter-by').click(function(evt) {
            var $that = $(this);
            evt.preventDefault();
            var filterHeight = $(this).next('div').height() + 70;
            if (me.detectmob() && $that.hasClass('open-filter')) {
                $that.parent().animate({
                    'height': filterHeight
                }, function() {
                    $that.removeClass('open-filter').addClass('close-filter').parent().css('overflow', 'visible');

                });
            } else if (me.detectmob() && $that.hasClass('close-filter')) {
                $that.parent().animate({
                    'height': '50px',
                    'overflow': 'hidden'
                }, function() {
                    $that.removeClass('close-filter').addClass('open-filter').parent().css('overflow', 'hidden');

                });
            } else {
                return false;
            }
        });
        $(window).bind('resize', setFilter);

    };


    var initResizer = function() {

    };

    tui.tweaks.init();
    return tui;

})(window.tui || {}, window, window.document, jQuery);

//  });

define("tuiTweaks", ["lazyLoad"], function() {});

/**
 * Helper file for angular app SearchResult
 * All non ajax related operations / operation dont require scope update can be kept here.
 * @param {[type]} ele  [description]
 * @param {[type]} opts [description]
 */
window.TUIResult = window.TUIResult || {};

window.TUIResult.ResultHelper = function() {
    var that = this,
        resultPanel = $('#results');

    that.init = function(resPanel) {
        if (resPanel) {
            resultPanel = resPanel;
        }
        that.tabAction();
        that.closeFilterPanel();
        that.hideBlankDiv();
        that.slideToggle();
        that.tabbing();
        that.facetDoneBtnAction();
        that.conceptTooltipAction();
        $.subscribe('breakpointchange', $.proxy(that.changeFilterPos, that));
    };
    var toolTipAnimation = function(targetelem) {
        var elem = $(targetelem).parents('.info-icon');
        var tooltip = elem.next().find('.wrapper');
        var toolTipPos = tooltip.position().top,
            bottomPos = 0;
        elem.parents('div.tool-tip-info').toggleClass('open');
        if (toolTipPos === 0) {
            bottomPos = '-100%';
        }

        tooltip.animate({
            bottom: bottomPos
        });
    };
    that.conceptTooltipAction = function() {
        resultPanel.on('click', '.tool-tip-info i', function(e) {
            var targetelem = e.target;
            if (TUIUtil.ie8OrLower()) {
                e.stopImmediatePropagation();
                toolTipAnimation(targetelem);
            } else {
                $(this).parents('div.tool-tip-info').toggleClass('open');
            }
        });
    };
    that.hotelData = function(json) {
        return $.extend(true, {}, json);
    };
    that.tabAction = function() {
        resultPanel.on('click', '#open-list-filter', function(e) {
            e.preventDefault();
            var $this = $(this),
                filterFlyout = $('#resultFilters');
            $this.toggleClass('active');
            $('#sort-list').removeClass('open');
            filterFlyout.addClass('active-filter');
            var top = 0;
            var left = $this.offset().left - 110;
            filterFlyout.toggleClass('open').css({
                'top': top + 'px',
                'left': left + 'px'
            });

            if (filterFlyout.hasClass('open')) {
                filterFlyout.show();
            } else {
                filterFlyout.hide();
            }
            $this.toggleClass('active-filter');
            $this.toggleClass('active');
            $this.toggleClass('open');
        });

        resultPanel.on('click', '.list-view-tabs li', function(e) {
            e.preventDefault();
            resultPanel.removeClass('search-open');
            var openPanelId = '';
            var listNum = $(this).index();
            var elemTopPos = $(this).offset().top;
            $(this).parent().find('li').each(function(i) {
                openPanelId = '#' + $(this).attr('data-tab');

                $(openPanelId).attr('style', '').removeClass('active-filter');
                if (openPanelId === '#sort-list') {
                    $('#resultFilters').removeClass('open');
                } else if (openPanelId === '#resultFilters') {
                    $('#sort-list').removeClass('open');
                } else if (openPanelId === '#search-panel') {
                    $('#sort-list').removeClass('open');
                }
            });

            var targetElem = $(this).attr('data-tab'),
                targetElemId = '#' + targetElem;
            if (targetElemId === '#search-panel') {
                $(targetElemId).addClass('open').show();
                resultPanel.addClass('search-open');

            } else if (targetElemId === '#resultFilters') {
                $(targetElemId).toggleClass('active-filter open');
            } else {
                elemTopPos = $(this).position().top + 39;
                $(targetElemId).toggleClass('open').css('top', elemTopPos + 'px').css('width', $(window).width() + 'px');
            }
        });
    };
    that.closeFilterPanel = function() {
        resultPanel.on('click', '#results-view-switch li a, #sort-list ul li,#list-search ', function() {
            if (($('#searchNowBtn').length) && !istabletOrDesktop() && !$('.sticky-mobile').length) {
                $('#searchNowBtn').wrap('<div class="sticky-mobile"></div>');
                $('.sticky-mobile').scrollToFixed({
                    bottom: 0,
                    left: 0,
                    limit: $('.sticky-mobile').offset().top
                });
            }
            $(this).parents('ul').parent().removeClass('open');

            $('#resultFilters').removeClass('open');
        });
    };
    var istabletOrDesktop = function() {
        if (TUIUtil.getCurrentBreakPoint() === 'lg') {
            return true;
        } else {
            return false;
        }
    };
    that.changeFilterPos = function() {
        var screenSize = TUIUtil.getCurrentBreakPoint();
        var elem = $('#open-list-filter'),
            resultFilters = $('#resultFilters'),
            listViewElem = $('#view-controls'),
            sortList = $('#sort-list'),
            elemLeftPos = elem.offset().left;

        if (screenSize) {
            resultFilters.removeClass('active-filter open');
            listViewElem.removeClass('open');
            sortList.removeClass('open');
        }
        that.adjustImageSize(resultPanel.find('.results-container'));
    };
    that.hideBlankDiv = function() {
        // hiding element with close class like "Zimmertyp", "Aktivitaten" on page load

        resultPanel.find('#left-search h3 span').each(function() {
            if ($(this).hasClass('icon-arrow-right')) {
                $(this).parent().siblings('.filter-block').hide();
            }
        });
    };

    that.adjustImageSize = function(resWrapper) {
        var imgCol = resWrapper.find('.image-col').find('.list-img').not('.carousel-formed'),
            cItem = imgCol.find('.carousel-item'),
            img = cItem.find('img').not('.lazyload-img');
        if (!TUIUtil.istabletOrDesktop()) {
            imgCol.css('width', '100%');
            cItem.css('width', '100%');
            img.css('width', '100%');

        } else {
            imgCol.removeAttr('style');
            cItem.removeAttr('style');
            img.removeAttr('style');
        }
    };

    that.slideToggle = function() {

        // Slide Toggle for components
        resultPanel.on('click', '#left-search h3', function(e) {
            e.stopImmediatePropagation();
            var h3 = $(this);
            var elemParent = $(this).parent(),
                elemParentId = $(this).parent().attr('id');
            if (elemParent.hasClass('last')) {
                elemParent.addClass('last-removed').removeClass('last');
            } else if (elemParent.hasClass('last-removed')) {
                elemParent.addClass('last').removeClass('last-removed');
            }

            if (h3.find('span, i').hasClass('icon-arrow-down')) { // changing arrow keys i.e., up and down
                that.updateFacetCookie(elemParentId, 'collapse');
                checkPriceFacet(elemParentId, 'collapse');
                h3.parent().find('.filter-block').slideUp(function() {
                    $(this).addClass('ng-hide').removeClass('ng-show');
                    h3.find('i').removeClass('icon-arrow-down').addClass('icon-arrow-right');
                });
            } else {
                that.updateFacetCookie(elemParentId, 'expand');
                checkPriceFacet(elemParentId, 'expand');
                h3.find('i').removeClass('icon-arrow-right').addClass('icon-arrow-down');
                h3.parent().find('.filter-block').hide().removeClass('ng-hide').slideDown(function() {
                    $(this).addClass('ng-show');
                });
            }
        });
    };

    that.tabbing = function() {
        resultPanel.on('click', '.tabbing-anchor a', function(e) {
            e.preventDefault();
            var clickedLink = $(this);
            clickedLink.siblings().removeClass('selected');
            clickedLink.addClass('selected');
            var selectedAttr = clickedLink.attr('data-link');
            clickedLink.parent().siblings().find('.tab-desc').removeClass('show').addClass('hide');
            $('.tabbing-container').find('.' + selectedAttr).addClass('show').removeClass('hide');
        });
    };
    /**
     * Rating slider value update on dom
     * @param  {[type]} value [description]
     * @return {[type]}       [description]
     */
    that.updateHotelRating = function(value) {
        var count = Math.floor(value),
            half = (value) % 1 !== 0,
            html,
            i,
            ratingText = $('body').data('rating-text');
        if (ratingText === 'star') { // create html for showing star rating
            html = ['<ul class="star-rating" >'];
            for (i = 0; i < count; i++) {
                html.push('<li class="icon-star"></li>');
            }

            if (half) {
                html.push('<li class="icon-star-half" />');
            }

            html.push('</ul>');
        } else { // create html for showing text rating as TTTT+ or SSS+ or FFF
            html = ['<ul class="text-rating" >'];

            for (i = 0; i < count; i++) {
                html.push('<li>' + ratingText + '</li>');
            }

            if (half) {
                html.push('<li>+</li>');
            }

            html.push('</ul>');
        }
        html = html.join('');
        $('div#hotel-rating-top').html(html);
    };

    that.facetDoneBtnAction = function() {
        resultPanel.on('click', '.txt-right', function(e) {
            resultPanel.find('[data-tab="resultFilters"]').trigger('click');
        });
    };


    /**
     * Update facest staus cookie on user action
     * @param  {[string]} facetGroupId [id of facet]
     * @param  {[string]} userAction [add / remove user action]
     */

    that.updateFacetCookie = function(facetGroupId, userAction) {
        var breakpoint = TUIUtil.getCurrentBreakPoint();
        var facetsCookie = $.cookie('COLLAPSED_EXPANDED_FACETS');


        if (facetsCookie) {
            facetsCookie = $.parseJSON(facetsCookie);
        } else {
            facetsCookie = [];
        }

        var updated = false;
        if (userAction === 'expand') {
            $.each(facetsCookie, function(i, item) {
                if (item.facetGroupId === facetGroupId && breakpoint === item.breakpoint) {
                    item.state = 'expanded';
                    updated = true;
                }
            });
            if (!updated) {
                facetsCookie.push({
                    facetGroupId: facetGroupId,
                    breakpoint: breakpoint,
                    state: 'expanded'
                });
            }
        } else { // 'collapse'
            updated = false;
            $.each(facetsCookie, function(i, item) {
                if (item.facetGroupId === facetGroupId && breakpoint === item.breakpoint) {
                    item.state = 'collapsed';
                    updated = true;
                }
            });
            if (!updated) {
                facetsCookie.push({
                    facetGroupId: facetGroupId,
                    breakpoint: breakpoint,
                    state: 'collapsed'
                });
            }
        }
        $.cookie('COLLAPSED_EXPANDED_FACETS', JSON.stringify(facetsCookie), {
            path: '/'
        });
    };

    /**
     * Update scope based on COLLAPSED_EXPANDED_FACETS cookie
     * the updated scope will be 'expanded' in $scope.facets
     */

    that.expandCollapseFacets = function($scope) {

        var facetsCookie = $.cookie('COLLAPSED_EXPANDED_FACETS');
        if (facetsCookie) {
            facetsCookie = $.parseJSON(facetsCookie);
        } else {
            facetsCookie = [];
        }

        var breakpoint = TUIUtil.getCurrentBreakPoint();

        if ($scope.facets && $scope.facets.length === 1) {
            $scope.facets[0].isExpanded = true;
            if ($.inArray(breakpoint, $scope.facets[0].expanded) === -1) {
                $scope.facets[0].expanded.push(breakpoint);
            }
            return;
        } else {
            $.each($scope.facets, function(index, facetObj) {
                if ($.inArray(breakpoint, facetObj.expanded) !== -1) {
                    facetObj.isExpanded = true;
                }
                $.each(facetsCookie, function(i, item) {
                    if ((item.facetGroupId === facetObj.id || facetObj.filterType.indexOf(item.facetGroupId) !== -1) && breakpoint === item.breakpoint) {
                        if (item.state === 'collapsed') {
                            facetObj.isExpanded = false;
                        } else {
                            facetObj.isExpanded = true;
                        }
                    }
                });

            });
        }
    };


    /**
     * Cookie to store the updated facets
     * @param  {[type]} selectedFacets [description]
     * @return {[type]}                [description]
     */
    that.updateFavFacetCookie = function(selectedFacets) {

        var trimmedObj = trimSelectedFacets(selectedFacets),
            prevFavFacets = [],
            intrimmedArr = false;

        if (!trimmedObj.items || !trimmedObj.items.length) { // No item in selectedFacets list.
            return;
        }

        if ($.cookie('FAVOURITE_FACETS')) {
            prevFavFacets = $.parseJSON($.cookie('FAVOURITE_FACETS')).items;
        }
        if (prevFavFacets.length && trimmedObj.items && trimmedObj.items.length) {
            $.each(prevFavFacets, function(indexprev, itemprev) {
                intrimmedArr = false;
                $.each(trimmedObj.items, function(index, item) {
                    if (item.groupId === itemprev.groupId && item.id === itemprev.id) {
                        intrimmedArr = true;
                        return false;
                    }
                });
                if (!intrimmedArr) {
                    trimmedObj.items.push(itemprev);
                }
            });
        }

        removeExtraFacets(trimmedObj);

        $.cookie('FAVOURITE_FACETS', JSON.stringify(trimmedObj), { // TODO check if the selected filters are coming blank on back
            path: '/'
        });
    };
    /**
     * In case of expand collapse any facet of type PRICE both facets should have same state
     * @param  {[type]} elemParentId [description]
     * @param  {[type]} 'collapse'   [description]
     * @return {[type]}              [description]
     */
    var checkPriceFacet = function(elemParentId, state) {
        if (elemParentId && elemParentId.indexOf('PRICE') !== -1) {
            if (elemParentId === 'PRICETOTAL') {
                that.updateFacetCookie('PRICEPERPERSON', state);
            } else {
                that.updateFacetCookie('PRICETOTAL', state);
            }
        }
    };

    var maxFavFacets = window.MAX_FAV_FACETS || 10;
    /**
     * Remove extra facets from fav facet cookie
     * @param  {[type]} trimmedObj [description]
     * @return {[type]}            [description]
     */
    var removeExtraFacets = function(trimmedObj) {
        if (trimmedObj.items && trimmedObj.items.length > maxFavFacets) {
            var extra = trimmedObj.items.length - maxFavFacets;
            var arr = trimmedObj.items;
            arr.splice(-extra, maxFavFacets);
            trimmedObj.items = arr;
        }
    };
    /**
     * REMOVE THE items from fav cookie
     * @param  {[type]} item [description]
     * @return {[type]}      [description]
     */
    that.trimFavFacetCookie = function(item) {
        var remainingItems = [],
            favCookie = $.cookie('FAVOURITE_FACETS');
        if (!favCookie) {
            return;
        }
        var favFacetCookie = $.parseJSON(favCookie);
        if (favFacetCookie && favFacetCookie.items) {
            $.each(favFacetCookie.items, function(idx, favItem) {
                if (favItem && item.id !== favItem.id) {
                    remainingItems.push(favItem);
                }
            });
        }

        favFacetCookie.items = remainingItems;
        $.cookie('FAVOURITE_FACETS', JSON.stringify(favFacetCookie), {
            path: '/'
        });
    };

    var trimSelectedFacets = function(selectedFacets) {
        var trimmedObj = {};
        trimmedObj.items = [];
        if (selectedFacets && selectedFacets.items) {
            $.each(selectedFacets.items, function(i, item) {
                trimmedObj.items.push({
                    groupId: item.groupId,
                    id: item.id
                });
            });
        }
        return trimmedObj;
    };

    that.updateSelectedStartDateLabel = function(d1, d2) {
        var dContainer = $('#start-date-slider');
        /*multiDate = dContainer.find('.multi-date'),
			from = dContainer.find('.from'),
			till = dContainer.find('.till'),
			singleDate = dContainer.find('.single-date');

		multiDate.hide();
		singleDate.hide();


		if (d1 === d2 && (d1 || d2)) {
			multiDate.hide();
			singleDate.html(d1 || d2);
			singleDate.show();
			return;
		} else {
			multiDate.show();
		}*/

        if (d1) {
            dContainer.find('.handle1').html(d1);
        }
        if (d2) {
            dContainer.find('.handle2').html(d2);
        }
    };

    return that;
};

define('resultHelper', [], function() {
    return angular.module('resultHelper', []).factory('ResultHelper', TUIResult.ResultHelper);
});

/**
 * Angular Service for SearchResult App.
 * contains serice calls for search results
 * like showMore, sorting, facet change etc
 * @param  {[type]} $http [description]
 * @return {[type]}       [description]
 */
window.TUIResult = window.TUIResult || {};

window.TUIResult.ResultService = function($http, locationService, ResultHelper) {

    var me = {},
        resWrapper = ($('#results').length) ? $('#results') : $('#flights-results'),
        sortingCombobox = $('select#cb-sort-results'),
        body = $('body'),
        facetWrapper = $('#left-search'),
        defOpts = {
            error: function(data, status, header, config) {
                // def error handling
            },
            dataType: 'json',
            cache: false,
            headers: {
                contentType: 'application/json'
            },
            url: facetWrapper.data('service'),
            method: 'POST'
        };
    me.ajaxInProgress = false;

    /**
     * Ajax call for result change
     * @param  {[type]} opts   [description]
     * @param  {[type]} $scope [description]
     * @return {[type]}        [description]
     */
    me.getData = function(opts, $scope, action) {

        TUIUtil.toggleLoader(body);
        me.ajaxInProgress = true;
        opts = $.extend({}, defOpts, opts);
        $http(opts).success(function(response) {

            me.ajaxInProgress = false;
            me.checkSessionTimeout(response);
            TUIUtil.toggleLoader(body, true);
            var append = false;
            if (action && action === 'showMore') {
                if (!opts.allRes) {
                    append = true;
                }
            }
            ResultHelper.updateFavFacetCookie(response.selectedfilters);
            var sortCriteria = $.parseJSON(opts.data).sortCriteria;
            $scope.updateScope(response, append, sortCriteria);
            $scope.updateScopeWithExpandedFacets(response.facets);
        }).error(function() {
            me.ajaxInProgress = false;
            TUIUtil.toggleLoader(body, true);
            TUIUtil.printLog('ResultService ajax failed for:' + opts);
        });
    };

    me.checkSessionTimeout = function(json) {
        if (json && !json.totalResults && json.sessionTimeOutMessage) {
            window.alert(json.sessionTimeOutMessage);
           // window.location.reload();
        }
    };

    me.triggerHashChange = function(key, json, forceBroadCast, $scope) {
        if (TUIUtil.isCookieDisabled) {
            me.triggerAjaxCall(null, json, $scope);
        } else {
            locationService.hashChange(key, json, forceBroadCast);
        }

    };

    me.triggerAjaxCall = function(event, obj, $scope) {
        TUIUtil.printLog('locationHashChange' + obj.postJSON);
        me.removeFirstSortOption(); // remove static sort by option if it is not selected
        var sortingCombobox = $('select#cb-sort-results'),
            sortCriteria = sortingCombobox.find('option:first').val();

        if (!obj.postJSON) { // No AJAX call needed
            TUIUtil.toggleLoader(resWrapper, true);
            var newHotelData = ResultHelper.hotelData(hotelData || flightData);
            $scope.updateScope(newHotelData, false);
        } else { // GET The data from server using postJSON

            if (obj.postJSON.postJSON) {
                obj.postJSON = obj.postJSON.postJSON;
            }
            var action = obj.postJSON.action;

            if (obj.postJSON.sortCriteria) {
                sortCriteria = obj.postJSON.sortCriteria;
            }

            obj.postJSON.currentFacetCategories = $scope.facets;

            obj.postJSON.allResults = locationService.checkHistory($scope);

            var additionalJSON = me.createPostJSON($scope);

            obj.postJSON =  $.extend({},obj.postJSON, additionalJSON);

            delete obj.postJSON.currentFacetCategories;

            delete obj.postJSON.previousSelectedFacets;

            delete obj.postJSON.selectedFacetGroup;



            var ajaxOptions = {
                data: JSON.stringify(obj.postJSON)

            };

            ajaxOptions.allRes = obj.postJSON.allResults;

            if (action === 'showMore') {
                ajaxOptions.url = obj.postJSON.url;
            }

            me.getData(ajaxOptions, $scope, action);
        }
    };

    me.createPostJSON = function($scope){
        me.setFormValues();
        var json = {
                requestData:window.formValuesJSON,
                initialFacetCategories:$scope.initialFacetCategories,
                previousSelectedFacets: $scope.selectedfilters,
                favFacetsCookie:$.cookie('FAVOURITE_FACETS') || ""
        };
        return json;
    };

    me.setFormValues = function () {
        if(!window.formValuesJSON.rooms){
            window.formValuesJSON.rooms = [{"adults":"2","children":"0","childAgeList":[],"id":"room-1","roomId":"room-1"}];
        }
        if(!window.formValuesJSON.duration){
            window.formValuesJSON.duration = 8;
            window.formValuesJSON.durationId = "8,9,13,15"
        }
        if(!window.formValuesJSON.selectedAirports){
            window.formValuesJSON.selectedAirports=["GOT","JKG","CPH","LLA","MMX","NRK","SFT","ARN","ORB"];
        }
        if(!window.formValuesJSON.searchValues){
            window.formValuesJSON.searchValues = []
        }
        if(!window.formValuesJSON.to){

            var chunks = window.formValuesJSON.from.split('/');
                if (chunks.length !== 3) {
                    return;
                }
            var dateObj = new Date(chunks[2], chunks[1] - 1, chunks[0]);
    var dchunks = window.formValuesJSON.durationId.split(',');
    var dval = dchunks[dchunks.length-1];

            dateObj.setDate(dateObj.getDate() + parseInt(dval));

            function pad(s) { return (s < 10) ? '0' + s : s; }
   

            window.formValuesJSON.to = pad(dateObj.getDate())+"/"+pad(dateObj.getMonth()+1)+"/"+dateObj.getFullYear();
        }

    }

    me.removeFirstSortOption = function() {
        if ($('#cb-sort-results').val() !== 'sort_by') {
            $('option.sort-option').remove();
        }
    };

    /**
     * Check if the combobox value has not changed on back
     * @param  {[type]} sortCriteria [description]
     * @return {[type]}              [description]
     */
    me.checkSortComboboxValue = function(sortCriteria) {
        var sortingCombobox = $('select#cb-sort-results');
        if (sortCriteria) {
            if (sortCriteria !== sortingCombobox.val()) {
                sortingCombobox.val(sortCriteria);
            }
        } else {
            sortingCombobox.val(sortingCombobox.find('option:first').val());
        }
    };

    return me;
};

define('resultService', [], function() {
    return angular.module('resultService', []).service('ResultService', ['$http', 'LocationService', 'ResultHelper', TUIResult.ResultService]);
});

/**
 * Angular Service for handling the operation / server calls related to Facets (Filters)
 * @param  {[type]} $http
 * @return {[type]}        [description]
 */
window.TUIResult = window.TUIResult || {};

window.TUIResult.FacetService = function($http, $location, locationService, resultService) {

    var me = {};

    /**
     * Generic JSON for every ajax call contains sort and searchMetaData
     * @param  {[type]} $scope [description]
     * @return {[type]}        [description]
     */
    var getCommonJSON = function($scope) {

        resetUserSlideOperation($scope);

        return $.extend({}, $scope.searchMetaData, {
            selectedFacetGroup: me.getOpenedFacetGroups()
        });
    };

    /**
     * Reset Filters
     * @param  {[type]} ele    [description]
     * @param  {[type]} $scope [description]
     * @param  {[type]} event  [description]
     * @return {[type]}        [description]
     */
    me.resetFilters = function(ele, $scope, event) {

        var json = $.extend({}, {
            facets: []
        }, getCommonJSON($scope));

        resultService.triggerHashChange('resetFilter', {
            postJSON: json
        }, false, $scope);
    };

    /**
     * Remove a selected filter
     * @param  {[type]} ele    [description]
     * @param  {[type]} $scope [description]
     * @param  {[type]} event  [description]
     * @return {[type]}        [description]
     */
    me.removeSelected = function(ele, $scope, item) {
        var grpId = item.groupId || ele.data('gid'),
            facetId = item.id || ele.attr('id'),
            facetType = item.facetType,
            selectedFacets = [],
            isRatingFacet = false,
            selectedItemIdx = -1;

        if (item.filterType.indexOf('rating') !== -1 || isPriceSlider(item)) {
            isRatingFacet = true;
            removeFromRatingStore(item, $scope);
        }
        if (item.filterType === 'duration-slider') {
            isRatingFacet = true;
            removeFromRatingStore(item, $scope);
        }

        var tempSelected = me.getChoosenFacets($scope);
        $.each(tempSelected, function(f, facet) {

            if (facet.id !== facetId || (isRatingFacet && grpId !== facet.groupId)) {
                selectedFacets.push(facet);
            }

        });


        var json = $.extend({}, {
            facets: selectedFacets,
            removedFacet: item
        }, getCommonJSON($scope));

        json = removeSelectedParents(json);
        resultService.triggerHashChange('remove-' + facetId, {
            postJSON: json
        }, false, $scope);
    };
    /**
     * Price toggle no AJAX call requried
     * @param  {[type]} ele    [description]
     * @param  {[type]} $scope [description]
     * @return {[type]}        [description]
     */
    me.bindPriceToggle = function(ele, $scope) {
        var newPType = 'pp';
        if (ele.hasClass('active')) {
            return;
        }
        $('#resultFilters,#sort-list').removeClass('open');
        ele.siblings().removeClass('active');
        ele.addClass('active');
        var rangeSetting = {};

        var type = ele.attr('data-ptype');
        if (type === 'ppPrice') {
            newPType = 'pp';
            $.each($scope.facets, function(i, facet) {
                if (facet.filterType === 'price-slider') {
                    rangeSetting = facet;
                    rangeSetting.groupId = 'PRICEPERPERSON';
                    return false;
                }
            });
        } else {
            newPType = 'tp';
            $.each($scope.facets, function(i, facet) {
                if (facet.filterType === 'price-slider-total') {
                    rangeSetting = facet;
                    rangeSetting.groupId = 'PRICETOTAL';
                    return false;
                }
            });
        }

        $scope.searchMetaData.showPriceType = newPType;
        rangeSetting.id = rangeSetting.end;
        var addPriceSliderInfo;
        if ($scope.ratingStore.length) {

            addPriceSliderInfo = false;
            $.each($scope.ratingStore, function(i, item) {
                if (isPriceSlider(item)) {
                    addPriceSliderInfo = true;
                    return false;
                }
            });
        }
        if (addPriceSliderInfo) {
            updateRatingStore(rangeSetting, $scope);
        }
    };

    me.showMore = function(opts, $scope) {
        var json = $.extend({}, $scope.searchMetaData, {
            facets: me.getChoosenFacets($scope),
            action: 'showMore',
            selectedFacetGroup: me.getOpenedFacetGroups()
        }, getCommonJSON($scope), opts);
        json = removeSelectedParents(json);

        resultService.triggerHashChange('show-more.' + (opts.currentPageNumber + 1), json); // NOT USING history for show More
    };

    me.sort = function(opts, $scope) {
        var json = $.extend({}, $scope.searchMetaData, {
            facets: me.getChoosenFacets($scope),
            action: 'sort',
            selectedFacetGroup: me.getOpenedFacetGroups()
        }, opts, getCommonJSON($scope));
        json = removeSelectedParents(json);

        resultService.triggerHashChange('sort-' + $scope.searchMetaData.sortCriteria, {
            postJSON: json
        }, true, $scope);
    };

    me.checkboxMultiLevelChange = function(ele, $scope, isContinent, item) {
        var grpId = ele.data('gid'),
            checked = ele.is(':checked'),
            facetId = ele.attr('id');

        updateSelectedCB($scope, grpId, facetId, checked, isContinent);
        if (!isContinent) {
            updateInnerSelectedCB($scope, grpId, facetId, checked);
        } else { // CONTINENT
            updateChildrenCB($scope, grpId, facetId, checked);

        }

        var json = $.extend({}, {
            facets: me.getChoosenFacets($scope, ele)
        }, getCommonJSON($scope));

        json = removeSelectedParents(json);

        if (!checked) {
            item.filterType = 'multi-checkbox';
            json.removedFacet = item;
        }
        resultService.triggerHashChange(facetId, {
            postJSON: json
        }, false, $scope);
    };
    /**
     * Filtering out the parent checkboxes if they are checked, in those cases only
     * send their children at top level selected facet.
     * Else include the facet.
     * @param  {[type]} json    [description]
     * @param  {[type]} checked [description]
     * @param  {[type]} facetId [description]
     * @return {[type]}         [description]
     */
    var removeSelectedParents = function(json) {
        var retJSON = $.extend({}, json);
        retJSON.facets = [];
        $.each(json.facets, function(i, facet) {
            if (facet.filterType === 'multi-level-checkbox' && facet.children && facet.children.length) {
                retJSON.facets = $.merge(retJSON.facets, facet.children);
            } else {
                retJSON.facets.push(facet);
            }
        });

        return retJSON;
    };

    /**
     * Checkbox change event in facets
     * @param  {[type]} ele    [description]
     * @param  {[type]} $scope [description]
     * @param  {[type]} event  [description]
     * @return {[type]}        [description]
     */
    me.checkboxChange = function(ele, $scope, item) {
        var grpId = ele.data('gid'),
            checked = ele.is(':checked'),
            facetId = ele.attr('id');
        if (!checked) // call the remove method
        {
            item.filterType = 'multi-checkbox';
            me.removeSelected(ele, $scope, item);
            return;
        }
        updateSelectedCB($scope, grpId, facetId, checked);

        var json = $.extend({}, {
            facets: me.getChoosenFacets($scope, ele)
        }, getCommonJSON($scope));

        json = removeSelectedParents(json);


        resultService.triggerHashChange(facetId, {
            postJSON: json
        }, true, $scope);

    };

    me.changeRating = function(elem, data, $scope) {

        if (!data || !data.additionalOpts) {
            return;
        }

        var rangeSetting = $.parseJSON(data.additionalOpts),
            commonjson = getCommonJSON($scope),
            currentFacet = '';

        rangeSetting.id = data.value;

        updateRatingStore(rangeSetting, $scope);


        $.each($scope.facets, function(i, facet) {

            if (facet.filterType === rangeSetting.filterType && isPriceSlider(rangeSetting) && parseFloat(data.value) === parseFloat(facet.max)) {
                currentFacet = facet;
            } else if (facet.filterType === rangeSetting.filterType && isRatingSlider(rangeSetting) && parseFloat(data.value) === parseFloat(facet.allowedRangeMin)) {
                currentFacet = facet;
            }
        });

        var facets = me.getChoosenFacets($scope); // checkboxes + all rating widgets

        var json = $.extend({}, {
            facets: facets,
            action: 'sliderAction'
        }, commonjson);


        if (currentFacet) {
            json.removedFacet = currentFacet;
        }
        json = removeSelectedParents(json);

        resultService.triggerHashChange('Rating', {
            postJSON: json
        }, true, $scope);

    };

    me.changeDuration = function(ui, datesArr, dateJSON, rangeSettingJSON, $scope) {

        if (!datesArr || !datesArr.length) {
            return;
        }

        var rangeSetting = dateJSON;
        var commonjson = getCommonJSON($scope);
        var start = ui.values[0];
        var end = ui.values[1];
        var startDate;
        var startMonth;
        var endDate;
        var endMonth;

        startDate = datesArr[start].date.length < 2 ? '0' + datesArr[start].date : datesArr[start].date;
        startMonth = datesArr[start].month.length < 2 ? '0' + (datesArr[start].month + 1) : datesArr[start].month + 1;
        startDate = startDate + '/' + startMonth + '/' + datesArr[start].year;
        endDate = datesArr[end].date.length < 2 ? '0' + datesArr[end].date : datesArr[end].date;
        endMonth = datesArr[end].month.length < 2 ? '0' + (datesArr[end].month + 1) : datesArr[end].month + 1;
        endDate = endDate + '/' + endMonth + '/' + datesArr[end].year;


        rangeSetting = $.extend({}, {
            id: rangeSettingJSON.groupId,
            groupId: rangeSettingJSON.groupId,
            facetType: rangeSettingJSON.facetType,
            max: rangeSettingJSON.max,
            min: rangeSettingJSON.min,
            start: start,
            end: end
        }, rangeSetting);
        rangeSetting.startDate = startDate;
        rangeSetting.endDate = endDate;
        rangeSetting.firstDate = dateJSON.firstDate;

        updateRatingStore(rangeSetting, $scope);

        var facets = me.getChoosenFacets($scope), // checkboxes + all rating widgets


            json = $.extend({}, {
                facets: facets,
                action: 'sliderAction'
            }, commonjson);

        json = removeSelectedParents(json);

        resultService.triggerHashChange('Duration', {
            postJSON: json
        }, true, $scope);

    };

    me.getOpenedFacetGroups = function() {
        var selectedFacetGroup = [];
        $('.icon-arrow-down:visible').each(function() {
            var selectedListId = $(this).parents('.top-facet-group').attr('id');
            selectedFacetGroup.push(selectedListId);
        });
        return selectedFacetGroup;
    };

    /**
     * Get the facet json , mark the selected checkbox in the
     * scope facet json and send it to server
     * @param  {[type]} $scope  [description]
     * @param  {[type]} grpId   [description]
     * @param  {[type]} facetId [description]
     * @param  {[type]} checked [description]
     * @return {[type]}         [description]
     */
    var updateSelectedCB = function($scope, grpId, facetId, checked) {
        var facets = $scope.facets;

        $.each(facets, function(f, fgroup) {

            if (fgroup.id === grpId) { // Plain Group
                $.each(fgroup.items, function(i, item) {
                    if (item.id === facetId) {
                        if (checked) {
                            item.selected = true;
                        } else {
                            item.selected = false;
                        }
                        return false;
                    }
                });
                return false;
            }
        });

        return facets;
    };

    var updateInnerSelectedCB = function($scope, grpId, facetId, checked) {
        var facets = $scope.facets;

        $.each(facets, function(f, fgroup) {

            if (fgroup.filterType === 'multi-level-checkbox' && fgroup.items && fgroup.items.length) {

                $.each(fgroup.items, function(i, item) {

                    $.each(item.children, function(i, child) {
                        if (child.id === facetId) {
                            if (checked) {
                                child.selected = true;
                            } else {
                                item.selected = false;
                                child.selected = false;
                            }
                            return false;
                        }
                    });
                });
                return false;
            }
        });

        return facets;
    };

    var updateChildrenCB = function($scope, grpId, facetId, checked) {
        $.each($scope.facets, function(f, fgroup) {
            if (fgroup.filterType === 'multi-level-checkbox' && fgroup.items && fgroup.items.length) {

                $.each(fgroup.items, function(i, item) {
                    if (item.id === facetId && item.children && item.children.length) {
                        $.each(item.children, function(i, child) {
                            if (checked) {
                                child.selected = true; // uncheck child irrespective of the case.
                                // CHANGE: mark child selected irrespective of the case even disabled
                            } else {
                                child.selected = false;
                            }

                        });
                        return false;
                    }
                });
            }
        });
    };

    me.getChoosenFacets = function($scope, checkbox) {
        var arr = [],
            facets = $scope.facets;

        if (!facets) {
            return arr;
        }
        $.each(facets, function(i, item) {
            if (item.filterType === 'multi-checkbox') {
                $.each(item.items, function(c, cb) {
                    cb = $.extend({}, cb, {
                        groupId: item.id,
                        facetType: item.facetType
                    });
                    if (cb.selected) {

                        arr.push(cb);
                    } else if (checkbox && checkbox.attr('id') === cb.id && checkbox.is(':checked')) {
                        arr.push(cb);
                    }
                });
            } else if (item.filterType === 'multi-level-checkbox') {
                $.each(item.items, function(c, cb) {
                    cb = $.extend({}, cb, {
                        groupId: item.id,
                        facetType: item.facetType
                    });
                    if (cb.selected) {
                        arr.push(cb);
                    } else if (checkbox && checkbox.attr('id') === cb.id && checkbox.is(':checked')) {
                        arr.push(cb);
                    } else if (!cb.selected && cb.children) {
                        $.each(cb.children, function(cd, child) {
                            if (child.selected) {
                                arr.push(child);
                            } else if (checkbox && checkbox.attr('id') === child.id && checkbox.is(':checked')) {
                                arr.push(child);
                            }
                        });
                    }
                });
            }
        });


        arr = $.merge(arr, $scope.ratingStore);
        var finalArr = [];
        // Remove the hidden Price Slider to be sent to server
        $.each(arr, function(i, item) {
            if (item.filterType === 'price-slider-total') {
                if ($scope.searchMetaData.showPriceType === 'tp') {
                    finalArr.push(item);
                }
            } else if (item.filterType === 'price-slider') {
                if ($scope.searchMetaData.showPriceType === 'pp') {
                    finalArr.push(item);
                }
            } else {
                finalArr.push(item);
            }
        });

        return finalArr;
    };

    var updateRatingStore = function(rangeSetting, $scope) {
        var updated = false,
            idx = -1,
            updatedObj;
        rangeSetting.userOperation = true; // TODO from toggleprice to be analyzsed
        if ($scope.ratingStore.length) {
            $.each($scope.ratingStore, function(i, ratingObj) {
                if (ratingObj.groupId === rangeSetting.groupId || ratingObj.id === rangeSetting.groupId) { // 2nd cond in case the store is updated from price toggle and not slider change.
                    updatedObj = rangeSetting;
                    idx = i;
                    return false;
                }
            });

            if (idx > -1) {
                $scope.ratingStore.splice(idx, 1);
                $scope.ratingStore.push(updatedObj);
                updated = true;
            }
        }
        if (!updated) {
            $scope.ratingStore.push(rangeSetting);
        }
    };

    var removeFromRatingStore = function(rangeSetting, $scope) {
        var tempStore = $scope.ratingStore,
            priceSliderRemoved = isPriceSlider(rangeSetting);
        $.each($scope.ratingStore, function(idx, ratingObj) {
            if (ratingObj.groupId === rangeSetting.id || ratingObj.id === rangeSetting.groupId) {
                tempStore.splice(idx, 1);
            } else if (isPriceSlider(ratingObj) && priceSliderRemoved) {
                // Removing the other price slider as well (TP / PP)
                tempStore.splice(idx, 1);
            }
        });

        $scope.ratingStore = tempStore;
    };

    var isPriceSlider = function(rangeSetting) {
        return (rangeSetting.filterType.indexOf('price') !== -1);
    };

    var isRatingSlider = function(rangeSetting) {
        return (rangeSetting.filterType.indexOf('rating') !== -1);
    };

    var resetUserSlideOperation = function($scope) {
        if ($scope.ratingStore && $scope.ratingStore.length) {
            $.each($scope.ratingStore, function(i, ratingObj) {
                ratingObj.userOperation = false;
            });
        }
    };

    return me;
};


define('facetService', [], function() {
    return angular.module('facetService', []).service('FacetService', ['$http', '$location', 'LocationService', 'ResultService', TUIResult.FacetService]);
});


// Hack to prevent simultaneous hashChange events.
var lastLocationChangeTime = null;

define('locationService', [], function() {

    return angular.module('locationService', []).service('LocationService', ['$http', '$location', '$rootScope',
        function($http, $location, $rootScope) {

            var me = {};
            window.hashMapArray = [];

            /**
             * Update the window location hash
             * @param  {[type]} param     [description]
             * @param  {[type]} valueJSON [description]
             * @return {[type]}           [description]
             */
            me.hashChange = function(param, valueJSON, forceBroadCast) {

                var randomKey = hashKeyGernator(param);
                if (window.sessionStorage) {
                    window.sessionStorage.setItem(randomKey, JSON.stringify(valueJSON));
                }
                $location.hash(randomKey);
                if (forceBroadCast) {
                    $rootScope.$broadcast('$locationChangeSuccess', $location);
                }
            };

            me.checkHistory = function(scope) {

                var cHash = $location.hash(),
                    storedVal = null,
                    cHashPage = 1,
                    cHashSplit = cHash.split('.');
                if (cHashSplit.length > 1) {
                    cHashPage = parseInt(cHashSplit[1], 10) || cHashPage;
                }
                if (scope.searchMetaData && scope.searchMetaData.currentPageNumber) {
                    if (cHashPage < scope.searchMetaData.currentPageNumber) {
                        return true;
                    } else {
                        return false;
                    }
                } else {
                    /* On Back button press. */
                    return true;
                }
            };

            /**
             * 7 key random hash Generator
             * @param  {[type]} key [description]
             * @return {[type]}     [description]
             */
            var hashKeyGernator = function(key) {
                var text = '';
                var possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

                for (var i = 0; i < 7; i++) {
                    text += possible.charAt(Math.floor(Math.random() * possible.length));
                }
                return text + '-' + key;
            };

            $rootScope.$on('$locationChangeSuccess', function(obj, obj2) {

                var diff = (new Date()).getTime() - lastLocationChangeTime;
                TUIUtil.printLog('lastLocationChangeTime: ' + lastLocationChangeTime + ', Diff with current location Change: (ms) : ' + diff);
                if (diff < 1000) {
                    TUIUtil.printLog('Ignoring Subsequent Request on hashChange broadcast');
                    return false;
                }
                lastLocationChangeTime = new Date().getTime();
                var cHash = $location.hash(),
                    storedVal = null;
                if (window.sessionStorage && window.sessionStorage.length && $rootScope.searchResultApp.appInitialized) {
                    storedVal = sessionStorage.getItem(cHash);
                    if (typeof storedVal === 'string') {
                        storedVal = $.parseJSON(storedVal);
                    }
                    if (storedVal) {
                        $rootScope.$broadcast('locationHashChange', {
                            postJSON: storedVal
                        });
                    } else {
                        $rootScope.$broadcast('locationHashChange', {
                            postJSON: null
                        });
                    }
                }
            });
            return me;
        }
    ]);

});

/**
 * Main Controller for SearchResult app, here all the major
 * event binding and scope updation should happen.
 *
 * @param  {[type]} $scope        [description]
 * @param  {[type]} $sce          [description]
 * @param  {[type]} ResultService [description]
 * @param  {[type]} ResultHelper  [description]
 * @param  {[type]} FacetService
 * @param  {[type]} resContainer
 * @return {[type]}               [description]
 */

define('resultController', [], function() {
    return angular.module('resultController', []).controller('ResultController', ['$rootScope', '$scope', '$sce', 'ResultService', 'ResultHelper', 'FacetService', '$location',
        function($rootScope, $scope, $sce, ResultService, ResultHelper, FacetService, $location) {

            var resWrapper = $('#results'),
                resContainer = resWrapper.find('.results-container'),
                bindingDone = false,
                bindEvents,
                bindCarousel,
                sortingCombobox = $('select#cb-sort-results'),
                setPageNumberAndRange,
                scrollToLastItem,
                scrollTimer,
                loadImageOnScroll,
                t = {};

            $scope.ratingStore = [];

            $scope.openDetail = function(e) {
                var target = e.target;
                if ($(target).hasClass('next') || $(target).hasClass('prev') || $(target).hasClass('icon-info')) {
                    return;
                } else {
                    window.location = this.hotel.detailURL;
                }
            };

            $scope.allowHTML = function(htmlStr) {
                return $sce.trustAsHtml(htmlStr);
            };

            $scope.allowHTML = function(htmlStr) {
                return $sce.trustAsHtml(htmlStr);
            };
            $scope.showPriceToggle = function() {
                var show = true;
                if (window.formValuesJSON && window.formValuesJSON.rooms && window.formValuesJSON.rooms.length) {
                    var people = 0;
                    $.each(window.formValuesJSON.rooms, function(r, room) {
                        people = people + (room.adults * 1);
                    });
                    if (people === 1) {
                        show = false;
                    }
                }
                return show;
            };
            /**
             * Update the scope based on either ajax call or with hotel data present on the page
             * if the obj.postJSON is not null that means hashchange has a valid post json and should
             * be used to trigger the ajax call, else if its a back button scenario to the first
             * instance of result page (no hashtag) then dont make the ajax call just update the
             * scope with the hoteldata present on the page.
             * @param  {[type]} event [description]
             * @param  {[type]} obj   [description]
             * @return {[type]}       [description]
             */
            $scope.$on('locationHashChange', function(event, obj) {

                ResultService.triggerAjaxCall(event, obj, $scope);

            });

            /**
             * Common event binding should be called only once
             * @return {[type]} [description]
             */
            bindEvents = function() {
                if (!bindingDone) {
                    resWrapper = $('#results');
                    resContainer = resWrapper.find('.results-container');

                    // Sort Event, cannot use ng-change as it requires ngModel which is not implemented yet
                    resWrapper.on('change', 'select#cb-sort-results', $scope.bindSorting);

                    resWrapper.on('click', '#sort-list li', bindSortingMobile);

                    $scope.isLastFacetGroup = function(check) {
                        var cssClass = check ? 'op-facet-group filter-prices last' : 'top-facet-group filter-prices';
                        return cssClass;
                    };

                    $scope.checkboxMultiLevelChange = function($event, $this, isContinent, json) {
                        var elem = $($event.target);
                        FacetService.checkboxMultiLevelChange(elem, $scope, isContinent, json);
                    };

                    $scope.checkboxChange = function($event, json) {
                        var elem = $($event.target);
                        FacetService.checkboxChange(elem, $scope, json);
                        if (!elem.is(':checked')) {
                            // remove from cookie before ajax call
                            ResultHelper.trimFavFacetCookie(json);
                        }
                    };

                    $scope.removeSelected = function($event, item) {
                        var elem = $($event.target);
                        // ResultHelper.trimFavFacetCookie(item); DEV-15014
                        FacetService.removeSelected(elem, $scope, item);
                    };

                    $scope.removeFavourite = function($event, item) {
                        var favFacetsItems = $scope.favFacets.items;
                        var favFacetsAllItems = $scope.favFacets.allItems;
                        // remove the element from current items
                        $.each(favFacetsItems, function(idx, favItem) {
                            if (favItem && item.id === favItem.id) {
                                favFacetsItems.splice(idx, 1);
                            }
                        });
                        // remove the element from allItems array
                        $.each(favFacetsAllItems, function(idx, favItem) {
                            if (favItem && item.id === favItem.id) {
                                favFacetsAllItems.splice(idx, 1);
                            }
                        });
                        // if exists, display the next element
                        if (favFacetsAllItems.length > favFacetsItems.length) {
                            favFacetsItems.push(favFacetsAllItems[favFacetsAllItems.length - 1]);
                        }
                        // remove the element from cookie
                        ResultHelper.trimFavFacetCookie(item);
                    };

                    $scope.favShowMoreLess = function(favFacets) {
                        if (favFacets.showMore) {
                            favFacets.showMore = false;
                            favFacets.showLess = true;
                            favFacets.items = favFacets.allItems;
                        } else {
                            favFacets.showMore = true;
                            favFacets.showLess = false;
                            var allItems = $.merge([], favFacets.allItems);
                            var initialItems = allItems.splice(0, favFacets.maxToShow);
                            favFacets.items = initialItems;
                        }
                    };

                    $scope.resetFilters = function($event) {
                        var elem = $($event.target);
                        FacetService.resetFilters(elem, $scope);
                    };

                    $scope.priceToggle = function($event) {
                        var elem = $($event.target);
                        if (!elem.is('LI')) {
                            elem = elem.parents('li');
                        }
                        FacetService.bindPriceToggle(elem, $scope);
                        ResultHelper.updateFacetCookie('PRICETOTAL', 'expand');
                        ResultHelper.updateFacetCookie('PRICEPERPERSON', 'expand');


                    };
                    loadImageOnScroll();
                    $scope.filterShowMoreLess = function(facet) {
                        facet.showList = !facet.showList;
                        if (typeof(Storage) !== 'undefined') {
                            var expandedFacetsValue = sessionStorage.getItem('expandedFacets');
                            if (expandedFacetsValue) {
                                if (facet.showList) {
                                    expandedFacetsValue = expandedFacetsValue + '|' + facet.id;
                                    sessionStorage.setItem('expandedFacets', expandedFacetsValue);
                                } else {
                                    var facetValues = expandedFacetsValue.split('|'),
                                        updatedExpandedFacets;
                                    $.each(facetValues, function(idx, value) {
                                        if (facet.id !== value) {
                                            if (updatedExpandedFacets) {
                                                updatedExpandedFacets = updatedExpandedFacets + '|' + value;
                                            } else {
                                                updatedExpandedFacets = value;
                                            }
                                        }
                                    });
                                    if (updatedExpandedFacets) {
                                        sessionStorage.setItem('expandedFacets', updatedExpandedFacets);
                                    } else {
                                        sessionStorage.removeItem('expandedFacets');
                                    }

                                }
                            } else {
                                sessionStorage.expandedFacets = facet.id;
                            }
                        } else {
                            console.log('browser does not support storage');
                        }
                    };

                    bindingDone = true;
                    ResultHelper.init();
                }
            };

            var bindSortingMobile = function() {
                var combobox = $('#cb-sort-results'),
                    sortList = $(this),
                    serviceURL = combobox.data('service'),
                    selectedSortCriteria = sortList.data('value');
                combobox.val(selectedSortCriteria).trigger('change');
            };
            /**
             * [ratingFilterCallback description]
             * @param  {[type]} eve    [description]
             * @param  {[type]} valObj [description] - Options
             * @return {[type]}        [description]
             */
            $scope.ratingFilterCallback = function(eve, valObj) {
                FacetService.changeRating($(eve.target), valObj, $scope);
            };

            /**
             * [startDateFilterCallback description]
             * @param  {[type]} eve    [description]
             * @param  {[type]} valObj [description] - Options
             * @return {[type]}        [description]
             */
            $scope.startDateFilterCallback = function(ui, datesArr, dateJSON, json) {
                FacetService.changeDuration(ui, datesArr, dateJSON, json, $scope);
            };

            $scope.updateHotelRating = function(value) {
                ResultHelper.updateHotelRating(value);
            };


            $scope.ratingViewCallback = function(obj, $event) {
                $.each($scope.facets, function(ii, iv) {
                    if (iv.filterType === 'hotel-rating-slider' && $(obj.target).attr('id') === 'hotel-ratingele') {
                        $scope.facets[ii].value = $event.value;
                        $scope.updateHotelRating($event.value);
                    }
                    if (iv.filterType === 'guest-rating-slider' && $(obj.target).attr('id') === 'guest-ratingele') {

                        $scope.facets[ii].value = $event.value;
                        $('div#guest-rating-top').html($event.value);
                    }
                });
            };

            $scope.budgetFilterViewCallback = function(event, json) {
                $.each($scope.facets, function(ii, iv) {
                    if (iv.filterType === 'price-slider' && ($(event.target).attr('id') === 'budget-price' || $(event.target).attr('id') === 'budget-price-total')) {
                        $scope.facets[ii].end = json.value;
                        $scope.updateBudget(event, json);
                    }


                });
            };

            $scope.updateBudget = function(event, json) {

                $(event.target).find('label').eq(0).text(TUIUtil.formatPrice(json.value, true));
            };

            $scope.startDateChangeCallback = function(d1, d2) {
                ResultHelper.updateSelectedStartDateLabel(d1, d2);
            };
            /**
             * Show more event handler
             * @return {[type]} [description]
             */
            $scope.bindShowMore = function(currentPageNumber) {
                var serviceURL = $scope.searchMetaData.showMoreService;
                if (!serviceURL) {
                    return;
                }

                FacetService.showMore({
                    url: serviceURL,
                    currentPageNumber: currentPageNumber
                }, $scope);
            };
            /**
             * Sorting Event Handler
             * @param  {[type]} e [description]
             * @return {[type]}   [description]
             */
            $scope.bindSorting = function(e) {
                var serviceURL = $(this).data('service');
                if (!serviceURL) {
                    return;
                }
                $scope.sortCriteria = $(this).val();
                $scope.searchMetaData.sortCriteria = $scope.sortCriteria;
                FacetService.sort({
                    url: serviceURL
                }, $scope);
            };


            /**
             * Carousel initiation after every result update
             * @return {[type]} [description]
             */
            bindCarousel = function(container) {

                ResultHelper.adjustImageSize(resWrapper);

                if (!resContainer.data('enablecarousel')) {
                    return;
                }
                t.carousels = [];
                var resultItem = container.find('div.list-img');

                resultItem = resultItem.filter(function() {
                    if ($(this).find('img.lazyload-img').length && !$(this).hasClass('carousel-formed')) {
                        return true;
                    } else {
                        return false;
                    }
                });
                if (resultItem.length === 0) {
                    return;
                }
                resultItem.append('<a href="#" data-dir="next" class="next" /><a href="#" data-dir="prev" class="prev" />');

                resultItem.responsiveCarousel({
                    itemWrapper: 'div.carousel-cont',
                    itemSelector: '.carousel-item',
                    resizeItems: false,
                    itemsPerScreen: 1
                });
                resultItem.addClass('carousel-formed');

                resultItem.each(function() {
                    t.carousels.push('ResponsiveCarousel');
                });


                if (this.opts && this.opts.controller) {
                    this.opts.controller.carousels = this.carousels;
                }

                $(document)
                    .off('responsiveCarouselNext')
                    .on('responsiveCarouselNext', function(e, $elem, indx) {
                        var $elemToLoad = $elem.parent().children().eq(indx + 1);
                        if ($elemToLoad.length) {
                            tui.tweaks.lazyLoadPicture(null, $elemToLoad);
                        }
                    });
            };

            setPageNumberAndRange = function(data) {
                var recordsRange = '';
                var currentPageLabel = '';
                if (data.currentPageNumber) {
                    currentPageLabel = 'Page ' + ' ' + data.currentPageNumber;
                    var hotelCount = data.results.hotels.length;
                    var rangeStart, rangeEnd;
                    rangeStart = ((data.currentPageNumber - 1) * data.pageSize) + 1;
                    rangeEnd = rangeStart + hotelCount - 1;
                    recordsRange = '(' + rangeStart + ' - ' + rangeEnd + ')';
                }

                return {
                    paginationRecord: true,
                    recordsRange: recordsRange,
                    currentPageLabel: currentPageLabel
                };
            };

            scrollToLastItem = function(lastItem) {
                var scrollTo = lastItem.offset().top;
                if (lastItem.height() + 100 > $(window).height()) {
                    scrollTo = scrollTo + (lastItem.height() / 2);
                }
                $('html, body').animate({
                    scrollTop: scrollTo
                }, 1000);
            };

            var subscribed = false;

            /**
             * Common method to update the model in scope
             * the three main objects which are updated are
             * - facets
             * - results
             * - searchMetaData
             * - selectedFilters
             * @param  {[json object]} response [description]
             * @param  {[boolean]} append   [description]
             */
            $scope.updateScope = function(response, append, sortCriteria) {

                response = handleErrorResponse(response);

                var lastItem = resContainer.find('li.result-item').last();

                // UPDATING RESULTS
                var hotels = response.results.hotels,
                    paginationInfo = {};
                if (append) {
                    paginationInfo = setPageNumberAndRange(response);
                    $scope.results.hotels.push(paginationInfo);
                    $scope.results.hotels = $.merge($scope.results.hotels, hotels);
                } else {
                    $scope.results = response.results || [];
                }

                // UPDATING FACETS
                $scope.facets = response.facets || [];
                $scope.facetShowMore = response.facetShowMore || 99;

                // UPDATING SELECTEDFILTERS
                $scope.selectedfilters = response.selectedfilters;

                // UPDATE FAV FILTERS
                $scope.favFacets = getFavFacets(response);

                // UPDATING SEARCHMETADATA
                var metaDataObj = $.extend({}, {
                    count: response.totalResults * 1,
                    normalPackagesCount: response.totalResults,
                    showMore: (response.showMore) ? true : false,
                    showMoreLabel: response.showMoreLabel,
                    showMoreService: response.showMoreService,
                    currentPageNumber: response.currentPageNumber,
                    postdata: response.postdata,
                    showPriceType: (response.showPriceType) ? response.showPriceType : $scope.searchMetaData.showPriceType,
                    pageSize: response.pageSize,
                    noRecordsFoundLabel: response.noRecordsFoundLabel
                }, paginationInfo);

                if (!$scope.searchMetaData) {
                    $scope.searchMetaData = {};
                }

                $scope.searchMetaData = $.extend({}, $scope.searchMetaData, metaDataObj);

                if (hotelData.unspecifiedResults && hotelData.unspecifiedResults.length) {
                    $scope.showUnspecifiedUpfront = hotelData.showUnspecifiedUpfront;
                    $scope.searchMetaData.count = ($scope.searchMetaData.count * 1) + hotelData.unspecifiedResults.length;
                }

                if (append) {
                    scrollToLastItem(lastItem);
                }
                setTimeout(function() {
                    resizeAndCreateCarousel();
                    if (sortCriteria) {
                        ResultService.checkSortComboboxValue(sortCriteria);
                        ResultService.removeFirstSortOption();
                    }
                }, 200);


                // update scope from cookie
                ResultHelper.expandCollapseFacets($scope);
                if (!subscribed) {
                    $.subscribe('breakpointchange', function() {
                        $scope.$apply(function() {
                            ResultHelper.expandCollapseFacets($scope);
                        });
                    });
                }

                setTimeout(function() {
                    if ($scope.searchMetaData.showAllPages) {
                        showUnspecified();
                        $scope.searchMetaData.showAllPages = false;
                        $scope.searchMetaData.unspecifiedLinkClicked = true;
                    }
                }, 500);

            }; // end of updateScope
            /**
             * Checking if the response type is non JSON like HTML error page
             * response in actual implementation.
             * @type {[type]}
             */
            var handleErrorResponse = function(response) {
                var modifiedResponse = response;
                if (response && typeof response !== 'object') {
                    modifiedResponse = {};
                    modifiedResponse.results = {};
                    modifiedResponse.results.hotels = [];
                    modifiedResponse.facets = [];
                    modifiedResponse.totalResults = 0;
                    modifiedResponse.showMore = false;
                }
                return modifiedResponse;
            };
            var lastResizeTime = 0;

            var lazyLoadImage = function(resItem) {
                setTimeout(function() {
                    resItem.addClass('lazy-loaded');
                    tui.tweaks.lazyLoadPicture(null, resItem, 1);
                }, 50);
            };
            loadImageOnScroll = function() {
                $(window).on('scroll', function() {
                    clearTimeout(scrollTimer);
                    scrollTimer = setTimeout(function() {
                        resizeAndCreateCarousel();
                    }, 100);
                });
            };
            var resizeAndCreateCarousel = function(container) {
                if (!container) {
                    container = $('.results-container');
                }

                var currentTime = new Date();
                currentTime = currentTime.getTime();
                var diff = currentTime - lastResizeTime;
                if (diff < 500) {
                    return;
                } else {
                    lastResizeTime = currentTime;
                }

                container.find('li.result-item').not('.lazy-loaded').each(function() {
                    if (TUIUtil.isElementVisibleOnScreen($(this).find('.list-img'), true)) {
                        lazyLoadImage($(this));
                    }
                });

                setTimeout(function() {
                    if (!TUIUtil.ie8OrLower()) {
                        bindCarousel(container);
                    } else {
                        container.find('li.result-item').each(function() {
                            $(this).find('.carousel-item').not(':first').remove();
                        });
                    }
                }, 100);
            };

            if (!subscribed) {
                $.subscribe('windowResized', function() {
                    resizePictures();
                });
            }

            var resizePictures = function() {
                resizeAndCreateCarousel();
            };

            var checkHashOnPageLoad = function(newScope) {
                var storedVal = null;
                storedVal = sessionStorage.getItem(cHash);
                if (typeof storedVal === 'string') {
                    storedVal = $.parseJSON(storedVal);
                }

                if (storedVal) {
                    $scope.$root.$broadcast('locationHashChange', {
                        postJSON: storedVal
                    });
                }
            };

            var getFavFacets = function(response) {

                var favFacets = response.favFacets || [];
                if (favFacets.maxToShow) {
                    if (favFacets.maxToShow < favFacets.items.length) {
                        favFacets.showMore = true;
                    }
                    var allItems = $.merge([], favFacets.items);

                    var initialItems = favFacets.items.splice(0, favFacets.maxToShow);
                    favFacets.items = initialItems;
                    favFacets.allItems = allItems;
                }

                return favFacets;
            };

            $scope.noRefinedResults = function() {
                var noResults = false;
                if (ResultService.ajaxInProgress) {
                    noResults = false;
                } else if (!$scope.results) {
                    noResults = true;
                } else if ((!$scope.results.hotels || $scope.results.hotels.length === 0) && ($scope.facets && $scope.facets.length > 0)) {
                    noResults = true;
                    TUIUtil.printLog('No results afer refinement');
                }
                return noResults;
            };


            $scope.newConceptClass = function(cClass) {
                if (cClass && ($.inArray(cClass, TUIUtil.conceptClasses) !== -1)) {
                    return false;
                } else {
                    return true;
                }
            };

            $scope.allowHTML = function(htmlStr) {
                return $sce.trustAsHtml(htmlStr);
            };

            $scope.scrollToUnspecified = function() {

                if ($scope.searchMetaData.showMore) {
                    $scope.searchMetaData.showAllPages = true;
                    $scope.bindShowMore(1);
                } else {
                    showUnspecified();
                }
            };

            $scope.updateScopeWithExpandedFacets = function(facets) {
                var expandedFacets = sessionStorage.getItem('expandedFacets');

                if (expandedFacets) {
                    var facetValues = expandedFacets.split('|');

                    $.each(facetValues, function(index, facetValue) {
                        var isMultiLevelFacet = facetValue.indexOf(':'),
                            breakLoop = false;
                        $.each(facets, function(idx, facet) {
                            if (isMultiLevelFacet > -1 && facet.filterType === 'multi-level-checkbox') {
                                $.each(facet.items, function(id, item) {
                                    if (item.id === facetValue) {
                                        item.showList = true;
                                        breakLoop = true;
                                        return false;
                                    }
                                });
                            } else {
                                if (facet.id === facetValue) {
                                    facet.showList = true;
                                    breakLoop = true;
                                }
                            }

                            if (breakLoop) {
                                return false;
                            }
                        });
                    });
                }
            };
            var showUnspecified = function() {
                var delta = 0,
                    unspecifiedTop = 0,
                    totalHeight = 0;
                if (TUIUtil.getCurrentBreakPoint() === 'lg') {
                    delta = $('#search-panel').outerHeight() + 100;
                }


                $('html, body').scrollTop(delta);
                setTimeout(function() {
                    if ($('.unspecified-container').length) {
                        unspecifiedTop = $('.unspecified-container').offset().top;
                    }

                    if ($scope.results && $scope.results.hotels) {
                        totalHeight = $scope.results.hotels.length * $('li.result-item').first().outerHeight(true);
                    }
                    if (TUIUtil.getCurrentBreakPoint() !== 'lg') {
                        delta = 130;
                    }
                    $('html, body').scrollTop(unspecifiedTop - delta);
                }, 500);
            };
            var sEndTime = new Date().getTime();
            TUIUtil.printLog('Before Scope Update  Time (ms): ' + (sEndTime - window.sStartTime));
            var cHash = $location.hash();
            if (cHash && window.sessionStorage && window.sessionStorage.length && sessionStorage.getItem(cHash)) {
                setTimeout(function() { // Delay to allow search require modules to load
                    checkHashOnPageLoad($scope);
                }, 200);
            } else if (typeof hotelData !== 'undefined') {
                var newHotelData = ResultHelper.hotelData(hotelData);
                $scope.updateScope(newHotelData);
                if (hotelData.unspecifiedResults && hotelData.unspecifiedResults.length) {
                    $scope.unspecifiedResults = hotelData.unspecifiedResults;
                }
            }
            bindEvents();

            resWrapper.removeClass('hidden');
            setTimeout(function() {
                // Delay so that locationService hashUpdateDoesnt execute immediatly after page load.
                $rootScope.searchResultApp.appInitialized = true;
                resWrapper.removeClass('hidden');
            }, 100);
            var newEndTime = new Date().getTime();
            TUIUtil.printLog('After Scope Update  Time (ms): ' + (newEndTime - window.sStartTime));

            // breakpointchange is changed to windowResized
            var hotelDataUpdated = function() {
                $scope.$apply(function() {
                    var newHotelData = ResultHelper.hotelData(window.hotelData);
                    $scope.updateScope(newHotelData);
                    $scope.initialFacetCategories = newHotelData.facets;
                    setTimeout(function(){
                       $(window).scrollTop($('#searchNowBtn').offset().top)
                    },800);
                });
            }
            $.subscribe('packagesUpdate', hotelDataUpdated);
        }
    ]);
});

define('resultDirectives', [], function() {
    return angular.module('resultdirectives', [])
        .directive('hotelratingcount', function() { // helper/directive for showing star rating in search results listing
            return {
                restrict: 'C',
                link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters
                    if (!attrs.hotelrating) {
                        return;
                    }
                    var actualRatingNumber = parseFloat(attrs.hotelrating),
                        maxRating = $('body').data('max-rating') || 5;

                    if (actualRatingNumber > maxRating) { // Making 5.5 as 5
                        actualRatingNumber = maxRating;
                    }
                    var count = Math.floor(actualRatingNumber),
                        half = (actualRatingNumber) % 1 !== 0,
                        html,
                        i,
                        ratingText = $('body').data('rating-text');

                    if (ratingText === 'star') { // create html for showing star rating
                        html = ['<ul class="star-rating" >'];
                        for (i = 0; i < count; i++) {
                            html.push('<li class="icon-star"></li>');
                        }

                        if (half) {
                            html.push('<li class="icon-star-half" />');
                        }

                        html.push('</ul>');
                    } else { // create html for showing text rating as TTTT+ or SSS+ or FFF
                        html = ['<ul class="text-rating" >'];

                        for (i = 0; i < count; i++) {
                            html.push('<li>' + ratingText + '</li>');
                        }

                        if (half) {
                            html.push('<li>+</li>');
                        }

                        html.push('</ul>');
                    }
                    html = html.join('');
                    element[0].innerHTML = html;
                }
            };
        }).directive('guestratingele', function() { // helper/directive for showing star rating in search results listing
            return {
                restrict: 'C',
                link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters

                    var allowedRangeJson = $.parseJSON(attrs.allowedrange), // allowed range for slider
                        rangeMin = allowedRangeJson.min || 1,
                        rangeMax = allowedRangeJson.max || 10,
                        prevUIVal,
                        json = $.extend({}, $.parseJSON(attrs.rangesettings), {
                            start: function(event, ui) {

                                prevUIVal = ui.value; // store the current slider value to compare with final value
                            },
                            stop: function(event, ui) {
                                if (prevUIVal === ui.value || ui.value > rangeMax || ui.value < rangeMin) {
                                    return false; // no action required if no change in slider value after user action
                                } else {
                                    $scope.ratingFilterCallback(event, ui); // make call with changed slider value after user action
                                }

                            },
                            step: 1,
                            slide: function(event, ui) {
                                if (ui.value > rangeMax || ui.value < rangeMin) {
                                    return false; // no action required if slider value is going beyond allowed range
                                }
                                $scope.ratingViewCallback(event, ui); // update (increase/decrease) the rating value as user slide the handle
                            },
                            additionalOpts: attrs.rangesettings
                        });
                    addTouch();
                    $('#' + attrs.sliderid).slider(json)
                        .each(function() {

                            //
                            // Add labels to slider whose values
                            // are specified by min, max and whose
                            // step is set to 1
                            //

                            // Get the options for this slider
                            var opt = $(this).data().uiSlider.options;
                            var el;
                            // Get the number of possible values
                            var vals = opt.max - opt.min;

                            // Space out values
                            for (var i = opt.min; i <= opt.max; i++) {
                                var cssLeft = 0;
                                if (i === opt.min) {
                                    cssLeft = 0;
                                } else if (opt.min === 1) {
                                    cssLeft = (i - 1) / vals * 100;
                                } else if (opt.min === 0) {
                                    cssLeft = i / vals * 100;
                                }
                                if (i < rangeMin || i > rangeMax) {
                                    el = $('<label class="range-disabled">' + (i) + '</label>').css('left', cssLeft + '%');
                                } else {
                                    el = $('<label>' + (i) + '</label>').css('left', cssLeft + '%');
                                }
                                $('#' + attrs.sliderid).append(el);

                            }
                        });
                }

            };
        }).directive('hotelratingele', function() { // helper/directive for showing star rating in search results listing
            return {
                restrict: 'C',
                link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters
                    var html = element[0].innerHTML;
                    element[0].outerHTML = html;
                    $('#hotel-rating-top').html(attrs.guestrating);
                    var allowedRangeJson = $.parseJSON(attrs.allowedrange), // allowed range for slider
                        rangeMin = allowedRangeJson.min || 1,
                        rangeMax = allowedRangeJson.max || 5,
                        prevUIVal,
                        json = $.extend({}, $.parseJSON(attrs.rangesettings), {
                            start: function(event, ui) {
                                prevUIVal = ui.value; // store the current slider value to compare with final value
                            },
                            stop: function(event, ui) {
                                if (prevUIVal === ui.value || ui.value > rangeMax || ui.value < rangeMin) {
                                    return false; // no action required if no change in slider value after user action
                                } else {
                                    $scope.ratingFilterCallback(event, ui); // make call with changed slider value after user action
                                }
                            },
                            step: 1,
                            slide: function(event, ui) {
                                if (ui.value > rangeMax || ui.value < rangeMin) {
                                    return false; // no action required if slider value is going beyond allowed range
                                }
                                $scope.ratingViewCallback(event, ui); // update (increase/decrease) the rating value as user slide the handle

                            },
                            additionalOpts: attrs.rangesettings

                        });
                    addTouch();
                    $('#' + attrs.sliderid).slider(json)
                        .each(function() {
                            // Add labels to slider whose values
                            // are specified by min, max and whose
                            // step is set to 1
                            // Get the options for this slider
                            var opt = $(this).data().uiSlider.options;
                            var el;
                            // Get the number of possible values
                            var vals = opt.max - opt.min;

                            // Space out values
                            for (var i = opt.min; i <= opt.max; i++) {
                                var cssLeft = 0;
                                if (i === opt.min) {
                                    cssLeft = 0;
                                } else if (opt.min === 1) {
                                    cssLeft = (i - 1) / vals * 100;
                                } else if (opt.min === 0) {
                                    cssLeft = i / vals * 100;
                                }
                                if (i < rangeMin || i > rangeMax) {
                                    el = $('<label class="range-disabled">' + (i) + '</label>').css('left', cssLeft + '%');
                                } else {
                                    el = $('<label>' + (i) + '</label>').css('left', cssLeft + '%');
                                }

                                $('#' + attrs.sliderid).append(el);
                            }
                        });
                }
            };
        }).directive('budgetfilter', function() { // helper/directive for showing star rating in search results listing
            return {
                restrict: 'C',
                link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters
                    var html = element[0].innerHTML,
                        handle;

                    element[0].outerHTML = html;

                    var setMaxBasedOnSteps = function(json) {
                        json.originalMin = json.min;
                        json.originalMax = json.max;
                        var resultFirstTime = false,
                            step = $('#left-search').data('pricestep') || 50,
                            maxModulo = json.max % step,
                            minModulo = json.min % step;

                        if (json.max === json.value) {
                            resultFirstTime = true;
                        }
                        if (maxModulo) {
                            json.max += step - maxModulo;
                        }
                        if (minModulo) {
                            json.min -= minModulo;
                        }
                        return json;
                    };
                    var initJSON = $.parseJSON(attrs.rangesettings);
                    initJSON = setMaxBasedOnSteps(initJSON);

                    var json = $.extend({}, initJSON, {
                        stop: function(event, ui) {
                            json.value = ui.value;
                            if (json.value < json.originalMin) {
                                json.value = json.originalMin;
                            }
                            if (json.value > json.originalMax) {
                                json.value = json.originalMax;
                            }
                            TUIUtil.setPosition(handle);
                            $scope.ratingFilterCallback(event, json);
                        },
                        step: $('#left-search').data('pricestep') || 50,
                        animate: false,
                        slide: function(event, ui) {
                            json.value = ui.value;
                            if (json.value < json.originalMin) {
                                json.value = json.originalMin;
                            }
                            if (json.value > json.originalMax) {
                                json.value = json.originalMax;
                            }
                            TUIUtil.setPosition(handle);
                            $scope.budgetFilterViewCallback(event, json);
                        },
                        additionalOpts: attrs.rangesettings
                    });
                    var priceSlider = $('#' + attrs.sliderid);
                    addTouch();
                    priceSlider.slider(json);
                    priceSlider.find('.ui-slider-handle').each(function(i) {
                        $(this).show();
                        $(this).append('<label class="handle' + (i + 1) + '" />').find('label').eq(i - 1).text(TUIUtil.formatPrice(json.value, true));
                        handle = $(this).find('.handle' + (i + 1));
                        TUIUtil.setPosition(handle, json.value, json.originalMax);
                    });

                    // Appending min max
                    priceSlider.append('<em class="minimum">' + TUIUtil.formatPrice(json.originalMin, true) + '</em><em class="maximum">' + TUIUtil.formatPrice(json.originalMax, true) + '</em>');

                }
            };
        }).directive('startdateslider', function() { // helper/directive for showing star rating in search results listing
            return {
                restrict: 'C',
                link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters
                    var html = element[0].innerHTML,
                        handle;

                    element[0].outerHTML = html;
                    var d1Days;
                    var d2Days;
                    var labelsJSON = $.parseJSON(attrs.labels),
                        monthNamesArr = labelsJSON.months || ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'July', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                        dayNamesArr = labelsJSON.days || ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                        dateJSON = $.parseJSON(attrs.datesettings),
                        datesArr = [],
                        json = $.extend({}, $.parseJSON(attrs.rangesettings), {
                            stop: function(event, ui) {
                                $scope.startDateFilterCallback(ui, datesArr, dateJSON, json);
                                $(this).find('.handle1').removeClass('hidden');

                                if (ui.values[0] === ui.values[1]) {
                                    $(this).find('.handle1').addClass('hidden');
                                    return false;
                                }
                            },
                            step: 1,
                            range: true,
                            animate: false,
                            slide: function(event, ui) {
                                var $t = $(this);

                                var btn = $(ui.handle),
                                    label = btn.find('label');

                                if (label.hasClass('handle1')) {
                                    d1Days = TUIUtil.getDateSliderLabels(datesArr[ui.value], monthNamesArr, true);
                                    d2Days = TUIUtil.getDateSliderLabels(datesArr[json.values[1]], monthNamesArr, true);

                                } else {
                                    d2Days = TUIUtil.getDateSliderLabels(datesArr[ui.value], monthNamesArr, true);
                                    d1Days = TUIUtil.getDateSliderLabels(datesArr[json.values[0]], monthNamesArr, true);

                                }

                                $scope.startDateChangeCallback(d1Days, d2Days);
                                return true;

                            }
                        });

                    datesArr = TUIUtil.getDateChunksArray(dateJSON.firstDate, json.max + 1);

                    json.min = 0;
                    var durationSlider = $('#' + attrs.sliderid);
                    addTouch();
                    durationSlider.slider(json);
                    durationSlider.find('.ui-slider-handle').each(function(i) {
                        $(this).show();
                        if (i === 0) {
                            $(this).append('<label class="handle' + (i + 1) + '" />').find('label').eq(i - 1).text(TUIUtil.getDateSliderLabels(datesArr[json.values[0]], monthNamesArr, false));
                        } else {
                            $(this).append('<label class="handle' + (i + 1) + '" />').find('label').eq(i - 1).text(TUIUtil.getDateSliderLabels(datesArr[json.values[1]], monthNamesArr, false));
                        }
                        handle = $(this).find('.handle' + (i + 1));
                        TUIUtil.setPosition(handle);
                    });

                    // Appending min max
                    var d1 = TUIUtil.getDateSliderLabels(datesArr[0], monthNamesArr, false),
                        d2 = TUIUtil.getDateSliderLabels(datesArr[datesArr.length - 1], monthNamesArr, false);

                    d1Days = TUIUtil.getDateSliderLabels(datesArr[json.values[0]], monthNamesArr, true),
                        d2Days = TUIUtil.getDateSliderLabels(datesArr[json.values[1]], monthNamesArr, true);
                    durationSlider.append('<em class="minimum">' + d1 + '</em><em class="maximum">' + d2 + '</em>');

                    if (json.min !== json.values[0] && json.max !== json.values[1]) {
                        $scope.startDateChangeCallback(d1Days, d2Days);
                    }
                }
            };
        });
});

define('packageDetailDirective', [], function() {
    // helper/directive for showing star rating in search results listing
    return angular.module('packageDetails', []).directive('packagedetail', function() { // helper/directive for showing star rating in search results listing
        return {
            restrict: 'A',
            link: function($scope, element, attrs) { // default scope of app, current element & its attributes as parameters
                var packageStringArr = attrs.value.split(':DATE:');
                if (packageStringArr.length && packageStringArr.length > 1) {
                    var dateTokens = packageStringArr[1].split('/'),
                        _month = dateTokens[1];
                    var calendarLabel = $('#searchWhen').data('labels');
                    var dayName = '';
                    var date = new Date(dateTokens[2], dateTokens[1] - 1, dateTokens[0]);
                    if (date) {
                        var dayNumber = date.getDay();
                        if (dayNumber === 7) {
                            dayNumber = 0;
                        }
                        dayName = calendarLabel.dayNames[dayNumber];
                    }

                    if (calendarLabel.monthLabels[_month - 1].length) {
                        element[0].innerHTML = packageStringArr[0] + ' ' + dayName + ' ' + dateTokens[0] + ' ' + calendarLabel.monthLabels[_month - 1] + ' ' + dateTokens[2];
                    } else {
                        element[0].innerHTML = attrs.value;
                    }
                } else {
                    element[0].innerHTML = attrs.value;
                }
            }
        };
    });
});

define('applicationModule', ['resultHelper', 'resultService', 'facetService', 'locationService', 'resultController', 'resultDirectives', 'packageDetailDirective'], function(resultHelper, resultService, facetService, locationService, resultController, resultDirectives, packageDetailDirective) {
    /**
     * Angular Application Module 'SearchResult'
     * All other components like controller, services or factory components
     * should be injected into the searchResultApp (Global Variable)
     * like :
     * searchResultApp.controller('MyController', ['dependencies..', function(dependencies){ }]);
     *
     * @type {[type]}
     */
    var searchResultAppModule = angular.module('SearchResults', [resultController.name, resultHelper.name, resultService.name, facetService.name, locationService.name, resultDirectives.name, packageDetailDirective.name]);

    /**
     * Global App Configuration
     * @param  {[type]} $locationProvider [description]
     * @return {[type]}                   [description]
     */
    searchResultAppModule.config(['$locationProvider', function($locationProvider) {
        $locationProvider.hashPrefix('!');
    }]);

    searchResultAppModule.run(['$rootScope', function($rootScope) {
        $rootScope.searchResultApp = searchResultAppModule;
    }]);

    return searchResultAppModule;
});

var sStartTime = new Date().getTime();
//  check for existing jQuery
var jQuery = window.jQuery,
    //  check for old versions of jQuery
    oldjQuery = jQuery && !!jQuery.fn.jquery.match(/^1\.[0-4](\.|$)/),
    localJqueryPath = '../vendor/jquery.min',
    noConflict;

jQuery = jQuery || $;
//  register the current jQuery mostly it will be available
if (jQuery || $) {
    define('jquery', [], function() {
        return jQuery;
    });
} else {
    console.log('JQuery is not loaded before requirejs');
}

// As jquery.all.min.js will always be loaded its not necessary to load jquery below.
require.config({
    paths: {
        baseUrl: '../components',
        jquerymobile: '../vendor/jquery.mobile.custom',
        jqueryui: '../vendor/jquery-ui.min',
        jqueryhoverIntent: '../vendor/jquery.hoverIntent',
        handlebars: '../vendor/handlebars.min',
        handlebarsHelpers: '../helpers/handlebars-helpers',
        jqueryCookie: '../vendor/jquery.cookie',
        pubSub: '../vendor/jquery.ba-tinypubsub.min',
        async: '../vendor/async',
        text: '../vendor/text',
        helpers: '../helpers',
        common: '../common',
        counterWidget: '../vendor/counterWidget',
        vendor: '../vendor',
        enscroll: '../vendor/enscroll.min',
        lazyLoad: '../vendor/jquery-lazy-load',
        tuiTweaks: '../common/Tui.tweaks',
        owlCarousel: '../vendor/owl.carousel',
        requireLib: '../vendor/require',
        applicationModule: 'search-results/angular/app',
        resultHelper: 'search-results/angular/common/resultHelper',
        resultService: 'search-results/angular/common/resultService',
        facetService: 'search-results/angular/common/facetService',
        locationService: 'search-results/angular/locationService',
        resultController: 'search-results/angular/resultController',
        resultDirectives: 'search-results/angular/resultDirectives',
        packageDetailDirective: 'search-results/angular/packageDetailDirective'
    },
    shim: {
        handlebars: {
            exports: 'Handlebars'
        },
        pubSub: {
            exports: 'PubSub',
            deps: ['jquery']
        },
        jqueryCookie: {
            exports: 'jqueryCookie',
            dep: ['jquery']
        },
        enscroll: ['jquery'],
        lazyLoad: ['jquery'],
        tuiTweaks: ['lazyLoad'],
        counterWidget: ['jquery'],
        owlCarousel: ['jquery'],

        'tui.cards.hotelcard': ['jquery'],
        'tui.swipe': ['tui.commonUX.lazyLoad', 'tui.equalHeight'],
        '../vendor/placeholder.min': ['jquery']
    }
});

require([
        'jquery',
        'jqueryCookie',
        'base',
        'search-panel/search-panel-v3',
        'search-results/results-v3',
        '../nordics/epifind.nordics',
        'tui.topnavigation',
        'tuiTweaks',
        'applicationModule'
    ],
    function($, jqueryCookie, base, SearchPanel, Results, searchApp) {
        'use strict';

        var init = function() {

            var searchPanel = $('#search-panel');
            searchPanel.removeClass('hidden');

            //  search panel
            tuiConfig.searchPanel = new SearchPanel(searchPanel);

            // Dockable Search Panel
            if (!TUIUtil.isTouchDevice()) {
                $('#search-panel[data-dockable]').dockable({
                    vOffset: $('#pg_boka-resa').length ? 92 : false,
                    dontDockCondition: tuiConfig.searchPanel.isFlyoutOpen,
                    name: 'searchPanel'
                });
            }

            //  results page
            var results = $('#results');
            if (results.length) {
                new Results(results, {
                    searchPanel: tuiConfig.searchPanel || false
                });
            }

            if (TUIUtil.isTouchDevice()) {
                $('body').addClass('touch');
            }
            var sEndTime = new Date().getTime();
            TUIUtil.printLog('Search Render Time (ms): ' + (sEndTime - sStartTime));
        };

        TUIUtil.updateCurrencyParams();
        // Checking if angular app then allow the angular app to load first
        // and then execute the require.
        require(['applicationModule'],
            function(app) {
                angular.bootstrap(document, [app.name], {
                    strictDi: true
                });
            }
        );

        init();

        var sEndTime = new Date().getTime();
        TUIUtil.printLog('Search Require load Time (ms): ' + (sEndTime - sStartTime));

        // window.tui = tuiConfig;
        window.tuiConfig = tuiConfig;
    });

define("../pages/search-results", function() {});


require(["../pages/search-results"]);